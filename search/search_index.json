{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>This is the documentation page of Skipper. Skipper is an HTTP router and reverse proxy for service composition. It\u2019s designed to handle large amounts of dynamically configured HTTP route definitions (&gt;800000 routes) with detailed lookup conditions, and flexible augmentation of the request flow with filters. It can be used out of the box or extended with custom lookup, filter logic and configuration sources.</p>"},{"location":"#http-proxy","title":"HTTP Proxy","text":"<p>Skipper identifies routes based on the requests\u2019 properties, such as path, method, host and headers using the predicates. It allows the modification of the requests and responses with filters that are independently configured for each route. Learn here more about how it works.</p>"},{"location":"#kubernetes-ingress","title":"Kubernetes Ingress","text":"<p>Skipper can be used to run as a Kubernetes Ingress controller. Details with examples of Skipper\u2019s capabilities and an overview can be found in the ingress-controller deployment docs.</p>"},{"location":"data-clients/eskip-file/","title":"Eskip File","text":"<p>Eskip file dataclient can be used to serve static defined routes, read from an eskip file. The file format eskip shows your route definitions in a clear way:</p> <pre><code>% cat example.eskip\nhello: Path(\"/hello\") -&gt; \"https://www.example.org\"\n</code></pre> <p>The Skipper project has two binaries, one is <code>skipper</code>, the other is <code>eskip</code>. Eskip can be used to validate the syntax of your routes file before reloading a production server:</p> <pre><code>% eskip check example.eskip\n</code></pre> <p>To run Skipper serving routes from an <code>eskip</code> file you have to use <code>-routes-file &lt;file&gt;</code> parameter:</p> <pre><code>% skipper -routes-file example.eskip\n</code></pre> <p>A more complicated example with different routes, matches, predicates and filters shows that you can name your route and use preconditions and create, change, delete HTTP headers as you like:</p> <pre><code>% cat complicated_example.eskip\nhostHeaderMatch:\n         Host(\"^skipper.teapot.org$\")\n         -&gt; setRequestHeader(\"Authorization\", \"Basic YWRtaW46YWRtaW5zcGFzc3dvcmQK\")\n         -&gt; \"https://target-to.auth-with.basic-auth.enterprise.com\";\nbaiduPathMatch:\n        Path(\"/baidu\")\n        -&gt; setRequestHeader(\"Host\", \"www.baidu.com\")\n        -&gt; setPath(\"/s\")\n        -&gt; setQuery(\"wd\", \"godoc skipper\")\n        -&gt; \"http://www.baidu.com\";\ngoogleWildcardMatch:\n        *\n        -&gt; setPath(\"/search\")\n        -&gt; setQuery(\"q\", \"godoc skipper\")\n        -&gt; \"https://www.google.com\";\nyandexWildcardIfCookie:\n        * &amp;&amp; Cookie(\"yandex\", \"true\")\n        -&gt; setPath(\"/search/\")\n        -&gt; setQuery(\"text\", \"godoc skipper\")\n        -&gt; tee(\"http://127.0.0.1:12345/\")\n        -&gt; \"https://yandex.ru\";\n</code></pre> <p>The former example shows 4 routes: hostHeaderMatch, baiduPathMatch, googleWildcardMatch and yandexWildcardIfCookie.</p> <ul> <li>hostHeaderMatch:<ul> <li>used if HTTP host header is exactly: \u201cskipper.teapot.org\u201d,</li> <li>sets a Basic Authorization header and</li> <li>sends the modified request to https://target-to.auth-with.basic-auth.enterprise.com</li> </ul> </li> <li>baiduPathMatch:<ul> <li>used when the request patch matches /baidu</li> <li>it will set the Host header to the proxy request</li> <li>it will set the path from /baidu to /s</li> <li>it will set the querystring to \u201cws=godoc skipper\u201d and</li> <li>sends the modified request to http://baidu.com</li> </ul> </li> <li>googleWildcardMatch:<ul> <li>used as default if no other route matches</li> <li>it will set the path to /search</li> <li>it will set the querystring to \u201cq=godoc skipper\u201d and</li> <li>sends the modified request to https://www.google.com</li> </ul> </li> <li>yandexWildcardIfCookie:<ul> <li>used as default if a Cookie named \u201cyandex\u201d has the value \u201ctrue\u201d</li> <li>it will set the path to /search/</li> <li>it will set the querystring to \u201ctext=godoc skipper\u201d</li> <li>it will send a copy of the modified request to http://127.0.0.1:12345/ (similar to unix <code>tee</code>) and drop the response and</li> <li>sends the modified request to https://yandex.ru</li> </ul> </li> </ul> <p>More examples you find in eskip file format description, in filters and in predicates.</p> <p>Eskip file format is also used if you print your current routes in skipper, for example:</p> <pre><code>% curl localhost:9911/routes\n*\n  -&gt; setResponseHeader(\"Content-Type\", \"application/json; charset=utf-8\")\n  -&gt; inlineContent(\"{\\\"foo\\\": 3}\")\n  -&gt; &lt;shunt&gt;\n</code></pre>"},{"location":"data-clients/eskip-remote/","title":"Remote eskip","text":"<p>Skipper can fetch routes in eskip format over HTTP:</p> <pre><code>curl https://opensource.zalando.com/skipper/data-clients/example.eskip\nhello: Path(\"/hello\") -&gt; \"https://www.example.org\"\n\nskipper -routes-urls=https://opensource.zalando.com/skipper/data-clients/example.eskip\n\ncurl -s http://localhost:9090/hello | grep title\n    &lt;title&gt;Example Domain&lt;/title&gt;\n</code></pre> <p>You may use multiple urls separated by comma and configure url poll interval via <code>-source-poll-timeout</code> flag.</p>"},{"location":"data-clients/etcd/","title":"etcd","text":"<p>etcd is an open-source distributed key value store: https://github.com/etcd-io/etcd. Skipper can use it as a route configuration storage and continuously synchronize the routing from etcd.</p>"},{"location":"data-clients/etcd/#why-storing-skipper-routes-in-etcd","title":"Why storing Skipper routes in etcd?","text":"<p>When running multiple Skipper instances, changing the configuration of each instance by accessing the instances directly on the fly can be complex and error-prone. With etcd, we need to update the routes only in etcd and each Skipper instance will synchronize its routing from the new version.</p> <p>Further benefits of using etcd are improved resiliency and the usage of a standard configuration storage for various system components of a distributed system, not only Skipper.</p> <p>Note: in case of Kubernetes, the standard recommended way is to use the Kubernetes Ingress API.</p>"},{"location":"data-clients/etcd/#starting-skipper-with-etcd","title":"Starting Skipper with etcd","text":"<p>Example:</p> <pre><code>skipper -etcd-urls http://localhost:2379,http://localhost:4001\n</code></pre> <p>An additional startup option is the <code>-etcd-prefix</code>. When using multiple Skipper deployments with different purpose, this option allows us to store separate configuration sets for them in the same etcd cluster. Example:</p> <pre><code>skipper -etcd-urls https://cluster-config -etcd-prefix skipper1\n</code></pre> <p>Note: when the etcd URL points to an etcd proxy, Skipper will internally use the proxy only to resolve the URLs of the etcd replicas, and access them for the route configuration directly.</p>"},{"location":"data-clients/etcd/#etcd-version","title":"etcd version","text":"<p>Skipper uses currently the V2 API of etcd.</p>"},{"location":"data-clients/etcd/#storage-schema","title":"Storage schema","text":"<p>Skipper expects to find the route configuration by default at the <code>/v2/keys/skipper/routes</code> path. In this path, the \u2018skipper\u2019 segment can be optionally overridden by the <code>-etcd-prefix</code> startup option.</p> <p>The <code>/v2/keys/skipper/routes</code> node is a directory that contains the routes as individual child nodes, accessed by the path <code>/v2/keys/skipper/routes/&lt;routeID&gt;</code>. The value of the route nodes is the route expression without the route ID in eskip format.</p>"},{"location":"data-clients/etcd/#maintaining-route-configuration-in-etcd","title":"Maintaining route configuration in etcd","text":"<p>etcd (v2) allows generic access to its API via the HTTP protocol. It also provides a supporting client tool: etcdctl. Following the above described schema, both of them can be used to maintain Skipper routes. In addition, Skipper also provides a supporting client tool: eskip, which can provide more convenient access to the routes in etcd.</p> <p>Getting all routes, a single route, insert or update and delete via HTTP:</p> <pre><code>curl http://localhost:2379/v2/keys/skipper/routes\ncurl http://localhost:2379/v2/keys/skipper/routes/hello\ncurl -X PUT -d 'value=* -&gt; status(200) -&gt; inlineContent(\"Hello, world!\") -&gt; &lt;shunt&gt;' http://localhost:2379/v2/keys/skipper/routes/hello\ncurl -X DELETE http://localhost:2379/v2/keys/skipper/routes/hello\n</code></pre> <p>Getting all route IDs, a route expression stored with an ID, insert or update, and delete with etcdctl:</p> <pre><code>etcdctl --endpoints http://localhost:2379,http://localhost:4001 ls /skipper/routes\netcdctl --endpoints http://localhost:2379,http://localhost:4001 get /skipper/routes/hello\netcdctl --endpoints http://localhost:2379,http://localhost:4001 set -- /skipper/routes/hello '* -&gt; status(200) -&gt; inlineContent(\"Hello, world!\") -&gt; &lt;shunt&gt;'\netcdctl --endpoints http://localhost:2379,http://localhost:4001 rm /skipper/routes/bello\n</code></pre> <p>We use the name \u2018eskip\u2019 for two related concepts: the eskip syntax of route configuration and the eskip command line tool. The command line tool can be used to check the syntax of skipper routes, format route files, prepend or append filters to multiple routes, and also to access etcd.</p> <p>Getting all routes, a single route, insert or update and delete with eskip:</p> <pre><code>eskip print -etcd-urls http://localhost:2379,http://localhost:4001\neskip print -etcd-urls http://localhost:2379,http://localhost:4001 | grep hello\neskip upsert -etcd-urls http://localhost:2379,http://localhost:4001 -routes 'hello: * -&gt; status(200) -&gt; inlineContent(\"Hello, world!\") -&gt; &lt;shunt&gt;'\neskip delete -etcd-urls http://localhost:2379,http://localhost:4001 -ids hello\n</code></pre> <p>When storing multiple configuration sets in etcd, we can use the <code>-etcd-prefix</code> to distinguish between them.</p> <p>Instead of using routes inline, it may be more convenient to edit them in a file and store them in etcd directly from the file.</p> <p>Contents of example.eskip:</p> <pre><code>hello: * -&gt; status(200) -&gt; inlineContent(\"Hello, world!\") -&gt; &lt;shunt&gt;;\nhelloTest: Path(\"/test\") -&gt; status(200) -&gt; inlineContent(\"Hello, test!\") -&gt; &lt;shunt&gt;;\n</code></pre> <p>Updating those routes in etcd that are defined in the file, or inserting them from the file in case they don\u2019t exist in etcd, yet:</p> <pre><code>eskip upsert -etcd-urls http://localhost:2379,http://localhost:4001 example.eskip\n</code></pre> <p>The above command won\u2019t modify or delete those routes, whose ID is missing from example.eskip. To fully sync a set of routes from a file to etcd, use the reset subcommand:</p> <pre><code>eskip reset -etcd-urls http://localhost:2379,http://localhost:4001 example.eskip\n</code></pre> <p>For more information see the documentation or <code>eskip -help</code>.</p>"},{"location":"data-clients/kubernetes/","title":"Kubernetes","text":"<p>Skipper\u2019s Kubernetes dataclient can be used, if you want to run Skipper as kubernetes-ingress-controller. It will get its route information from provisioned Ingress Objects.</p>"},{"location":"data-clients/kubernetes/#kubernetes-ingress-controller-deployment","title":"Kubernetes Ingress Controller deployment","text":"<p>How to install Skipper ingress-controller for cluster operators.</p>"},{"location":"data-clients/kubernetes/#kubernetes-ingress-usage","title":"Kubernetes Ingress Usage","text":"<p>Find out more how to use Skipper ingress features for deployers.</p>"},{"location":"data-clients/kubernetes/#why-to-choose-skipper","title":"Why to choose Skipper?","text":"<p>Kubernetes is a fast changing environment and traditional http routers are not made for frequently changing routing tables. Skipper is a http proxy made to apply updates very often. Skipper is used in production with more than 200.000 routing table entries. Skipper has Filters to change http data and Predicates to change the matching rules, both can combined and chained. You can set these in ingress.yaml files to build resiliency patterns like load shedding, ratelimit or circuitbreaker. You can also use them to build more high-level deployment patterns, for example feature toggles, shadow traffic or blue-green deployments.</p> <p>Skipper\u2019s main features:</p> <ul> <li>Filters - create, update, delete all kind of HTTP data</li> <li>collection of base http manipulations:      for example manipulating Path, Querystring, HTTP Headers and redirect handling</li> <li>cookie handling</li> <li>circuitbreakers</li> <li>ratelimit: based on client or backend data</li> <li>Shadow traffic filters</li> <li>Predicates - advanced matching capability</li> <li>URL Path match: <code>Path(\"/foo\")</code></li> <li>Host header match: <code>Host(\"^www.example.org$\")</code></li> <li>Querystring: <code>QueryParam(\"featureX\")</code></li> <li>Cookie based: <code>Cookie(\"alpha\", /^enabled$/)</code></li> <li>source IP allowlist: <code>Source(\"1.2.3.4/24\")</code> or <code>ClientIP(\"1.2.3.4/24\")</code></li> <li>time based interval</li> <li>traffic by percentage supports also sticky sessions</li> <li>Kubernetes integration</li> <li>All Filters and Predicates can be used with 2 annotations<ul> <li>Predicates: <code>zalando.org/skipper-predicate</code></li> <li>Filters: <code>zalando.org/skipper-filter</code></li> </ul> </li> <li>Custom routes can be defined with the annotation <code>zalando.org/skipper-routes</code></li> <li>RouteGroup CRD to support all skipper features without limitation</li> <li>monitoring</li> <li>opentracing</li> <li>access logs with fine granular control of logs by status codes</li> <li>Blue-Green deployments, with another Ingress annotation <code>zalando.org/backend-weights</code></li> </ul>"},{"location":"data-clients/route-string/","title":"Route String","text":"<p>Route string dataclient can be used to create simple demo applications, for example if you want to show traffic switching or ratelimiting or just need to serve some json in your demo.</p>"},{"location":"data-clients/route-string/#serve-text","title":"Serve text","text":"<p>Serve with <code>Content-Type: text/plain; charset=utf-8</code></p> <p>Example (Open your browser http://localhost:9090/):</p> <pre><code>skipper -inline-routes '* -&gt; inlineContent(\"Hello, world!\") -&gt; &lt;shunt&gt;'\n</code></pre> <p>Docker Example (Open your browser http://localhost:9090/):</p> <pre><code>docker run -p 9090:9090 -it registry.opensource.zalan.do/teapot/skipper:latest skipper -inline-routes '* -&gt; inlineContent(\"Hello, world!\") -&gt; &lt;shunt&gt;'\n</code></pre>"},{"location":"data-clients/route-string/#serve-html-with-css","title":"Serve HTML with CSS","text":"<p>Serve with <code>Content-Type: text/html; charset=utf-8</code></p> <p>Example (Open your browser http://localhost:9090/):</p> <pre><code>skipper -inline-routes '* -&gt; inlineContent(\"&lt;html&gt;&lt;body style=\\\"background-color: orange;\\\"&gt;&lt;/body&gt;&lt;/html&gt;\") -&gt; &lt;shunt&gt;'\n</code></pre> <p>Docker Example (Open your browser http://localhost:9090/):</p> <pre><code>docker run -p 9090:9090 -it registry.opensource.zalan.do/teapot/skipper:latest skipper -inline-routes '* -&gt; inlineContent(\"&lt;html&gt;&lt;body style=\\\"background-color: orange;\\\"&gt;&lt;/body&gt;&lt;/html&gt;\") -&gt; &lt;shunt&gt;'\n</code></pre>"},{"location":"data-clients/route-string/#serve-json","title":"Serve JSON","text":"<p>Serve with <code>Content-Type: application/json; charset=utf-8</code></p> <p>Example (Open your browser http://localhost:9090/):</p> <pre><code>skipper -inline-routes '* -&gt; inlineContent(\"{\\\"foo\\\": 3}\", \"application/json; charset=utf-8\") -&gt; &lt;shunt&gt;'\n</code></pre> <p>Docker Example (Open your browser http://localhost:9090/):</p> <pre><code>docker run -p 9090:9090 -it registry.opensource.zalan.do/teapot/skipper:latest skipper -inline-routes '* -&gt; inlineContent(\"{\\\"foo\\\": 3}\", \"application/json; charset=utf-8\") -&gt; &lt;shunt&gt;'\n</code></pre>"},{"location":"data-clients/route-string/#proxy-to-a-given-url","title":"Proxy to a given URL","text":"<p>If you just have to build a workaround and you do not want to use socat to do a tcp proxy, but proxy http, you can do:</p> <pre><code>% skipper -inline-routes '* -&gt; \"https://my-new-backend.example.org/\"'\n</code></pre>"},{"location":"kubernetes/east-west-usage/","title":"East-West aka svc-to-svc","text":""},{"location":"kubernetes/east-west-usage/#east-west-usage","title":"East-West Usage","text":"<p>If you run Skipper with an East-West setup, you can use the configured ingress also to do service-to-service calls, bypassing your ingress loadbalancer and stay inside the cluster. You can connect via HTTP to your application based on its ingress configuration.</p> <p>Example:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: demo\n  namespace: default\nspec:\n  rules:\n  - host: demo.skipper.cluster.local\n    http:\n      paths:\n      - backend:\n          service:\n            name: example\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>Or as a RouteGroup:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: demo\n  namespace: default\nspec:\n  hosts:\n  - demo.skipper.cluster.local\n  backends:\n  - name: backend\n    type: service\n    serviceName: example\n    servicePort: 80\n  defaultBackends:\n  - backendName: backend\n</code></pre> <p>Your clients inside the cluster should call this example with <code>demo.skipper.cluster.local</code> in their host header. Example from inside a container:</p> <pre><code>curl http://demo.skipper.cluster.local/\n</code></pre> <p>You can also use the same ingress or RouteGroup object to accept internal and external traffic:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: demo\n  namespace: default\nspec:\n  rules:\n  - host: demo.example.com\n    http:\n      paths:\n      - backend:\n          service:\n            name: example\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n  - host: demo.skipper.cluster.local\n    http:\n      paths:\n      - backend:\n          service:\n            name: example\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>Or, again, as a RouteGroup:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: demo\n  namespace: default\nspec:\n  hosts:\n  - demo.skipper.cluster.local\n  - demo.example.com\n  backends:\n  - name: backend\n    type: service\n    serviceName: example\n    servicePort: 80\n  defaultBackends:\n  - backendName: backend\n</code></pre> <p>Metrics will change, because skipper stores metrics per HTTP Host header, which changes with cluster internal calls from <code>demo.example.org</code> to <code>demo.default.skipper.cluster.local</code>.</p> <p>You can use all features as defined in Ingress Usage, Filters, Predicates via annotations as before and also custom-routes.</p>"},{"location":"kubernetes/external-addresses/","title":"External Addresses (External Name)","text":"<p>In Kubernetes, it is possible to define services with external names (type=ExternalName). For Ingress objects, Skipper supports these services, if enabled by <code>-enable-kubernetes-external-names</code>. Skipper generates routes from the Ingress objects that reference one or more external name service, that will have a backend pointing to the network address defined by the specified service.</p> <p>Route groups don\u2019t support services of type ExternalName, but they support network backends, and even LB backends with explicit endpoints with custom endpoint addresses. This way, it is possible to achieve the same with route groups.</p> <p>For both the Ingress objects and the route groups, the accepted external addresses must be explicitly allowed by listing regexp expressions of which at least one must be matched by the domain name of these addresses. The allow list is a startup option, defined via command line flags or in the configuration file. Enforcing this list happens only in the Kubernetes Ingress mode of Skipper.</p>"},{"location":"kubernetes/external-addresses/#specifying-allowed-external-names-via-command-line-flags","title":"Specifying allowed external names via command line flags","text":"<p>For compatibility reasons, the validation needs to be enabled with an explicit toggle:</p> <pre><code>skipper -kubernetes \\\n-enable-kubernetes-external-names \\\n-kubernetes-only-allowed-external-names \\\n-kubernetes-allowed-external-name \"^one[.]example[.]org$\" \\\n-kubernetes-allowed-external-name \"^two[.]example[.]org$\"\n</code></pre>"},{"location":"kubernetes/external-addresses/#specifying-allowed-external-names-via-a-config-file","title":"Specifying allowed external names via a config file","text":"<p>For compatibility reasons, the validation needs to be enabled with an explicit toggle:</p> <pre><code>enable-kubernetes-external-names: true\nkubernetes-only-allowed-external-names: true\nkubernetes-allowed-external-names:\n- ^one[.]example[.]org$\n- ^two[.]example[.]org$\n</code></pre>"},{"location":"kubernetes/ingress-backends/","title":"Kubernetes Backend Deployments","text":""},{"location":"kubernetes/ingress-backends/#kubernetes-race-condition-problem","title":"Kubernetes Race Condition problem","text":"<p>As described in #652, there is a problem that exists in Kubernetes, while terminating Pods. Terminating Pods could be graceful, but the nature of distributed environments will show failures, because not all components in the distributed system changed already their state. When a Pod terminates, the controller-manager has to update the <code>endpoints</code> of the Kubernetes <code>service</code>.  Additionally Skipper has to get this endpoints list. Skipper polls the kube-apiserver every <code>-source-poll-timeout=&lt;ms&gt;</code>, which defaults to 3000. Reducing this interval or implementing watch will only reduce the timeframe, but not fix the underlying race condition.</p> <p>Mitigation strategies can be different and the next section document strategies for application developers to mitigate the problem.</p>"},{"location":"kubernetes/ingress-backends/#teardown-strategies","title":"Teardown strategies","text":"<p>An application that is target of an ingress can circumvent HTTP code 504s Gateway Timeouts with these strategies:</p> <ol> <li>use Pod lifecycle hooks</li> <li>use a SIGTERM handler to switch <code>readinessProbe</code> to unhealthy and exit later, or just wait for SIGKILL terminating the process.</li> </ol>"},{"location":"kubernetes/ingress-backends/#pod-lifecycle-hooks","title":"Pod Lifecycle Hooks","text":"<p>Kubernetes Pod Lifecycle Hooks in the Pod spec can have a <code>preStop</code> command which executes for example a binary. The following will execute the binary <code>sleep</code> with argument <code>20</code> to wait 20 seconds before terminating the containers within the Pod:</p> <pre><code>lifecycle:\n  preStop:\n    exec:\n      command: [\"sleep\",\"20\"]\n</code></pre> <p>or use sleep in kubelet without the need of the binary <code>sleep</code> in your container:</p> <pre><code>lifecycle:\n  preStop:\n    sleep:\n      seconds: 20\n</code></pre> <p>20 seconds should be enough to fade your Pod out of the endpoints list and Skipper\u2019s routing table.</p>"},{"location":"kubernetes/ingress-backends/#sigterm-handling-in-containers","title":"SIGTERM handling in Containers","text":"<p>An application can implement a SIGTERM handler, that changes the <code>readinessProbe</code> target to unhealthy for the application instance. This will make sure it will be deleted from the endpoints list and from Skipper\u2019s routing table. Similar to Pod Lifecycle Hooks you could sleep 20 seconds and after that terminate your application or you just wait until SIGKILL will cleanup the instance after 60s.</p> <pre><code>go func() {\n    var sigs chan os.Signal\n    sigs = make(chan os.Signal, 1)\n    signal.Notify(sigs, syscall.SIGTERM)\n    for {\n        select {\n            case &lt;-sigs:\n               healthCheck = unhealthy\n               time.Sleep(20*time.Second)\n               os.Exit(0)\n        }\n    }\n}()\n</code></pre>"},{"location":"kubernetes/ingress-controller/","title":"Skipper Ingress Controller","text":"<p>This documentation is meant for cluster operators and describes how to install Skipper as Ingress-Controller in your Kubernetes Cluster.</p>"},{"location":"kubernetes/ingress-controller/#why-you-should-use-skipper-as-ingress-controller","title":"Why you should use Skipper as ingress controller?","text":"<p>Baremetal load balancers perform really well, but their configuration is not updated frequently and most of the installations are not meant for rapid change. With the introduction of Kubernetes this assumption is no longer valid and there was a need for a HTTP router which supported backend routes which changed very frequently. Skipper was initially designed for a rapidly changing routing tree and subsequently used to implement an ingress controller in Kubernetes.</p> <p>Cloud load balancers scale well and can be updated frequently, but do not provide many features. Skipper has advanced resiliency and deployment features, which you can use to enhance your environment. For example, ratelimiters, circuitbreakers, blue-green deployments, shadow traffic and more \u2013 see Skipper Ingress Usage.</p>"},{"location":"kubernetes/ingress-controller/#comparison-with-other-ingress-controllers","title":"Comparison with other Ingress Controllers","text":"<p>At Zalando we chose to run <code>kube-ingress-aws-controller</code> with <code>skipper ingress</code> as the target group. While AWS load balancers give us features like TLS termination, automated certificate rotation, possible WAF, and Security Groups, the HTTP routing capabilities are very limited. Skipper\u2019s main advantage compared to other HTTP routers is matching and changing HTTP. Another advantage for us and for skipper users in general is that defaults with kube-ingress-aws-controller just work as you would expect. For lower latency, safety, and cost reasons you can also use Network Load Balancer (NLB) instead of Application Load Balancer (ALB). We tested two cases (Skipper backends were pre-scaled and not changed):</p> <ol> <li>A hard switch to a cold NLB with 1 million requests per second (RPS). A similar test with 100k RPS with ALB results in client visible error rates and high latency percentiles.</li> <li>A 6h test with 2k RPS showed regular spikes in p999 latency to more than 100ms in for ALB. NLB showed a flat p999 latency of 25-35ms for the same workload.</li> </ol> <p>There are a number of other ingress controllers including traefik, nginx, haproxy or aws-alb-ingress-controller. Why not one of these?</p> <p>HAproxy and Nginx are well understood and good TCP/HTTP proxies, that were built before Kubernetes. As a result, the first drawback is their reliance on static configuration files which comes from a time when routes and their configurations were relatively static. Secondly, the list of annotations to implement even basic features are already quite a big list for users. Skipper was built to support dynamically changing route configurations, which happens quite often in Kubernetes. Other advantage of using Skipper is that we are able to easily implement automated canary deployments, automated blue-green deployments or shadow traffic.</p> <p>However there are some features that have better support in <code>aws-alb-ingress-controller</code>, <code>HAproxy</code> and <code>nginx</code>. For instance the <code>sendfile()</code> operation. If you need to stream a large file or large amount of files, then you may want to go for one of these options.</p> <p><code>aws-alb-ingress-controller</code> directly routes traffic to your Kubernetes services, which is both good and bad, because it can reduce latency, but comes with the risk of depending on kube-proxy routing. <code>kube-proxy</code> routing can take up to 30 seconds, ETCD ttl, for finding pods from dead nodes. In Skipper we passively observe errors from endpoints and are able to drop these from the load balancer members. We add these to an actively checked member pool, which will enable endpoints if these are healthy again from skipper\u2019s point of view. Additionally the <code>aws-alb-ingress-controller</code> does not support features like ALB sharing, or Server Name Indication which can reduce costs. Features like path rewriting are also not currently supported.</p> <p><code>Traefik</code> has a good community and support for Kubernetes. Skipper originates from Project Mosaic which was started in 2015. Back then Traefik was not yet a mature project and still had time to go before the v1.0.0 release. Traefik also does not currently support our OpenTracing provider. It also did not support traffic splitting when we started stackset-controller for automated traffic switching. We have also recently done significant work on running Skipper as API gateway within Kubernetes, which could potentially help many teams that run many small services on Kubernetes. Skipper predicates and filters are a powerful abstraction which can enhance the system easily.</p>"},{"location":"kubernetes/ingress-controller/#comparison-with-service-mesh","title":"Comparison with service mesh","text":"<p>Why run Skipper and not Istio, Linkerd or other service-mesh solutions?</p> <p>Skipper has a Kubernetes native integration, which is reliable, proven in production since end of 2015 as of March 2019 run in 112 Kubernetes clusters at Zalando. Skipper already has most of the features provided by service meshes:</p> <ul> <li>Authentication/Authorization in Kubernetes ingress, and can also integrate a custom service with webhook</li> <li>Diagnosis tools that support latency, bandwidth throttling, random content and more.</li> <li>Rich Metrics which  you can enable and disable in the Prometheus format.</li> <li>Support for different Opentracing providers including jaeger, lightstep and instana</li> <li>Ratelimits support with cluster ratelimits as a pending solution, which enables you to stop login attacks easily</li> <li>Connects to endpoints directly, instead of using Kubernetes services</li> <li>Retries requests, if the request can be safely retried, which is only the case if the error happens on the TCP/IP connection establishment or a backend whose requests are defined as idempotent.</li> <li>Simple East-West Communication which enables proper communication paths without the need of yet another tool to do service discovery. See how to run skipper as API Gateway with East-West setup, if you want to run this powerful setup. Kubernetes, Skipper and DNS are the service discovery in this case.</li> <li>Blue-green deployments  with automation if you like to use stackset-controller</li> <li>shadow-traffic  to determine if the new version is able to handle the traffic the same as the old one</li> <li>A simple way to do A/B tests</li> <li>You are free to use cloud providers TLS terminations and certificate rotation, which is reliable and secure. Employees cannot download private keys and certificates are certified by a public CA. Many mTLS setups rely on insecure CA handling and are hard to debug in case of  failure.</li> <li>We are happy to receive issues and pull requests in our repository, but if you need a feature which cannot be implemented upstream, you are also free to use skipper as a library and create internal features to do whatever you want.</li> </ul> <p>With Skipper you do not need to choose to go all-in and you are able to add features as soon as you need or are comfortable.</p>"},{"location":"kubernetes/ingress-controller/#what-is-an-ingress-controller","title":"What is an Ingress-Controller?","text":"<p>Ingress-controllers are serving http requests into a Kubernetes cluster. Most of the time traffic will pass through ingress and go to the Kubernetes endpoints of the respective pods. For having a successful ingress, you need to have a DNS name pointing to a set of stable IP addresses that act as a load balancer.</p> <p>Skipper as ingress-controller:</p> <ul> <li>cloud: deploy behind the cloud load balancer</li> <li>baremetal: deploy behind your hardware/software load balancer and have all skipper as members in one pool.</li> </ul> <p>You would point your DNS entries to the load balancer in front of skipper, for example automated using external-dns.</p>"},{"location":"kubernetes/ingress-controller/#why-skipper-uses-endpointslices-or-endpoints-and-not-services","title":"Why Skipper uses EndpointSlices or Endpoints and not Services?","text":"<p>Skipper does not use the ClusterIP of Kubernetes Services to route traffic to the pods. Instead it uses the Endpointslices or Endpoints API to bypass kube-proxy created iptables to remove overhead like conntrack entries for iptables DNAT. Skipper can also reuse connections to Pods, such that you have no overhead in establishing connections all the time. To prevent errors on node failures, Skipper also does automatic retries to another endpoint when it gets a connection refused or TLS handshake error to the endpoint.  Other reasons are future support of features like session affinity, different load balancer algorithms or distributed loadbalancing also known as service mesh.</p>"},{"location":"kubernetes/ingress-controller/#using-endpointslices-instead-of-endpoints","title":"Using EndpointSlices instead of Endpoints","text":"<p>EndpointSlices provide the ability to scale beyond 1000 load balancer members in one pool.</p> <p>To enable EndpointSlices you need to run skipper or routesrv with <code>-enable-kubernetes-endpointslices=true</code>.</p>"},{"location":"kubernetes/ingress-controller/#using-services-instead-of-endpoints","title":"Using Services instead of Endpoints","text":"<p>While using Endpoints is the preferred way of using Skipper as an ingress controller as described in the section above, there might be edge cases that require the use of Kubernetes Services instead.</p> <p>An example of scenario where you might need to use Services is when you rely on Istio networking features to connect multiple clusters, as the IPs of Kubernetes Endpoints will not resolve in all cases.</p> <p>If you find yourself in this category, you can override the default behaviour by setting the <code>KubernetesForceService</code> flag to <code>true</code> in the <code>Skipper.Options</code> struct. This will cause Skipper to create routes with <code>BackendType=eskip.NetworkBackend</code> instead of <code>BackendType=eskip.LBBackend</code> and use the following address format: <code>http://&lt;service name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;</code>. See the Kubernetes Service DNS documentation for more information.</p>"},{"location":"kubernetes/ingress-controller/#aws-deployment","title":"AWS deployment","text":"<p>In AWS, this could be an ALB with DNS pointing to the ALB. The ALB can then point to an ingress-controller running on an EC2 node and uses Kubernetes <code>hostnetwork</code> port specification in the Pod spec.</p> <p>A logical overview of the traffic flow in AWS is shown in this picture:</p> <p></p> <p>We described that Skipper bypasses Kubernetes Service and uses directly endpoints for good reasons, therefore the real traffic flow is shown in the next picture. </p>"},{"location":"kubernetes/ingress-controller/#baremetal-deployment","title":"Baremetal deployment","text":"<p>In datacenter, baremetal environments, you probably have a hardware load balancer or some haproxy or nginx setup, that serves most of your production traffic and DNS points to these endpoints. For example <code>*.ingress.example.com</code> could point to your virtual server IPs in front of ingress. Skippers could be used as pool members, which do the http routing. Your load balancer of choice could have a wildcard certificate for <code>*.ingress.example.com</code> and DNS for this would point to your load balancer. You can also automate DNS records with external-dns, if you for example use PowerDNS as provider and have a load balancer controller that modifies the status field in ingress to your load balancer virtual IP.</p> <p></p>"},{"location":"kubernetes/ingress-controller/#routesrv","title":"RouteSRV","text":"<p>In kubernetes skipper-ingress fetches ingress/routegroup configurations every 3s, with high number of skipper pods ~100 we faced issues with kube-apiserver. At which we introduced RouteSRV, which will serve as a layer between kube-apiserver and skipper ingress, so it will give us more flexibility in scaling skipper-ingress without affecting k8s-apiserver</p>"},{"location":"kubernetes/ingress-controller/#kubernetes-dataclient-as-routes-source","title":"Kubernetes dataclient as routes source","text":"<pre><code>  graph TD;\n      kapis(kubeapiserver) --fetches ingresses--&gt; s(skipper);</code></pre>"},{"location":"kubernetes/ingress-controller/#kubernetes-with-routesrv-as-routes-source","title":"Kubernetes with RouteSRV as routes source","text":"<pre><code>  graph TD;\n  kapis(kubeapiserver) --fetches ingresses--&gt; s(routesrv) --fetches routes--&gt; d1(skipper1) &amp; d2(skipper2);</code></pre>"},{"location":"kubernetes/ingress-controller/#requirements","title":"Requirements","text":"<p>In general for one endpoint you need, a DNS A/AAAA record pointing to one or more load balancer IPs. Skipper is best used behind this layer 4 load balancer to route and manipulate HTTP data.</p> <p>minimal example:</p> <ul> <li>layer 4 load balancer has <code>1.2.3.4:80</code> as socket for a virtual server pointing to all skipper ingress</li> <li><code>*.ingress.example.com</code> points to 1.2.3.4</li> <li>ingress object with host entry for <code>myapp.ingress.example.com</code> targets a service type ClusterIP</li> <li>service type ClusterIP has a selector that targets your Pods of your myapp deployment</li> </ul> <p>TLS example:</p> <ul> <li>same as before, but you would terminate TLS on your layer 4 load balancer</li> <li>layer 4 load balancer has <code>1.2.3.4:443</code> as socket for a virtual server</li> <li>you can use an automated redirect for all port 80 requests to https with <code>-kubernetes-https-redirect</code> and change the default redirect code with <code>-kubernetes-https-redirect-code</code></li> </ul>"},{"location":"kubernetes/ingress-controller/#install-skipper-as-ingress-controller","title":"Install Skipper as ingress-controller","text":"<p>You should have a base understanding of Kubernetes and Ingress.</p> <p>Prerequisites:</p> <ol> <li>You should checkout the git repository to have access to the manifests: <code>git clone https://github.com/zalando/skipper.git</code></li> <li>You should enter the cloned directory: <code>cd skipper</code></li> <li>You have to choose how to install skipper-ingress. You can install it as daemonset or as deployment.</li> </ol> <p>Beware, in order to get traffic from the internet, we would need to have a load balancer in front to direct all traffic to skipper. Skipper will route the traffic based on ingress objects. The load balancer should have a HTTP health check, that does a GET request to <code>/kube-system/healthz</code> on all Kubernetes worker nodes. This method is simple and used successfully in production. In AWS you can run <code>kube-ingress-aws-controller</code> to create these load balancers automatically based on the ingress definition.</p>"},{"location":"kubernetes/ingress-controller/#deployment-style","title":"Deployment style","text":"<p>Follow the deployment style you like: daemonset or deployment.</p>"},{"location":"kubernetes/ingress-controller/#daemonset","title":"Daemonset","text":"<p>We start to deploy skipper-ingress as a daemonset, use hostNetwork and expose the TCP port 9999 on each Kubernetes worker node for incoming ingress traffic.</p> <p>To deploy all manifests required for the daemonset style, you can run:</p> <pre><code>kubectl create -f docs/kubernetes/deploy/daemonset\n</code></pre> <pre><code># cat docs/kubernetes/deploy/daemonset/daemonset.yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.10.180\n    component: ingress\nspec:\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  updateStrategy:\n    type: RollingUpdate\n  template:\n    metadata:\n      name: skipper-ingress\n      labels:\n        application: skipper-ingress\n        version: v0.11.1\n        component: ingress\n    spec:\n      priorityClassName: system-node-critical\n      serviceAccountName: skipper-ingress\n      tolerations:\n      - key: dedicated\n        operator: Exists\n      nodeSelector:\n        kubernetes.io/role: worker\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/teapot/skipper:v0.22.170\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        - name: metrics-port\n          containerPort: 9911\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-kubernetes-path-mode=path-prefix\"\n          - \"-address=:9999\"\n          - \"-wait-first-route-load\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-reverse-source-predicate\"\n          - \"-metrics-flavour=codahale,prometheus\"\n          - \"-enable-connection-metrics\"\n          - \"-max-audit-body=0\"\n          - \"-histogram-metric-buckets=.01,.025,.05,.075,.1,.2,.3,.4,.5,.75,1,2,3,4,5,7,10,15,20,30,60,120,300,600\"\n        resources:\n          requests:\n            cpu: 150m\n            memory: 150Mi\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 5\n          timeoutSeconds: 5\n        securityContext:\n          readOnlyRootFilesystem: true\n          runAsNonRoot: true\n          runAsUser: 1000\n</code></pre> <p>Please check, that you are using the latest release, and do not use latest tag in production. While skipper is quite stable as library and proxy, there is ongoing development to make skipper more safe, increase visibility, fix issues that lead to incidents and add features.</p>"},{"location":"kubernetes/ingress-controller/#deployment","title":"Deployment","text":"<p>We start to deploy skipper-ingress as a deployment with an HPA, use hostNetwork and expose the TCP port 9999 on each Kubernetes worker node for incoming ingress traffic.</p> <p>To deploy all manifests required for the deployment style, you can run:</p> <pre><code>kubectl create -f docs/kubernetes/deploy/deployment\n</code></pre> <p>Now, let\u2019s see what we have just deployed. This will create serviceaccount, PodSecurityPolicy and RBAC rules such that skipper-ingress is allowed to listen on the hostnetwork and poll ingress resources.</p> <pre><code># cat docs/kubernetes/deploy/deployment/rbac.yaml\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: hostnetwork\nspec:\n  hostNetwork: true\n  hostPorts:\n  - max: 10000\n    min: 50\n  supplementalGroups:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  runAsUser:\n    # Require the container to run without root privileges.\n    rule: 'MustRunAsNonRoot'\n  seLinux:\n    rule: RunAsAny\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: hostnetwork-psp\nrules:\n- apiGroups:\n  - extensions\n  resourceNames:\n  - hostnetwork\n  resources:\n  - podsecuritypolicies\n  verbs:\n  - use\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: skipper-ingress\nrules:\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses\n  verbs:\n  - get\n  - list\n- apiGroups:\n    - extensions\n  resources:\n    - ingresses\n  verbs:\n    - get\n    - list\n- apiGroups: [\"\"]\n  resources:\n    - namespaces\n    - services\n    - endpoints\n    - pods\n  verbs:\n    - get\n    - list\n- apiGroups:\n    - discovery.k8s.io\n  resources:\n    - endpointslices\n  verbs:\n    - get\n    - list\n- apiGroups:\n  - zalando.org\n  resources:\n  - routegroups\n  verbs:\n  - get\n  - list\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: skipper-ingress\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: skipper-ingress\nsubjects:\n- kind: ServiceAccount\n  name: skipper-ingress\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: skipper-ingress-hostnetwork-psp\n  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: hostnetwork-psp\nsubjects:\n- kind: ServiceAccount\n  name: skipper-ingress\n  namespace: kube-system\n</code></pre> <p>The next file creates deployment with all options passed to skipper, that you should care in a basic production setup.</p> <pre><code># cat docs/kubernetes/deploy/deployment/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n    version: v0.11.40\n    component: ingress\nspec:\n  strategy:\n    rollingUpdate:\n      maxSurge: 0\n  selector:\n    matchLabels:\n      application: skipper-ingress\n  template:\n    metadata:\n      labels:\n        application: skipper-ingress\n        version: v0.11.40\n        component: ingress\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                - key: application\n                  operator: In\n                  values:\n                  - skipper-ingress\n              topologyKey: kubernetes.io/hostname\n      priorityClassName: system-cluster-critical\n      serviceAccountName: skipper-ingress\n      nodeSelector:\n        kubernetes.io/role: worker\n      dnsPolicy: ClusterFirstWithHostNet\n      hostNetwork: true\n      containers:\n      - name: skipper-ingress\n        image: registry.opensource.zalan.do/teapot/skipper:v0.22.170\n        ports:\n        - name: ingress-port\n          containerPort: 9999\n          hostPort: 9999\n        args:\n          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-kubernetes-path-mode=path-prefix\"\n          - \"-address=:9999\"\n          - \"-wait-first-route-load\"\n          - \"-proxy-preserve-host\"\n          - \"-serve-host-metrics\"\n          - \"-disable-metrics-compat\"\n          - \"-enable-profile\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-reverse-source-predicate\"\n          - \"-metrics-flavour=prometheus\"\n          - \"-enable-connection-metrics\"\n          - \"-max-audit-body=0\"\n          - \"-histogram-metric-buckets=.0001,.00025,.0005,.00075,.001,.0025,.005,.0075,.01,.025,.05,.075,.1,.2,.3,.4,.5,.75,1,2,3,4,5,7,10,15,20,30,60,120,300,600\"\n          - \"-expect-continue-timeout-backend=30s\"\n          - \"-keepalive-backend=30s\"\n          - \"-max-idle-connection-backend=0\"\n          - \"-response-header-timeout-backend=1m\"\n          - \"-timeout-backend=1m\"\n          - \"-tls-timeout-backend=1m\"\n          - \"-close-idle-conns-period=20s\"\n          - \"-idle-timeout-server=62s\"\n          - \"-read-timeout-server=5m\"\n          - \"-write-timeout-server=60s\"\n          - '-default-filters-prepend=enableAccessLog(4,5) -&gt; lifo(2000,20000,\"3s\")'\n        resources:\n          limits:\n            cpu: \"4\"\n            memory: \"1Gi\"\n          requests:\n            cpu: \"4\"\n            memory: \"1Gi\"\n        readinessProbe:\n          httpGet:\n            path: /kube-system/healthz\n            port: 9999\n          initialDelaySeconds: 60\n          timeoutSeconds: 5\n        securityContext:\n          readOnlyRootFilesystem: true\n          runAsNonRoot: true\n          runAsUser: 1000\n</code></pre> <p>This will deploy a HorizontalPodAutoscaler to scale skipper-ingress based on load.</p> <pre><code># cat docs/kubernetes/deploy/deployment/hpa.yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: skipper-ingress\n  minReplicas: 3\n  maxReplicas: 50\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 70\n</code></pre> <p>The next file will group skipper-ingress with a service, such that internal clients can access skipper via Kubernetes service.</p> <pre><code># cat docs/kubernetes/deploy/deployment/service.yaml\nkind: Service\napiVersion: v1\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n  labels:\n    application: skipper-ingress\n  annotations:\n    prometheus.io/path: /metrics\n    prometheus.io/port: \"9911\"\n    prometheus.io/scrape: \"true\"\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      targetPort: 9999\n      protocol: TCP\n  selector:\n    application: skipper-ingress\n</code></pre>"},{"location":"kubernetes/ingress-controller/#test-your-skipper-setup","title":"Test your skipper setup","text":"<p>We now deploy a simple demo application serving html:</p> <pre><code># cat docs/kubernetes/deploy/demo/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: skipper-demo\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      application: skipper-demo\n  template:\n    metadata:\n      labels:\n        application: skipper-demo\n    spec:\n      containers:\n      - name: skipper-demo\n        image: registry.opensource.zalan.do/teapot/skipper:v0.22.170\n        args:\n          - \"skipper\"\n          - \"-inline-routes\"\n          - \"* -&gt; inlineContent(\\\"&lt;body style='color: white; background-color: green;'&gt;&lt;h1&gt;Hello!&lt;/h1&gt;\\\") -&gt; &lt;shunt&gt;\"\n        ports:\n        - containerPort: 9090\n</code></pre> <p>We deploy a service type ClusterIP that we will select from ingress:</p> <pre><code># cat docs/kubernetes/deploy/demo/svc.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: skipper-demo\n  labels:\n    application: skipper-demo\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      protocol: TCP\n      targetPort: 9090\n      name: external\n  selector:\n    application: skipper-demo\n</code></pre> <p>To deploy the demo application, you have to run:</p> <pre><code>kubectl create -f docs/kubernetes/deploy/demo/\n</code></pre> <p>Now we have a skipper-ingress running as daemonset or deployment exposing the TCP port 9999 on each worker nodes, which has a running skipper-ingress instance, a backend application running with 2 replicas that serves some html on TCP port 9090, and we expose a cluster service on TCP port 80. Besides skipper-ingress, deployment and service cannot be reached from outside the cluster. Now we expose the application with Ingress to the external network:</p> <pre><code># cat demo-ing.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: skipper-demo\nspec:\n  rules:\n  - host: skipper-demo.&lt;mydomain.org&gt;\n    http:\n      paths:\n      - backend:\n          service:\n            name: skipper-demo\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>To deploy this ingress, you have to run:</p> <pre><code>kubectl create -f demo-ing.yaml\n</code></pre> <p>Skipper will configure itself for the given ingress, such that you can test doing:</p> <pre><code>curl -v -H\"Host: skipper-demo.&lt;mydomain.org&gt;\" http://&lt;nodeip&gt;:9999/\n</code></pre> <p>The next question you may ask is: how to expose this to your customers?</p> <p>The answer depends on your setup and complexity requirements. In the simplest case you could add one A record in your DNS <code>*.&lt;mydomain.org&gt;</code> to your frontend load balancer IP that directs all traffic from <code>*.&lt;mydomain.org&gt;</code> to all Kubernetes worker nodes on TCP port 9999. The load balancer health check should make sure, that only nodes with ready skipper-ingress instances will get traffic.</p> <p>A more complex setup we use in production and can be done with something that configures your frontend load balancer, for example kube-aws-ingress-controller, and your DNS, external-dns automatically.</p>"},{"location":"kubernetes/ingress-controller/#multiple-skipper-deployments","title":"Multiple skipper deployments","text":"<p>If you want to split for example <code>internal</code> and <code>public</code> traffic, it might be a good choice to split your ingress deployments. Skipper has the flag <code>--kubernetes-ingress-class=&lt;regexp&gt;</code> to only select ingress objects that have the annotation <code>kubernetes.io/ingress.class</code> set to something that is matched by <code>&lt;regexp&gt;</code>. Skipper will only create routes for ingress objects with it\u2019s annotation or ingress objects that do not have this annotation.</p> <p>The default ingress class is <code>skipper</code>, if not set. You have to create your ingress objects with the annotation <code>kubernetes.io/ingress.class: skipper</code> to make sure only skipper will serve the traffic.</p> <p>Example ingress:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: skipper\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-controller/#scoping-skipper-deployments-to-a-single-namespace","title":"Scoping Skipper Deployments to a Single Namespace","text":"<p>In some instances you might want skipper to only watch for ingress objects created in a single namespace. This can be achieved by using <code>kubernetes-namespace=&lt;string&gt;</code> where <code>&lt;string&gt;</code> is the Kubernetes namespace. Specifying this option forces Skipper to look at the namespace ingresses endpoint rather than the cluster-wide ingresses endpoint.</p> <p>By default this value is an empty string (<code>\"\"</code>) and will scope the skipper instance to be cluster-wide, watching all <code>Ingress</code> objects across all namespaces.</p>"},{"location":"kubernetes/ingress-controller/#publish-ingress-status-from-a-service","title":"Publish Ingress status from a Service","text":"<p>Skipper can update <code>Ingress.status.loadBalancer.ingress</code> from a configured Service by setting:</p> <p><code>-kubernetes-status-from-service=&lt;namespace&gt;/&lt;service-name&gt;</code></p> <p>Example:</p> <pre><code>skipper -kubernetes-status-from-service=ingress-system/skipper\n</code></pre> <p>When enabled, Skipper reads the configured Service and patches the <code>/status</code> subresource of ingresses only if the status value changed.</p>"},{"location":"kubernetes/ingress-controller/#rbac-requirement-for-status-updates","title":"RBAC requirement for status updates","text":"<p>Before enabling this feature, many setups only required read access (<code>get</code>, <code>list</code>) on <code>ingresses</code>. For status reconciliation, Skipper also needs write access on the <code>ingresses/status</code> subresource.</p> <p>Add the following rule to your ClusterRole:</p> <pre><code>- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses/status\n  verbs:\n  - patch\n  - update\n</code></pre> <p>If this permission is missing, Skipper logs Kubernetes RBAC \u201cforbidden\u201d errors when trying to write ingress status.</p>"},{"location":"kubernetes/ingress-controller/#helm-based-deployment","title":"Helm-based deployment","text":"<p>Skipper is not available as a Helm chart. There is a ticket asking for a helm chart.</p>"},{"location":"kubernetes/ingress-controller/#run-as-api-gateway-with-east-west-setup","title":"Run as API Gateway with East-West setup","text":"<p>East-West means cluster internal service-to-service communication. For this you need to resolve DNS to skipper for one or more additional domains of your choice. When Ingress or RouteGroup objects specify such domains Skipper will add the configured predicates.</p>"},{"location":"kubernetes/ingress-controller/#skipper","title":"Skipper","text":"<p>To enable the East-West in skipper, you need to run skipper with <code>-kubernetes-east-west-range-domains</code> and <code>-kubernetes-east-west-range-predicates</code> configuration flags. Check the East West Range feature. Skipper will analyze all routes from Kubernetes objects and, the identified East-West routes will have the predicates specified appended.</p> <p>For example, for running skipper with the <code>skipper.cluster.local</code> domain, and setting East-West routes to accept just internal traffic, use the following config:</p> <pre><code>skipper \\\n  -kubernetes-east-west-range-domains=\"skipper.cluster.local\" \\\n  -kubernetes-east-west-range-predicates='ClientIP(\"10.2.0.0/16\")'\n</code></pre> <p>It assumes 10.2.0.0/16 is your PODs\u2019 CIDR, you have to change it accordingly to your environment.</p> <p>You need also to have a kubernetes service type ClusterIP and write down the IP (p.e. <code>10.3.11.28</code>), which you will need in CoreDNS setup.</p>"},{"location":"kubernetes/ingress-controller/#coredns","title":"CoreDNS","text":"<p>You can create the DNS records with the <code>template</code> plugin from CoreDNS.</p> <p>Corefile example: <pre><code>.:53 {\n    errors\n    health\n    kubernetes cluster.local in-addr.arpa ip6.arpa {\n        pods insecure\n        upstream\n        fallthrough in-addr.arpa ip6.arpa\n    }\n    template IN A skipper.cluster.local  {\n      match \"^.*[.]skipper[.]cluster[.]local\"\n      answer \"{{ .Name }} 60 IN A 10.3.11.28\"\n      fallthrough\n    }\n    prometheus :9153\n    proxy . /etc/resolv.conf\n    cache 30\n    reload\n}\n</code></pre></p>"},{"location":"kubernetes/ingress-controller/#usage","title":"Usage","text":"<p>If the setup is correct, skipper will protect the following ingress example with the <code>ClientIP</code> predicate:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: demo\n  namespace: default\nspec:\n  rules:\n  - host: demo.skipper.cluster.local\n    http:\n      paths:\n      - backend:\n          service:\n            name: example\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>Your clients inside the cluster should call this example with <code>demo.skipper.cluster.local</code> in their host header. Example from inside a container:</p> <pre><code>curl demo.skipper.cluster.local\n</code></pre> <p>Skipper won\u2019t accept traffic from any IP outside of the configured network CIDR.</p> <p>Note</p> <p>Depending on your environment, you might want to allow traffic not just from the PODs\u2019 CIDR, but, also, from your nodes\u2019 CIDR. When doing so, pay attention to do not allow traffic from your LoadBalancer and, by consequence, external traffic. You can use different combinations of predicates like <code>ClientIP</code> and <code>SourceFromLast</code> to achieve the desired protection.</p>"},{"location":"kubernetes/ingress-controller/#running-with-cluster-ratelimits","title":"Running with Cluster Ratelimits","text":"<p>Cluster ratelimits require a communication exchange method to build a skipper swarm to have a shared knowledge about the requests passing all skipper instances. To enable this feature you need to add command line option <code>-enable-swarm</code> and <code>-enable-ratelimits</code>. The rest depends on the implementation, that can be:</p> <ul> <li>Redis</li> <li>alpha version: SWIM</li> </ul>"},{"location":"kubernetes/ingress-controller/#redis-based","title":"Redis based","text":"<p>Additionally you have to add <code>-swarm-redis-urls</code> to skipper <code>args:</code>. For example: <code>-swarm-redis-urls=skipper-redis-0.skipper-redis.kube-system.svc.cluster.local:6379,skipper-redis-1.skipper-redis.kube-system.svc.cluster.local:6379</code>.</p> <p>Running skipper with <code>hostNetwork</code> in kubernetes will not be able to resolve redis hostnames as shown in the example, if skipper does not have <code>dnsPolicy: ClusterFirstWithHostNet</code> in its Pod spec, see also DNS policy in the official Kubernetes documentation.</p> <p>This setup is considered experimental and should be carefully tested before running it in production.</p> <p>Example redis statefulset with headless service:</p> <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  labels:\n    application: skipper-redis\n    version: v6.2.4\n  name: skipper-redis\n  namespace: kube-system\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      application: skipper-redis\n  serviceName: skipper-redis\n  template:\n    metadata:\n      labels:\n        application: skipper-redis\n        version: v6.2.4\n    spec:\n      containers:\n      - image: registry.opensource.zalan.do/library/redis-6-alpine:6-alpine-20210712\n        name: skipper-redis\n        ports:\n        - containerPort: 6379\n          protocol: TCP\n        readinessProbe:\n          exec:\n            command:\n            - redis-cli\n            - ping\n          failureThreshold: 3\n          initialDelaySeconds: 10\n          periodSeconds: 60\n          successThreshold: 1\n          timeoutSeconds: 1\n        resources:\n          limits:\n            cpu: 100m\n            memory: 100Mi\n      dnsPolicy: ClusterFirst\n      restartPolicy: Always\n      schedulerName: default-scheduler\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    application: skipper-redis\n  name: skipper-redis\n  namespace: kube-system\nspec:\n  clusterIP: None\n  ports:\n  - port: 6379\n    protocol: TCP\n    targetPort: 6379\n  selector:\n    application: skipper-redis\n  type: ClusterIP\n</code></pre>"},{"location":"kubernetes/ingress-controller/#swim-based","title":"SWIM based","text":"<p>SWIM is a \u201cScalable Weakly-consistent Infection-style Process Group Membership Protocol\u201d, which is very interesting for example to use for cluster ratelimits. This setup is not considered stable enough to run production, yet.</p> <p>Additionally you have to add the following command line flags to skipper\u2019s container spec <code>args:</code>:</p> <pre><code>-swarm-port=9990\n-swarm-label-selector-key=application\n-swarm-label-selector-value=skipper-ingress\n-swarm-leave-timeout=5s\n-swarm-max-msg-buffer=4194304\n-swarm-namespace=kube-system\n</code></pre> <p>and open another port in Kubernetes and your Firewall settings to make the communication work with TCP and UDP to the specified <code>swarm-port</code>:</p> <pre><code>- containerPort: 9990\n  hostPort: 9990\n  name: swarm-port\n  protocol: TCP\n</code></pre>"},{"location":"kubernetes/ingress-controller/#upgrades","title":"Upgrades","text":"<p>Please always read the announcements of the vX.Y.0 release page, because these will document in case we break something in a backwards non compatible way. Most of the time it will be safe to deploy minor version updates, but better to know in advance if something could break.</p>"},{"location":"kubernetes/ingress-controller/#v0140","title":"=v0.14.0 <p>Kubernetes dataclient removes support for ingress v1beta1. What does it mean for you?</p> <ol> <li>If you run with enabled <code>-kubernetes-ingress-v1</code>, you won\u2019t need to   do anything and you can safely delete the flag while updating to   <code>&gt;=0.14.0</code>.</li> <li>If you use skipper as library and pass <code>KubernetesIngressV1: true</code>   via <code>kubernetes.Options</code> into <code>kubernetes.New()</code>, then you won\u2019t need to   do anything and you can safely delete passing the option while updating to   <code>&gt;=0.14.0</code>.</li> <li>If you use Ingress v1beta1 and run Kubernetes cluster version that   does not support ingress v1, then you can\u2019t update skipper to   <code>&gt;=0.14.0</code>, before you upgrade your Kubernetes cluster.</li> <li>If you use Ingress v1beta1 and run Kubernetes cluster version that   supports ingress v1, then you need to allow skipper to access the new   APIs with a changed RBAC. See the guide below.</li> </ol> <p>If upgrading from Ingress v1beta1 on a Kubernetes cluster that supports Ingress v1, you have to apply a change in your RBAC, please check the diff or the full rendered file.</p> <p>Diff view (same for deployment and daemonset): <pre><code>diff --git docs/kubernetes/deploy/deployment/rbac.yaml docs/kubernetes/deploy/deployment/rbac.yaml\nindex 361f3789..c0e448a4 100644\n--- docs/kubernetes/deploy/deployment/rbac.yaml\n+++ docs/kubernetes/deploy/deployment/rbac.yaml\n@@ -37,11 +37,18 @@ metadata:\n   name: skipper-ingress\n   namespace: kube-system\n ---\n-apiVersion: rbac.authorization.k8s.io/v1beta1\n+apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRole\n metadata:\n   name: skipper-ingress\n rules:\n+- apiGroups:\n+  - networking.k8s.io\n+  resources:\n+  - ingresses\n+  verbs:\n+  - get\n+  - list\n - apiGroups:\n     - extensions\n   resources:\n@@ -66,7 +73,7 @@ rules:\n   - get\n   - list\n ---\n-apiVersion: rbac.authorization.k8s.io/v1beta1\n+apiVersion: rbac.authorization.k8s.io/v1\n kind: ClusterRoleBinding\n metadata:\n   name: skipper-ingress\n@@ -79,7 +86,7 @@ subjects:\n   name: skipper-ingress\n   namespace: kube-system\n ---\n-apiVersion: rbac.authorization.k8s.io/v1beta1\n+apiVersion: rbac.authorization.k8s.io/v1\n kind: RoleBinding\n metadata:\n   name: skipper-ingress-hostnetwork-psp\n</code></pre></p> <p>Full rendered RBAC files (same for deployment and daemonset):</p> <pre><code># cat docs/kubernetes/deploy/deployment/rbac.yaml\napiVersion: policy/v1beta1\nkind: PodSecurityPolicy\nmetadata:\n  name: hostnetwork\nspec:\n  hostNetwork: true\n  hostPorts:\n  - max: 10000\n    min: 50\n  supplementalGroups:\n    rule: RunAsAny\n  fsGroup:\n    rule: RunAsAny\n  runAsUser:\n    # Require the container to run without root privileges.\n    rule: 'MustRunAsNonRoot'\n  seLinux:\n    rule: RunAsAny\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: hostnetwork-psp\nrules:\n- apiGroups:\n  - extensions\n  resourceNames:\n  - hostnetwork\n  resources:\n  - podsecuritypolicies\n  verbs:\n  - use\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: skipper-ingress\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: skipper-ingress\nrules:\n- apiGroups:\n  - networking.k8s.io\n  resources:\n  - ingresses\n  verbs:\n  - get\n  - list\n- apiGroups:\n    - extensions\n  resources:\n    - ingresses\n  verbs:\n    - get\n    - list\n- apiGroups: [\"\"]\n  resources:\n    - namespaces\n    - services\n    - endpoints\n    - pods\n  verbs:\n    - get\n    - list\n- apiGroups:\n    - discovery.k8s.io\n  resources:\n    - endpointslices\n  verbs:\n    - get\n    - list\n- apiGroups:\n  - zalando.org\n  resources:\n  - routegroups\n  verbs:\n  - get\n  - list\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: skipper-ingress\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: skipper-ingress\nsubjects:\n- kind: ServiceAccount\n  name: skipper-ingress\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: skipper-ingress-hostnetwork-psp\n  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: hostnetwork-psp\nsubjects:\n- kind: ServiceAccount\n  name: skipper-ingress\n  namespace: kube-system\n</code></pre>","text":""},{"location":"kubernetes/ingress-usage/","title":"Skipper Ingress Usage","text":"<p>This documentation is meant for people deploying to Kubernetes Clusters and describes to use Ingress and low level and high level features Skipper provides.</p> <p>RouteGroups, Skipper Kubernetes native routing object that supports all Skipper features. If you need to create more than one route to your application, RouteGroups should be the default choice, instead of ingress.  The documentation contains a section with mapping Ingress to RouteGroups.</p>"},{"location":"kubernetes/ingress-usage/#skipper-ingress-annotations","title":"Skipper Ingress Annotations","text":"Annotation example data usage zalando.org/backend-weights <code>{\"my-app-1\": 80, \"my-app-2\": 20}</code> blue-green deployments, see also StackSet for more high-level integration zalando.org/skipper-filter <code>consecutiveBreaker(15)</code> arbitrary filters zalando.org/skipper-predicate <code>QueryParam(\"version\", \"^alpha$\")</code> arbitrary predicates zalando.org/skipper-routes <code>Method(\"OPTIONS\") -&gt; status(200) -&gt; &lt;shunt&gt;</code> extra custom routes, please consider using RouteGroups instead zalando.org/skipper-backend <code>forward</code> if you want to rewrite the backend, for migration purposes to the forward backend, other backends are not allowed, yet. zalando.org/ratelimit <code>ratelimit(50, \"1m\")</code> deprecated, use zalando.org/skipper-filter instead zalando.org/skipper-ingress-redirect <code>\"true\"</code> change the default HTTPS redirect behavior for specific ingresses (true/false) zalando.org/skipper-ingress-redirect-code <code>301</code> change the default HTTPS redirect code for specific ingresses zalando.org/skipper-loadbalancer <code>consistentHash</code> defaults to <code>roundRobin</code>, see available choices zalando.org/skipper-backend-protocol <code>fastcgi</code> (experimental) defaults to <code>http</code>, see available choices zalando.org/skipper-ingress-path-mode <code>path-prefix</code> (deprecated) please use Ingress version 1 pathType option, which defaults to ImplementationSpecific and does not change the behavior. Skipper\u2019s path-mode defaults to <code>kubernetes-ingress</code>, see available choices, to change the default use <code>-kubernetes-path-mode</code>."},{"location":"kubernetes/ingress-usage/#supported-service-types","title":"Supported Service types","text":"<p>Ingress backend definitions are services, which have different service types. ClusterIP should be the default for all backend applications that expose via ingress.</p> Service type supported workaround ClusterIP yes \u2014 NodePort yes \u2014 ExternalName yes (enable by <code>-enable-kubernetes-external-names</code> \u2014 LoadBalancer no it should not, because Kubernetes cloud-controller-manager will maintain it"},{"location":"kubernetes/ingress-usage/#http-host-header-routing","title":"HTTP Host header routing","text":"<p>HTTP host header is defined within the rules <code>host</code> section and this route will match by http <code>Host: app-default.example.org</code> and route to endpoints selected by the Kubernetes service <code>app-svc</code> on port <code>80</code>.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>To have 2 routes with different <code>Host</code> headers serving the same backends, you have to specify 2 entries in the rules section, as Kubernetes defined the ingress spec. This is often used in cases of migrations from one domain to another one or migrations to or from bare metal datacenters to cloud providers or inter cloud or intra cloud providers migrations. Examples are AWS account migration, AWS to GCP migration, GCP to bare metal migration or bare metal to Alibaba Cloud migration.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n  - host: foo.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#multiple-ingresses-defining-the-same-route","title":"Multiple Ingresses defining the same route","text":"<p>Warning</p> <p>If multiple ingresses define the same host and the same predicates, traffic routing may become non-deterministic.</p> <p>Consider the following two ingresses which have the same hostname and therefore overlap. In Skipper the routing of this is currently undefined as skipper doesn\u2019t pick one over the other, but just creates routes (possible overlapping) for each of the ingresses.</p> <p>In this example (taken from the issues we saw in production clusters) one ingress points to a service with no endpoints and the other to a service with endpoints. (Most likely service-x was renamed to service-x-live and the old ingress was forgot).</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: service-x\nspec:\n  rules:\n  - host: service-x.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: service-x # this service has 0 endpoints\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>\u200b</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: service-x-live\nspec:\n  rules:\n  - host: service-x.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: service-x-live\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#ingress-path-handling","title":"Ingress path handling","text":"<p>Skipper supports all Kubernetes path-types as documented in Kubernetes documentation.</p> <p>Ingress paths can be interpreted in five different modes:</p> <ol> <li><code>pathType: Prefix</code> results in PathSubtree predicate)</li> <li><code>pathType: Exact</code> results in Path predicate)</li> <li><code>pathType: ImplementationSpecific</code><ol> <li>based on the Kubernetes ingress specification (default)</li> <li>as plain regular expression</li> <li>as a path prefix (same as <code>pathType: Prefix</code> and results in PathSubtree)</li> </ol> </li> </ol> <p>Default can be changed by startup option <code>-kubernetes-path-mode</code> to any of the other modes. The individual ingress rules can also override the default behavior with the <code>zalando.org/skipper-ingress-path-mode</code> annotation. You can also set for each path rule a different Kubernetes <code>pathType</code> like <code>Prefix</code> and <code>Exact</code>.</p> <p>E.g.:</p> <pre><code>zalando.org/skipper-ingress-path-mode: path-prefix # Skipper specific\npathType: Prefix # ingress v1\n</code></pre>"},{"location":"kubernetes/ingress-usage/#kubernetes-ingress-specification-base-path","title":"Kubernetes ingress specification base path","text":"<p>By default, the ingress path mode is set to <code>kubernetes-ingress</code>, which is interpreted as a regular expression with a mandatory leading <code>/</code>, and is automatically prepended by a <code>^</code> control character, enforcing that the path has to be at the start of the incoming request path.</p>"},{"location":"kubernetes/ingress-usage/#plain-regular-expression","title":"Plain regular expression","text":"<p>When the path mode is set to <code>path-regexp</code>, the ingress path is interpreted similar to the default Kubernetes ingress specification way, but is not prepended by the <code>^</code> control character.</p>"},{"location":"kubernetes/ingress-usage/#path-prefix","title":"Path prefix","text":"<p>When the path mode is set to <code>path-prefix</code>, the ingress path is not a regular expression. As an example, <code>/foo/bar</code> will match <code>/foo/bar</code> or <code>/foo/bar/baz</code>, but won\u2019t match <code>/foo/barooz</code>.</p> <p>When PathPrefix is used, the path matching becomes deterministic when a request could match more than one ingress routes otherwise.</p> <p>In PathPrefix mode, when a Path or PathSubtree predicate is set in an annotation, the predicate in the annotation takes precedence over the normal ingress path.</p>"},{"location":"kubernetes/ingress-usage/#filters-and-predicates","title":"Filters and Predicates","text":"<ul> <li>Filters can manipulate http data, which is not possible in the ingress spec.</li> <li>Predicates change the route matching, beyond normal ingress definitions</li> </ul> <p>This example shows how to add predicates and filters:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: predicate1 &amp;&amp; predicate2 &amp;&amp; .. &amp;&amp; predicateN\n    zalando.org/skipper-filter: filter1 -&gt; filter2 -&gt; .. -&gt; filterN\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#custom-routes","title":"Custom Routes","text":"<p>Please consider using RouteGroups, instead of custom routes!</p> <p>Custom routes extend default routes configured for an ingress resource and are specified via <code>zalando.org/skipper-routes</code> annotation.</p> <p>Sometimes you just want to return a header, redirect or even static html content. You can return from Skipper without doing a proxy call to a backend, if you end your filter chain with <code>&lt;shunt&gt;</code>. The use of <code>&lt;shunt&gt;</code> recommends the use in combination with <code>status()</code> filter, to not respond with the default http code, which defaults to 404.  To match your custom route with higher priority than your ingress you also have to add another predicate, for example the Method(\u201cGET\u201d) predicate to match the route with higher priority.</p> <p>Custom routes specified in ingress will always add the <code>Host()</code> predicate to match the host header specified in the ingress <code>rules:</code>. If there is a <code>path:</code> definition in your ingress, then it will be based on the Skipper command line parameter <code>-kubernetes-path-mode</code> set one of these predicates:</p> <ul> <li>Path()</li> <li>PathSubtree()</li> <li>PathRegexp()</li> </ul> <p>If you have a <code>path:</code> value defined in your ingress resource, a custom route is not allowed to use <code>Path()</code> nor <code>PathSubtree()</code> predicates. You will get an error in Skipper logs, similar to:</p> <pre><code>[APP]time=\"2019-01-02T13:30:16Z\" level=error msg=\"Failed to add route having 2 path routes: Path(\\\"/foo/bar\\\") -&gt; inlineContent(\\\"custom route\\\") -&gt; status(200) -&gt; &lt;shunt&gt;\"\n</code></pre> <p>Warning: Predicates from <code>zalando.org/skipper-predicate</code> and filters from <code>zalando.org/skipper-filter</code> annotations won\u2019t be appended to routes from <code>zalando.org/skipper-routes</code> annotation.</p>"},{"location":"kubernetes/ingress-usage/#redirects","title":"Redirects","text":""},{"location":"kubernetes/ingress-usage/#overwrite-the-current-ingress-with-a-redirect","title":"Overwrite the current ingress with a redirect","text":"<p>Sometimes you want to overwrite the current ingress with a redirect to a nicer downtime page.</p> <p>The following example shows how to create a temporary redirect with status code 307 to https://outage.example.org. No requests will pass to your backend defined, because the created route from the annotation <code>zalando.org/skipper-routes</code> will get 3 Predicates <code>Host(\"^app-default[.]example[.]org$\") &amp;&amp; Path(\"/\") &amp;&amp; PathRegexp(\"/\")</code>, instead of the 2 Predicates <code>Host(\"^app-default[.]example[.]org$\") &amp;&amp; Path(\"/\")</code>, that will be created for the ingress backend.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app\n  namespace: default\n  annotations:\n    zalando.org/skipper-routes: |\n       redirect_app_default: PathRegexp(\"/\") -&gt; redirectTo(307, \"https://outage.example.org/\") -&gt; &lt;shunt&gt;;\nspec:\n  rules:\n  - host: \"app-default.example.org\"\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n</code></pre>"},{"location":"kubernetes/ingress-usage/#redirect-a-specific-path-from-ingress","title":"Redirect a specific path from ingress","text":"<p>Sometimes you want to have a redirect from <code>http://app-default.example.org/myredirect</code> to <code>https://somewhere.example.org/another/path</code>.</p> <p>The following example shows how to create a permanent redirect with status code 308 from <code>http://app-default.example.org/myredirect</code> to <code>https://somewhere.example.org/another/path</code>, other paths will not be redirected and passed to the backend selected by <code>serviceName=app-svc</code> and <code>servicePort=80</code>:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app\n  namespace: default\n  annotations:\n    zalando.org/skipper-routes: |\n       redirect_app_default: PathRegexp(\"/myredirect\") -&gt; redirectTo(308, \"https://somewhere.example.org/another/path\") -&gt; &lt;shunt&gt;;\nspec:\n  rules:\n  - host: \"app-default.example.org\"\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n</code></pre>"},{"location":"kubernetes/ingress-usage/#return-static-content","title":"Return static content","text":"<p>The following example sets a response header <code>X: bar</code>, a response body <code>&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;</code> and respond from the ingress directly with a HTTP status code 200:</p> <pre><code>zalando.org/skipper-routes: |\n  PathRegexp(\"/\") -&gt; setResponseHeader(\"X\", \"bar\") -&gt; inlineContent(\"&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;\") -&gt; status(200) -&gt; &lt;shunt&gt;\n</code></pre> <p>Keep in mind that you need a valid backend definition to backends which are available; otherwise, Skipper would not accept the entire route definition from the ingress object for safety reasons.</p>"},{"location":"kubernetes/ingress-usage/#cors-example","title":"CORS example","text":"<p>This example shows how to add a custom route for handling <code>OPTIONS</code> requests.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-routes: |\n      Method(\"OPTIONS\") -&gt;\n      setResponseHeader(\"Access-Control-Allow-Origin\", \"*\") -&gt;\n      setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\") -&gt;\n      setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\") -&gt;\n      status(200) -&gt; &lt;shunt&gt;\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>This will generate a custom route for the ingress which looks like this:</p> <pre><code>Host(/^app-default[.]example[.]org$/) &amp;&amp; Method(\"OPTIONS\") -&gt;\n  setResponseHeader(\"Access-Control-Allow-Origin\", \"*\") -&gt;\n  setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\") -&gt;\n  setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\") -&gt;\n  status(200) -&gt; &lt;shunt&gt;\n</code></pre>"},{"location":"kubernetes/ingress-usage/#multiple-routes","title":"Multiple routes","text":"<p>You can also set multiple routes, but you have to set the IDs (<code>routename1</code>, <code>routename2</code>) of the route as defined in eskip:</p> <pre><code>zalando.org/skipper-routes: |\n  routename1: Path(\"/\") -&gt; clientRatelimit(2, \"1h\") -&gt; inlineContent(\"A\") -&gt; status(200) -&gt; &lt;shunt&gt;;\n  routename2: Path(\"/foo\") -&gt; clientRatelimit(5, \"1h\") -&gt; inlineContent(\"B\") -&gt; status(200) -&gt; &lt;shunt&gt;;\n</code></pre> <p>Make sure the <code>;</code> semicolon is used to terminate the routes, if you use multiple routes definitions.</p> <p>Disclaimer: This feature works only with having different <code>Path*</code> predicates in ingress, if there are no paths rules defined. For example this will not work:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: skipper-ingress\n  annotations:\n    kubernetes.io/ingress.class: skipper\n    zalando.org/skipper-routes: |\n       redirect1: Path(\"/foo/\") -&gt; redirectTo(308, \"/bar/\") -&gt; &lt;shunt&gt;;\nspec:\n  rules:\n  - host: foo.bar\n    http:\n      paths:\n      - path: /something\n        pathType: Prefix\n        backend:\n          service:\n            name: something\n            port:\n              number: 80\n      - path: /else\n        pathType: Prefix\n        backend:\n          service:\n            name: else\n            port:\n              number: 80\n</code></pre> <p>A possible solution is to use skipper\u2019s RouteGroups.</p>"},{"location":"kubernetes/ingress-usage/#filters-basic-http-manipulations","title":"Filters - Basic HTTP manipulations","text":"<p>HTTP manipulations are done by using Skipper filters. Changes can be done in the request path, meaning request to your backend or in the response path to the client, which made the request.</p> <p>The following examples can be used within <code>zalando.org/skipper-filter</code> annotation.</p>"},{"location":"kubernetes/ingress-usage/#add-a-request-header","title":"Add a request Header","text":"<p>Add a HTTP header in the request path to your backend.</p> <pre><code>setRequestHeader(\"X-Foo\", \"bar\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#add-a-response-header","title":"Add a response Header","text":"<p>Add a HTTP header in the response path of your clients.</p> <pre><code>setResponseHeader(\"X-Foo\", \"bar\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#enable-compression","title":"Enable compression","text":"<p>Compress responses (see details about selecting responses to compress).</p> <pre><code>compress() // compress all valid MIME types\ncompress(\"text/html\") // only compress HTML files\ncompress(11, \"text/html\") // control the level of compression, 1 = fastest, 11 = best compression (fall back to 9 for gzip), 0 = no compression\n</code></pre>"},{"location":"kubernetes/ingress-usage/#set-the-path","title":"Set the Path","text":"<p>Change the path in the request path to your backend to <code>/newPath/</code>.</p> <pre><code>setPath(\"/newPath/\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#modify-path","title":"Modify Path","text":"<p>Modify the path in the request path from <code>/api/foo</code> to your backend to <code>/foo</code>.</p> <pre><code>modPath(\"^/api/\", \"/\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#set-the-querystring","title":"Set the Querystring","text":"<p>Set the Querystring in the request path to your backend to <code>?text=godoc%20skipper</code>.</p> <pre><code>setQuery(\"text\", \"godoc skipper\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#redirect","title":"Redirect","text":"<p>Create a redirect with HTTP code 301 to https://foo.example.org/.</p> <pre><code>redirectTo(301, \"https://foo.example.org/\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#cookies","title":"Cookies","text":"<p>Set a Cookie in the request path to your backend.</p> <pre><code>requestCookie(\"test-session\", \"abc\")\n</code></pre> <p>Set a Cookie in the response path of your clients.</p> <pre><code>responseCookie(\"test-session\", \"abc\", 31536000)\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\n\n// response cookie without HttpOnly:\njsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#authorization","title":"Authorization","text":"<p>Our authentication and authorization tutorial or filter auth godoc shows how to use filters for authorization.</p>"},{"location":"kubernetes/ingress-usage/#basic-auth","title":"Basic Auth","text":"<pre><code>% htpasswd -nbm myName myPassword\n\nbasicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#bearer-token-oauthjwt","title":"Bearer Token (OAuth/JWT)","text":"<p>OAuth2/JWT tokens can be validated and allowed based on different content of the token. Please check the filter documentation for that:</p> <ul> <li>oauthTokeninfoAnyScope</li> <li>oauthTokeninfoAllScope</li> <li>oauthTokeninfoAnyKV</li> <li>oauthTokeninfoAllKV</li> </ul> <p>There are also auth predicates, which will allow you to match a route based on the content of a token:</p> <ul> <li><code>JWTPayloadAnyKV()</code></li> <li><code>JWTPayloadAllKV()</code></li> </ul> <p>These are not validating the tokens, which should be done separately by the filters mentioned above.</p>"},{"location":"kubernetes/ingress-usage/#diagnosis-throttling-bandwidth-latency","title":"Diagnosis - Throttling Bandwidth - Latency","text":"<p>For diagnosis purpose there are more than 20 filters that enable you to throttle the bandwidth or add latency. For the full list of filters see our diagnostics filters. Examples:</p> <pre><code>bandwidth(30) // incoming in kb/s\nbackendBandwidth(30) // outgoing in kb/s\nbackendLatency(120) // in ms\nnormalRequestLatency(\"10ms\", \"5ms\") // normal distribution for request latency as time duration string\nlogHeader(\"request\") // log all request headers\nlogBody(\"response\", 1024) // log up to 1024 Bytes of the response body\n</code></pre>"},{"location":"kubernetes/ingress-usage/#flow-id-to-trace-request-flows","title":"Flow ID to trace request flows","text":"<p>To trace request flows Skipper can generate a unique Flow ID for every HTTP request that it receives. You can then find the trace of the request in all your access logs.  Skipper sets the X-Flow-Id header to a unique value. Read more about this in our flowid filter and godoc.</p> <pre><code> flowId(\"reuse\")\n</code></pre>"},{"location":"kubernetes/ingress-usage/#filters-reliability-features","title":"Filters - reliability features","text":"<p>Filters can modify http requests and responses. There are plenty of things you can do with them.</p>"},{"location":"kubernetes/ingress-usage/#circuitbreaker","title":"Circuitbreaker","text":""},{"location":"kubernetes/ingress-usage/#consecutive-breaker","title":"Consecutive Breaker","text":"<p>The consecutiveBreaker filter is a breaker for the ingress route that open if the backend failures for the route reach a value of N (in this example N=15), where N is a mandatory argument of the filter and there are some more optional arguments documented.</p> <pre><code>consecutiveBreaker(15)\n</code></pre> <p>The ingress spec would look like this:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: consecutiveBreaker(15)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#rate-breaker","title":"Rate Breaker","text":"<p>The rateBreaker filter is a breaker for the ingress route that open if the backend failures for the route reach a value of N within a window of the last M requests, where N (in this example 30) and M (in this example 300) are mandatory arguments of the filter and there are some more optional arguments documented.</p> <pre><code>rateBreaker(30, 300)\n</code></pre> <p>The ingress spec would look like this:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: rateBreaker(30, 300)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#admission-control","title":"Admission Control","text":"<p>The admissionControl filter is a dynamic circuit breaker that works based on HTTP error codes observed by backends. It will dynamically adjust the shedding of load to the maximum throughput possible.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: admissionControl(\"myapp\", \"active\", \"1s\", 5, 10, 0.95, 0.9, 0.5)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#ratelimits","title":"Ratelimits","text":"<p>There are two kind of ratelimits:</p> <ol> <li>Client side ratelimits are used to slow down login enumeration attacks, that targets your login pages. This is a security protection for DDoS or login attacks.</li> <li>Service or backend side ratelimits are used to protect your services due too much traffic. This can be used in an emergency situation to make sure you calm down ingress traffic or in general if you know how much calls per duration your backend is able to handle.</li> <li>Cluster ratelimits can be enforced either on client or on service side as described above.</li> </ol> <p>Ratelimits are enforced per route.</p> <p>More details you will find in rate limit filters section and in our ratelimit tutorial.</p>"},{"location":"kubernetes/ingress-usage/#client-ratelimits","title":"Client Ratelimits","text":"<p>The example shows 20 calls per hour per client, based on X-Forwarded-For header or IP when there is no X-Forwarded-For header set, are allowed to each Skipper instance for the given ingress.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: clientRatelimit(20, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>If you need to rate limit service to service communication and you use Authorization headers to protect your backend from your clients, then you can pass a 3 parameter to group clients by \u201cAuthorization Header\u201d:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: clientRatelimit(20, \"1h\", \"authorization\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#service-ratelimits","title":"Service Ratelimits","text":"<p>The example shows 50 calls per minute are allowed to each skipper instance for the given ingress.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: ratelimit(50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#cluster-ratelimits","title":"Cluster Ratelimits","text":"<p>Cluster ratelimits are eventual consistent and require the flag <code>-enable-swarm</code> to be set.</p>"},{"location":"kubernetes/ingress-usage/#service","title":"Service","text":"<p>The example shows 50 calls per minute are allowed to pass this ingress rule to the backend.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: clusterRatelimit(\"groupSvcApp\", 50, \"1m\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#client","title":"Client","text":"<p>The example shows 10 calls per hour are allowed per client, X-Forwarded-For header, to pass this ingress rule to the backend.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: clusterClientRatelimit(\"groupSvcApp\", 10, \"1h\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#path-ratelimit","title":"Path ratelimit","text":"<p>To ratelimit a specific path use a second ingress definition like</p> <p><pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-default\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-login\n  annotations:\n    zalando.org/skipper-predicate: Path(\"/login\")\n    zalando.org/skipper-filter: clusterClientRatelimit(\"login-ratelimit\", 10, \"1h\")\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> or use RouteGroups.</p>"},{"location":"kubernetes/ingress-usage/#shadow-traffic","title":"Shadow Traffic","text":"<p>If you want to test a new replacement of a production service with production load, you can copy incoming requests to your new endpoint and ignore the responses from your new backend. This can be done by the tee() and teenf() filters. See also our shadow traffic tutorial.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: teenf(\"https://app-new.example.org\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#predicates","title":"Predicates","text":"<p>Predicates are influencing the route matching, which you might want to carefully test before using it in production. This enables you to do feature toggles or time based enabling endpoints.</p> <p>You can use all kinds of predicates with filters together.</p>"},{"location":"kubernetes/ingress-usage/#feature-toggle","title":"Feature Toggle","text":"<p>Feature toggles are often implemented as query string to select a new feature. Normally you would have to implement this in your application, but Skipper can help you with that and you can select routes with an ingress definition.</p> <p>You create 2 ingresses that matches the same route, here host header match to <code>app-default.example.org</code> and one ingress has a defined query parameter to select the route to the alpha version deployment. If the query string in the URL has <code>version=alpha</code> set, for example <code>https://app-default.example.org/mypath?version=alpha</code>, the service <code>alpha-svc</code> will get the traffic, if not <code>prod-svc</code>.</p> <p>alpha-svc:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: QueryParam(\"version\", \"^alpha$\")\n  name: alpha-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: alpha-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>prod-svc:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: prod-app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: prod-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#ip-allow-listing","title":"IP Allow Listing","text":"<p>This ingress route will only allow traffic from networks 1.2.3.0/24 and 195.168.0.0/17 Before you use this in production please understand your deployment and check the difference between the following options:</p> <ul> <li>ClientIP</li> <li>Source</li> <li>SourceFromLast</li> </ul> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: ClientIP(\"1.2.3.0/24\", \"195.168.0.0/17\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#ab-test","title":"A/B test","text":"<p>Implementing A/B testing is heavy. Skipper can help you to do that. You need to have a traffic split somewhere and have your customers sticky to either A or B flavor of your application. Most likely people would implement using cookies. Skipper can set a cookie with responseCookie() in a response to the client and the cookie predicate can be used to match the route based on the cookie. Like this you can have sticky sessions to either A or B for your clients.  This example shows to have 10% traffic using A and the rest using B.</p> <p>10% choice of setting the Cookie \u201cflavor\u201d to \u201cA\u201d:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Traffic(.1, \"flavor\", \"A\")\n    zalando.org/skipper-filter: responseCookie(\"flavor\", \"A\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: a-app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>Rest is setting Cookie \u201cflavor\u201d to \u201cB\u201d:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-filter: responseCookie(\"flavor, \"B\", 31536000)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: b-app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>To be sticky, you have to create 2 ingress with predicate to match routes with the cookie we set before. For \u201cA\u201d this would be:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^A$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: a-app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre> <p>For \u201cB\u201d this would be:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/)\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: b-app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#blue-green-deployments","title":"Blue-Green deployments","text":"<p>To do blue-green deployments you have to have control over traffic switching. Skipper gives you the opportunity to set weights to backend services in your ingress specification. <code>zalando.org/backend-weights</code> is a hash map, which key relates to the <code>serviceName</code> of the backend and the value is the weight of traffic you want to send to the particular backend. It works for more than 2 backends, but for simplicity this example shows 2 backends, which should be the default case for supporting blue-green deployments.</p> <p>In the following example my-app-1 service will get 80% of the traffic and my-app-2 will get 20% of the traffic:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app\n  labels:\n    application: my-app\n  annotations:\n    zalando.org/backend-weights: |\n      {\"my-app-1\": 80, \"my-app-2\": 20}\nspec:\n  rules:\n  - host: my-app.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: my-app-1\n            port:\n              name: http\n        pathType: Prefix\n        path: /\n      - backend:\n          service:\n            name: my-app-2\n            port:\n              name: http\n        pathType: Prefix\n        path: /\n</code></pre> <p>For more advanced blue-green deployments, check out our stackset-controller.</p>"},{"location":"kubernetes/ingress-usage/#chaining-filters-and-predicates","title":"Chaining Filters and Predicates","text":"<p>You can set multiple filters in a chain similar to the eskip format.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-predicate: Cookie(\"flavor\", /^B$/) &amp;&amp; Source(\"1.2.3.0/24\", \"195.168.0.0/17\")\n    zalando.org/skipper-filter: clientRatelimit(50, \"10m\") -&gt; requestCookie(\"test-session\", \"abc\")\n  name: app\nspec:\n  rules:\n  - host: app-default.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#controlling-https-redirect","title":"Controlling HTTPS redirect","text":"<p>Skipper Ingress can provide HTTP-&gt;HTTPS redirection. Enabling it and setting the status code used by default can be done with the command line options: <code>-kubernetes-https-redirect</code> and <code>-kubernetes-https-redirect-code</code>. By using annotations, this behavior can be overridden from the individual ingress specs for the scope of routes generated based on these ingresses specs.</p> <p>Annotations:</p> <ul> <li><code>zalando.org/skipper-ingress-redirect</code>: the possible values are true or false. When the global HTTPS redirect is   disabled, the value true enables it for the current ingress. When the global redirect is enabled, the value   false disables it for the current ingress.</li> <li><code>zalando.org/skipper-ingress-redirect-code</code>: the possible values are integers <code>300 &lt;= x &lt; 400</code>. Sets the redirect   status code for the current ingress.</li> </ul> <p>Example:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-ingress-redirect: \"true\"\n    zalando.org/skipper-ingress-redirect-code: 301\n  name: app\nspec:\n  rules:\n  - host: mobile-api.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/ingress-usage/#load-balancer-algorithm","title":"Load Balancer Algorithm","text":"<p>You can set the loadbalancer algorithm, which is used to find the next endpoint for a given request with the ingress annotation <code>zalando.org/skipper-loadbalancer</code>.</p> <p>For example, for some workloads you might want to have always the same endpoint for the same client. For this use case there is the consistent hash algorithm, that finds for a client detected by the IP or X-Forwarded-For header, the same backend. If the backend is not available it would switch to another one.</p> <p>Annotations:</p> <ul> <li><code>zalando.org/skipper-loadbalancer</code> see available choices</li> </ul> <p>Example:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    zalando.org/skipper-loadbalancer: consistentHash\n  name: app\nspec:\n  rules:\n  - host: websocket.example.org\n    http:\n      paths:\n      - backend:\n          service:\n            name: app-svc\n            port:\n              number: 80\n        pathType: ImplementationSpecific\n</code></pre>"},{"location":"kubernetes/migrate/","title":"Migration","text":"<p>This provides a guide for people that want to migrate from another Ingress Controller to Skipper.</p> <p>You can use our Skipper install guide to deploy skipper and test it. Different Ingress controllers have a lot of advantages and disadvantages. Skipper is the most feature rich controller for HTTP. Skipper does not support lower level protocols as plain TCP or plain TLS routes. Skipper can be run as controller or you can build your own controller, because the implementation is a library first code base. You can also check our own production configuration.</p> <p>Skipper is very good at serving HTTP APIs, it\u2019s much faster than others (like nginx or envoy) in routing. Its routing tree is capabable of efficient routing up to 500k routes (not a kubernetes controller installation). In comparision the gateway-api tests end at 5k routes. We run ourselves Skipper as ingress controller in clusters with many above 15k routes. Our routing capabilities is based on predicates, which match the best route for a given request.</p> <p>Skipper can modify every detail in HTTP request and response by using filters, that you apply to a route. One more complex example is authentication for example via Open Policy Agent or cluster based rate limits.</p> <p>Skipper has also a very good visibility features, Prometheus metrics, access logs in Apache format, Opentracing/OTel with detailed proxy spans that show slowness in detail. Check our operations guide to see what you get.</p> <p>Skipper is built to support regular config changes by using dataclients to feed a rebuilt of the routing tree. We rebuild the routing tree every 3s, so config changes through Kubernetes Ingress are quasi instant.</p>"},{"location":"kubernetes/migrate/#ingress-nginx","title":"Ingress Nginx","text":"<p>Ingress Nginx is the most used Ingress Controller as of today. It was early available, OpenSource and maintained by the community. It is trusted, because there is no company that would change to some proprietary license to get some money and Nginx is a well-known trusted and efficient HTTP proxy. The bad news are that it will be retired soon, because of lack on support on maintainers.</p>"},{"location":"kubernetes/migrate/#pros-and-cons-nginx-skipper","title":"Pros and Cons Nginx &lt;-&gt; Skipper","text":"<p>Missing features from Nginx:</p> <ul> <li>TLS routing</li> <li>TCP routing</li> <li>UDP routing</li> </ul> <p>Nginx is very efficient in streaming data. If you need to stream tons of data, then you likely want to check some other controller, because skipper is not made for heavy data streaming. So if you serve 100GB pictures through ingress, check haproxy or similar proxies.</p> <p>If you serve mostly HTTP APIs, skipper provides you a solid solution, that shines with efficiency, visibility, routing with predicates and filters. Many users build their own custom proxy based on skipper. Skipper was used since 10 years in production as an Ingress Controller at Zalando.</p>"},{"location":"kubernetes/migrate/#migration-by-feature","title":"Migration by feature","text":"<p>Ingress Nginx uses a lot of annotations and every feature has a lot of knobs that you need to configure via annotations. You can not just use the same annotations!</p> <p>Skipper has 11 annotations, the most used one is <code>zalando.org/skipper-filter</code>.  Skipper uses the composite pattern and the UNIX philosophy: every filter should do only one job and it should do it well. You will combine filters to make things work as you want. This is a very powerful option, which you likely know from a shell!</p> <p>Examples:</p>"},{"location":"kubernetes/migrate/#mirror-tee","title":"Mirror / tee","text":"<p>Nginx mirror <pre><code>nginx.ingress.kubernetes.io/mirror-target: https://1.2.3.4$request_uri\nnginx.ingress.kubernetes.io/mirror-host: \"test.env.com\"\n</code></pre></p> <p>Skipper tee filters <pre><code>zalando.org/skipper-filter: tee(\"https://test.env.com\")\n</code></pre></p>"},{"location":"kubernetes/migrate/#allow-listing","title":"Allow listing","text":"<p>Nginx <pre><code>nginx.ingress.kubernetes.io/whitelist-source-range: 10.0.0.0/24,172.10.0.1\n</code></pre></p> <p>Skipper predicate ClientIP or Source <pre><code>zalando.org/skipper-predicate: ClientIP(\"10.0.0.0/24\", \"172.10.0.1\")\n</code></pre></p>"},{"location":"kubernetes/migrate/#rate-limit","title":"Rate limit","text":"<p>Nginx (supports only by pod limit) <pre><code>nginx.ingress.kubernetes.io/limit-rps: 100\n</code></pre></p> <p>Skipper supports different style of rate limit filters. Some filters also support template variables. <pre><code># by pod limit\nzalando.org/skipper-filter: clientRatelimit(100, \"1s\")\n\n# by \"group\" key for the whole cluster\nzalando.org/skipper-filter: clusterClientRatelimit(\"groupA\", 100, \"1s\")\n\n# by \"group\" key for the whole cluster by Authorization header\nzalando.org/skipper-filter: clusterClientRatelimit(\"groupB\", 100, \"1m\", \"Authorization\")\n\n# allow 10 requests per minute for each unique PHPSESSID cookie with bursts of up to 5 requests\nclusterLeakyBucketRatelimit(\"session-${request.cookie.PHPSESSID}\", 10, \"1m\", 5, 1)\n</code></pre></p>"},{"location":"kubernetes/migrate/#redirect","title":"Redirect","text":"<p>Nginx <pre><code>nginx.ingress.kubernetes.io/permanent-redirect: https://example.org\nnginx.ingress.kubernetes.io/permanent-redirect-code: '308'\n</code></pre></p> <p>Skipper custom routes supports eskip, skipper\u2019s routing language.  The  backend responds to the client directly from the proxy. <pre><code>zalando.org/skipper-routes: |\n  r: True() -&gt; redirectTo(308, \"https://example.org\") -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"kubernetes/migrate/#cors","title":"CORS","text":"<p>Nginx <pre><code>nginx.ingress.kubernetes.io/enable-cors: \"true\"\nnginx.ingress.kubernetes.io/cors-allow-origin: \"https://api.example.org, https://www.example.org\"\nnginx.ingress.kubernetes.io/cors-allow-credentials: \"true\"\n</code></pre></p> <p>skipper <pre><code>// annotation for the normal ingress\nzalando.org/skipper-filter: |\n  corsOrigin(\"https://api.example.org\", \"https://www.example.org\")\n  -&gt; setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n  -&gt; setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\")\n\n// route for the OPTIONS request\nzalando.org/skipper-routes: |\n  Method(\"OPTIONS\")\n  -&gt; corsOrigin(\"https://api.example.org\", \"https://www.example.org\")\n  -&gt; setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\")\n  -&gt; setResponseHeader(\"Access-Control-Allow-Headers\", \"Authorization\")\n  -&gt; status(200) -&gt; &lt;shunt&gt;\n</code></pre></p>"},{"location":"kubernetes/routegroup-crd/","title":"RouteGroup CRD Semantics","text":"<p>This document contains the semantic definition of the RouteGroup CRD. For more information, see the route group documentation, or see the CRD yaml definition.</p>"},{"location":"kubernetes/routegroup-crd/#concepts","title":"Concepts","text":""},{"location":"kubernetes/routegroup-crd/#routegroup","title":"RouteGroup","text":"<p>A RouteGroup represents a grouped routing specification, with one or more backends, typically a Kubernetes service. The Skipper routes yielded by a route group are handled atomically, meaning that if any problem is detected during processing a route group, none of the generated routes from that group will be applied.</p>"},{"location":"kubernetes/routegroup-crd/#hosts","title":"Hosts","text":"<p>A list of allowed DNS host names that an incoming HTTP request should match in order to be handled by the route group. Host list is mandatory.</p>"},{"location":"kubernetes/routegroup-crd/#backend","title":"Backend","text":"<p>Typically a Kubernetes service, but not necessarily. The routes generated from route groups need to have a backend, therefore at least one backend is mandatory.</p>"},{"location":"kubernetes/routegroup-crd/#default-backend","title":"Default backend","text":"<p>A route group can contain multiple routes. If the routes don\u2019t identify the backend, then the default backends are used. There can be multiple default backends, e.g. to support weighted A/B testing.</p>"},{"location":"kubernetes/routegroup-crd/#route","title":"Route","text":"<p>Routes describe how a matching HTTP request is handled and where it is forwarded to.</p>"},{"location":"kubernetes/routegroup-crd/#predicate","title":"Predicate","text":"<p>A predicate is used during route lookup to identify which route should handle an incoming request. Route group routes provide dedicated fields for the most common predicates like the path or the HTTP method, but in the predicates list field, it is possible to define and configure any predicate supported by Skipper. See the Predicates section of the reference.</p>"},{"location":"kubernetes/routegroup-crd/#filter","title":"Filter","text":"<p>A filter is used during handling the request to shape the request flow. In a route group, any filter supported by Skipper is allowed to be used. See the Filters section of the reference.</p>"},{"location":"kubernetes/routegroup-crd/#routegroup-top-level-object","title":"RouteGroup - top level object","text":"<p>The route group spec must contain hosts, backends, routes and optional default backends.</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nspec:\n  hosts:\n  - &lt;string&gt;\n  backends:\n  - &lt;backend&gt;\n  defaultBackends:\n  - &lt;backendRef&gt;\n  routes:\n  - &lt;route&gt;\n</code></pre>"},{"location":"kubernetes/routegroup-crd/#backend_1","title":"Backend","text":"<p>The <code>&lt;backend&gt;</code> object defines the type of a backend and the required configuration based on the type. Required fields are the name and the type, while the rest of the fields may be required based on the type.</p> <pre><code>&lt;backend&gt;\n  name: &lt;string&gt;\n  type: &lt;string&gt;            one of \"service|shunt|loopback|dynamic|lb|network|forward\"\n  address: &lt;string&gt;         optional, required for type=network\n  algorithm: &lt;string&gt;       optional, valid for type=lb|service, values=roundRobin|random|consistentHash|powerOfRandomNChoices\n  endpoints: &lt;stringarray&gt;  optional, required for type=lb\n  serviceName: &lt;string&gt;     optional, required for type=service\n  servicePort: &lt;number&gt;     optional, required for type=service\n</code></pre> <p>See more about Skipper backends in the backend documentation.</p>"},{"location":"kubernetes/routegroup-crd/#backend-reference","title":"Backend reference","text":"<p>The <code>&lt;backendRef&gt;</code> object references a backend that is defined in the route group\u2019s backends field. The name is a required field, while the weight is optional. If no weight is used at all, then the traffic is split evenly between the referenced backends. One or more backend reference may appear on the route group level as a default backend, or in a route.</p> <pre><code>&lt;backendRef&gt;\n- backendName: &lt;string&gt;\n  weight: &lt;number&gt;          optional\n</code></pre>"},{"location":"kubernetes/routegroup-crd/#route_1","title":"Route","text":"<p>The <code>&lt;route&gt;</code> object defines the actual routing setup with custom matching rules (predicates), and request flow shaping with filters.</p> <pre><code>&lt;route&gt;\n  path: &lt;string&gt;            either path or pathSubtree is allowed\n  pathSubtree: &lt;string&gt;     either path or pathSubtree is allowed\n  pathRegexp: &lt;string&gt;      optional\n  methods: &lt;stringarray&gt;    optional, one of the HTTP methods per entry \"GET|HEAD|PATCH|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE\", defaults to all\n  predicates: &lt;stringarray&gt; optional\n  filters: &lt;stringarray&gt;    optional\n  backends:                 optional, overrides defaults\n  - &lt;backendRef&gt;\n</code></pre> <p>The <code>path</code>, <code>pathSubtree</code> and <code>pathRegexp</code> fields work the same way as the predicate counterparts on eskip routes. See the reference manual for more details.</p> <p>The <code>methods</code> field defines which methods an incoming request can have in order to match the route.</p> <p>The items in the <code>predicates</code> and <code>filter</code> fields take lists of predicates and filters, respectively, defined in their eskip format. Example:</p> <pre><code>  predicates:\n  - Cookie(\"alpha\", \"enabled\")\n  - Header(\"X-Test\", \"true\")\n  filters:\n  - setQuery(\"test\", \"alpha\")\n  - compress()\n</code></pre> <p>See also:</p> <ul> <li>predicates</li> <li>filters</li> </ul> <p>The  references in the backends field, if present, define which backends a route should use."},{"location":"kubernetes/routegroup-validation/","title":"RouteGroup Operations","text":"<p>RouteGroup is a Custom Resource Definition (CRD).</p>"},{"location":"kubernetes/routegroup-validation/#routegroup-validation","title":"RouteGroup Validation","text":"<p>CRDs can be validated at create and update time. The validation can be done via JSON Schemas, which enables input type validation and string validation with regular expressions. In addition to JSON Schema you can use a custom validation webhook.</p> <p>For RouteGroup we provide a CRD yaml with JSON schema and a validation webhook as separate binary <code>webhook</code> in the same docker container as <code>skipper</code>.</p>"},{"location":"kubernetes/routegroup-validation/#synopsis","title":"Synopsis","text":"<pre><code>% docker run registry.opensource.zalan.do/teapot/skipper:latest webhook --help\nusage: webhook [&lt;flags&gt;]\n\nFlags:\n  --help                         Show context-sensitive help (also try --help-long and --help-man).\n  --debug                        Enable debug logging\n  --tls-cert-file=TLS-CERT-FILE  File containing the certificate for HTTPS\n  --tls-key-file=TLS-KEY-FILE    File containing the private key for HTTPS\n  --address=\":9443\"              The address to listen on\n</code></pre>"},{"location":"kubernetes/routegroup-validation/#validation-webhook-installation","title":"Validation Webhook Installation","text":"<p>A Kubernetes validation webhook can be installed next to the kubernetes API server. In order to do this you need:</p> <ol> <li>A container running the webhook</li> <li>A ValidatingWebhookConfiguration configuration</li> </ol> <p>Kubernetes container spec for the RouteGroup validation webhook can be installed in your kube-apiserver Pod, such that it can communicate via localhost.</p> <p>We use the TLS based ValidatingWebhookConfiguration configuration, that we show below, but you can also scroll down to the Configuration without TLS. The configuration will make sure the validation webhook is called on all create and update operations to <code>zalando.org/v1/routegroups</code> by the Kubernetes API server.</p>"},{"location":"kubernetes/routegroup-validation/#configuration-with-tls","title":"Configuration with TLS","text":"<p>Here you can see the Pod spec with enabled TLS:</p> <pre><code>- name: routegroups-admission-webhook\n  image: registry.opensource.zalan.do/teapot/skipper:v0.13.3\n  args:\n    - webhook\n    - --address=:9085\n    - --tls-cert-file=/etc/kubernetes/ssl/admission-controller.pem\n    - --tls-key-file=/etc/kubernetes/ssl/admission-controller-key.pem\n  lifecycle:\n    preStop:\n      exec:\n        command: [\"/bin/sh\", \"-c\",  \" sleep 60\"]\n  readinessProbe:\n    httpGet:\n      scheme: HTTPS\n      path: /healthz\n      port: 9085\n    initialDelaySeconds: 5\n    timeoutSeconds: 5\n  resources:\n    requests:\n      cpu: 50m\n      memory: 100Mi\n  ports:\n    - containerPort: 9085\n  volumeMounts:\n    - mountPath: /etc/kubernetes/ssl\n      name: ssl-certs-kubernetes\n      readOnly: true\n</code></pre> <p>Make sure you pass the <code>caBundle</code> and set the <code>url</code> depending where your webhook container is running. <pre><code>apiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: \"routegroup-admitter.teapot.zalan.do\"\n  labels:\n    application: routegroups-admission-webhook\nwebhooks:\n  - name: \"routegroup-admitter.teapot.zalan.do\"\n    rules:\n      - operations: [\"CREATE\", \"UPDATE\"]\n        apiGroups: [\"zalando.org\"]\n        apiVersions: [\"v1\"]\n        resources: [\"routegroups\"]\n    clientConfig:\n      url: \"https://localhost:9085/routegroups\"\n      caBundle: |\n        ...8&lt;....\n    admissionReviewVersions: [\"v1\"]\n    sideEffects: None\n    timeoutSeconds: 5\n</code></pre></p>"},{"location":"kubernetes/routegroup-validation/#configuration-without-tls","title":"Configuration without TLS","text":"<p>In case you don\u2019t need TLS, you do not need some of the configuration shown above.</p> <p>Container spec without TLS:</p> <pre><code>- name: routegroups-admission-webhook\n  image: registry.opensource.zalan.do/teapot/skipper:v0.13.3\n  args:\n    - webhook\n    - --address=:9085\n  lifecycle:\n    preStop:\n      exec:\n        command: [\"/bin/sh\", \"-c\",  \" sleep 60\"]\n  readinessProbe:\n    httpGet:\n      path: /healthz\n      port: 9085\n    initialDelaySeconds: 5\n    timeoutSeconds: 5\n  resources:\n    requests:\n      cpu: 50m\n      memory: 100Mi\n  ports:\n    - containerPort: 9085\n</code></pre> <p>Validation webhook configuration without TLS:</p> <pre><code>apiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: \"routegroup-admitter.teapot.zalan.do\"\n  labels:\n    application: routegroups-admission-webhook\nwebhooks:\n  - name: \"routegroup-admitter.teapot.zalan.do\"\n    rules:\n      - operations: [\"CREATE\", \"UPDATE\"]\n        apiGroups: [\"zalando.org\"]\n        apiVersions: [\"v1\"]\n        resources: [\"routegroups\"]\n    clientConfig:\n      url: \"http://localhost:9085/routegroups\"\n    admissionReviewVersions: [\"v1\"]\n    sideEffects: None\n    timeoutSeconds: 5\n</code></pre>"},{"location":"kubernetes/routegroups/","title":"Route groups","text":"<p>Route groups are an alternative to the Kubernetes Ingress format for defining ingress rules. They allow to define Skipper routing in Kubernetes, while providing a straightforward way to configure the routing features supported by Skipper and not defined by the generic Ingress.</p>"},{"location":"kubernetes/routegroups/#skipper-as-kubernetes-ingress-controller","title":"Skipper as Kubernetes Ingress controller","text":"<p>Skipper is an extensible HTTP router with rich route matching, and request flow and traffic shaping capabilities. Through its integration with Kubernetes, it can be used in the role of an ingress controller for forwarding incoming external requests to the right services in a cluster. Kubernetes provides the Ingress specification to define the rules by which an ingress controller should handle the incoming traffic. The specification is simple and generic, but doesn\u2019t offer a straightforward way to benefit from Skipper\u2019s rich HTTP related functionality.</p>"},{"location":"kubernetes/routegroups/#routegroups","title":"RouteGroups","text":"<p>A RouteGroup is a custom Kubernetes resource definition. It provides a way to define the ingress routing for Kubernetes services. It allows route matching based on any HTTP request attributes, and provides a clean way for the request flow augmentation and traffic shaping. It supports higher level features like gradual traffic switching, A/B testing, and more.</p> <p>Example:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-routes\nspec:\n  backends:\n  - name: variant-a\n    type: service\n    serviceName: service-a\n    servicePort: 80\n  - name: variant-b\n    type: service\n    serviceName: service-b\n    servicePort: 80\n  defaultBackends:\n  - backendName: variant-b\n  routes:\n  - pathSubtree: /\n    filters:\n    - responseCookie(\"canary\", \"A\")\n    predicates:\n    - Traffic(.1)\n    backends:\n    - backendName: variant-a\n  - pathSubtree: /\n    filters:\n    - responseCookie(\"canary\", \"B\")\n  - pathSubtree: /\n    predicates:\n    - Cookie(\"canary\", \"A\")\n    backends:\n    - backendName: variant-a\n  - pathSubtree: /\n    predicates:\n    - Cookie(\"canary\", \"B\")\n</code></pre> <p>(See a more detailed explanation of the above example further down in this document.)</p> <p>Links:</p> <ul> <li>RouteGroup semantics</li> <li>CRD definition</li> </ul>"},{"location":"kubernetes/routegroups/#requirements","title":"Requirements","text":"<ul> <li>External DNS v0.7.0 or higher</li> <li>Kubernetes Ingress Controller for AWS v0.10.0 or higher</li> </ul>"},{"location":"kubernetes/routegroups/#installation","title":"Installation","text":"<p>The definition file of the CRD can be found as part of Skipper\u2019s source code, at:</p> <p>https://github.com/zalando/skipper/blob/master/dataclients/kubernetes/deploy/apply/routegroups_crd.yaml</p> <p>To install it manually in a cluster, assuming the current directory is the root of Skipper\u2019s source, call this command:</p> <pre><code>kubectl apply -f dataclients/kubernetes/deploy/apply/routegroups_crd.yaml\n</code></pre> <p>This will install a namespaced resource definition, providing the RouteGroup kind:</p> <ul> <li>full name: routegroups.zalando.org</li> <li>resource group: zalando.org/v1</li> <li>resource names: routegroup, routegroups, rg, rgs</li> <li>kind: RouteGroup</li> </ul> <p>The route groups, once any is defined, can be displayed then via kubectl as:</p> <pre><code>kubectl get rgs\n</code></pre> <p>The API URL of the routegroup resources will be:</p> <p>https://kubernetes-api-hostname/apis/zalando.org/v1/routegroups</p>"},{"location":"kubernetes/routegroups/#usage","title":"Usage","text":"<p>The absolute minimal route group configuration for a Kubernetes service (my-service) looks as follows:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  routes:\n    - pathSubtree: /\n      backends:\n        - backendName: my-backend\n</code></pre> <p>This is equivalent to the ingress:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\nspec:\n  defaultBackend:\n    service:\n      name: my-service\n      port:\n        number: 80\n</code></pre> <p>Notice that the route group contains a list of actual backends, and the defined service backend is then referenced as the default backend. This structure plays a role in supporting scenarios like A/B testing and gradual traffic switching, explained below. The backend definition also has a type field, whose values can be service, lb, network, shunt, loopback or dynamic. More details on that below.</p> <p>Creating, updating and deleting route groups happens the same way as with ingress objects. E.g, manually applying a route group definition:</p> <pre><code>kubectl apply -f my-route-group.yaml\n</code></pre>"},{"location":"kubernetes/routegroups/#hosts","title":"Hosts","text":"<ul> <li>Format</li> </ul> <p>Hosts contain hostnames that are used to match the requests handled by a given route group. They are also used to update the required DNS entries and load balancer configuration if the cluster is set up that way.</p> <p>Note that it is also possible to use any Skipper predicate in the routes of a route group, with the Host predicate included, but the hostnames defined that way will not serve as input for the DNS configuration.</p>"},{"location":"kubernetes/routegroups/#backends","title":"Backends","text":"<ul> <li>Format</li> <li>General backend reference</li> </ul> <p>RouteGroups support different backends. The most typical backend type is the \u2018service\u2019, and it works the same way as in case of ingress definitions.</p> <p>In a RouteGroup, there can be multiple backends and they are listed on the top level of the route group spec, and are referenced from the actual routes or as default backends.</p>"},{"location":"kubernetes/routegroups/#typeservice","title":"type=service","text":"<p>This backend resolves to a Kubernetes service. It works the same way as in case of Ingress definitions. Skipper resolves the Services to the available Endpoints belonging to the Service, and generates load balanced routes using them. (This basically means that under the hood, a <code>service</code> backend becomes an <code>lb</code> backend.)</p>"},{"location":"kubernetes/routegroups/#typelb","title":"type=lb","text":"<p>This backend provides load balancing between multiple network endpoints. Keep in mind that the service type backend automatically generates load balanced routes for the service endpoints, so this backend type typically doesn\u2019t need to be used for services.</p>"},{"location":"kubernetes/routegroups/#typenetwork","title":"type=network","text":"<p>This backend type results in routes that proxy incoming requests to the defined network address, regardless of the Kubernetes semantics, and allows URLs that point somewhere else, potentially outside of the cluster, too.</p>"},{"location":"kubernetes/routegroups/#typeshunt-typeloopback-typedynamic-typeforward","title":"type=shunt, type=loopback, type=dynamic, type=forward","text":"<p>These backend types allow advanced routing setups. Please check the reference manual for more details.</p>"},{"location":"kubernetes/routegroups/#default-backends","title":"Default Backends","text":"<ul> <li>Format</li> </ul> <p>A default backend is a reference to one of the defined backends. When a route doesn\u2019t specify which backend(s) to use, the ones referenced in the default backends will be used.</p> <p>In case there are no individual routes at all in the route group, a default set of routes (one or more) will be generated and will proxy the incoming traffic to the default backends.</p> <p>The reason, why multiple backends can be referenced as default, is that this makes it easy to execute gradual traffic switching between different versions, even more than two, of the same application. See more.</p>"},{"location":"kubernetes/routegroups/#routes","title":"Routes","text":"<ul> <li>Format</li> </ul> <p>Routes define where to and how the incoming requests will be proxied. The predicates, including the path, pathSubtree, pathRegexp and methods fields, and any free-form predicate listed under the predicates field, control which requests are matched by a route, the filters can apply changes to the forwarded requests and the returned responses, and the backend refs, if defined, override the default backends, where the requests will be proxied to. If a route group doesn\u2019t contain any explicit routes, but it contains default backends, a default set of routes will be generated for the route group.</p> <p>Important to bear in mind about the path fields, that the plain \u2018path\u2019 means exact path match, while \u2018pathSubtree\u2019 behaves as a path prefix, and so it is more similar to the path in the Ingress specification.</p> <p>See also:</p> <ul> <li>predicates</li> <li>filters</li> </ul>"},{"location":"kubernetes/routegroups/#gradual-traffic-switching","title":"Gradual traffic switching","text":"<p>The weighted backend references allow to split the traffic of a single route and send it to different backends with the ratio defined by the weights of the backend references. E.g:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-routes\nspec:\n  hosts:\n  - api.example.org\n  backends:\n  - name: api-svc-v1\n    type: service\n    serviceName: api-service-v1\n    servicePort: 80\n  - name: api-svc-v2\n    type: service\n    serviceName: foo-service-v2\n    servicePort: 80\n  routes:\n  - pathSubtree: /api\n    backends:\n    - backendName: api-svc-v1\n      weight: 80\n    - backendName: api-svc-v2\n      weight: 20\n</code></pre> <p>In case of the above example, 80% of the requests is sent to api-service-v1 and the rest is sent to api-service-v2.</p> <p>Since this type of weighted traffic switching can be used in combination with the Traffic predicate, it is possible to control the routing of a long running A/B test, while still executing gradual traffic switching independently to deploy a new version of the variants, maybe to deploy a fix only to one variant. E.g:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-routes\nspec:\n  hosts:\n  - api.example.org\n  backends:\n  - name: variant-a\n    type: service\n    serviceName: service-a\n    servicePort: 80\n  - name: variant-b\n    type: service\n    serviceName: service-b-v1\n    servicePort: 80\n  - name: variant-b-v2\n    type: service\n    serviceName: service-b-v2\n    servicePort: 80\n  defaultBackends:\n  - backendName: variant-b\n    weight: 80\n  - backendName: variant-b-v2\n    weight: 20\n  routes:\n  - filters:\n    - responseCookie(\"canary\", \"A\")\n    predicates:\n    - Traffic(.1)\n    backends:\n    - backendName: variant-a\n  - filters:\n    - responseCookie(\"canary\", \"B\")\n  - predicates:\n    - Cookie(\"canary\", \"A\")\n    backends:\n    - backendName: variant-a\n  - predicates:\n    - Cookie(\"canary\", \"B\")\n</code></pre> <p>See also:</p> <ul> <li>Traffic predicate</li> </ul>"},{"location":"kubernetes/routegroups/#mapping-from-ingress-to-routegroups","title":"Mapping from Ingress to RouteGroups","text":"<p>RouteGroups are one-way compatible with Ingress, meaning that every Ingress specification can be expressed in the RouteGroup format, as well. In the following, we describe the mapping from Ingress fields to RouteGroup fields.</p>"},{"location":"kubernetes/routegroups/#ingress-with-default-backend","title":"Ingress with default backend","text":"<p>Ingress:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\nspec:\n  defaultBackend:\n    service:\n      name: my-service\n      port:\n        number: 80\n</code></pre> <p>RouteGroup:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  defaultBackends:\n  - backendName: my-backend\n</code></pre>"},{"location":"kubernetes/routegroups/#ingress-with-path-rule","title":"Ingress with path rule","text":"<p>Ingress:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\nspec:\n  rules:\n  - host: api.example.org\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: my-service\n            port:\n              number: 80\n</code></pre> <p>RouteGroup:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  hosts:\n  - api.example.org\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  routes:\n  - pathSubtree: /api\n</code></pre>"},{"location":"kubernetes/routegroups/#ingress-with-multiple-hosts","title":"Ingress with multiple hosts","text":"<p>Ingress (we need to define two rules):</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\nspec:\n  rules:\n  - host: api.example.org\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: my-service\n            port:\n              number: 80\n  - host: legacy-name.example.org\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: my-service\n            port:\n              number: 80\n</code></pre> <p>RouteGroup (we just define an additional host):</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  hosts:\n  - api.example.org\n  - legacy-name.example.org\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  routes:\n  - pathSubtree: /api\n</code></pre>"},{"location":"kubernetes/routegroups/#ingress-with-multiple-hosts-and-different-routing","title":"Ingress with multiple hosts, and different routing","text":"<p>For those cases when using multiple hostnames in the same ingress with different rules, we need to apply a small workaround for the equivalent route group spec. Ingress:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\nspec:\n  rules:\n  - host: api.example.org\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: my-service\n            port:\n              number: 80\n  - host: legacy-name.example.org\n    http:\n      paths:\n      - path: /application\n        pathType: Prefix\n        backend:\n          service:\n            name: my-service\n            port:\n              number: 80\n</code></pre> <p>RouteGroup (we need to use additional host predicates):</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  hosts:\n  - api.example.org\n  - legacy-name.example.org\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  routes:\n  - pathSubtree: /api\n    predicates:\n    - Host(\"api.example.org\")\n  - pathSubtree: /application\n    predicates:\n    - Host(\"legacy-name.example.org\")\n</code></pre> <p>The RouteGroups allow multiple hostnames for each route group, but by default, their union is used during routing. If we want to distinguish between them, then we need to use an additional Host predicate in the routes. Importantly, only the hostnames listed under the hosts field serve as input for the DNS and LB configuration.</p>"},{"location":"kubernetes/routegroups/#mapping-skipper-ingress-extensions-to-routegroups","title":"Mapping Skipper Ingress extensions to RouteGroups","text":"<p>Skipper accepts a set of annotations in Ingress objects that give access to certain Skipper features that would not be possible with the native fields of the Ingress spec, e.g. improved path handling or rate limiting. These annotations can be expressed now natively in the RouteGroups.</p>"},{"location":"kubernetes/routegroups/#zalandoorgbackend-weights","title":"zalando.org/backend-weights","text":"<p>Backend weights are now part of the backend references, and they can be controlled for multiple backend sets within the same route group. See Gradual traffic switching.</p>"},{"location":"kubernetes/routegroups/#zalandoorgskipper-filter-and-zalandoorgskipper-predicate","title":"zalando.org/skipper-filter and zalando.org/skipper-predicate","text":"<p>Filters and predicates are now part of the route objects, and different set of filters or predicates can be set for different routes.</p>"},{"location":"kubernetes/routegroups/#zalandoorgskipper-routes","title":"zalando.org/skipper-routes","text":"<p>\u201cCustom routes\u201d in a route group are unnecessary, because every route can be configured with predicates, filters and backends without limitations. E.g where an ingress annotation\u2019s metadata may look like this:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\n  zalando.org/skipper-routes: |\n    Method(\"OPTIONS\") -&gt; status(200) -&gt; &lt;shunt&gt;\nspec:\n  backend:\n    service:\n      name: my-service\n      port:\n        number: 80\n</code></pre> <p>the equivalent RouteGroup would look like this:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  - name: options200\n    type: shunt\n  defaultBackends:\n  - backendName: my-backend\n  routes:\n  - pathSubtree: /\n  - pathSubtree: /\n    methods: OPTIONS\n    filters:\n    - status(200)\n    backends:\n    - backendName: options200\n</code></pre>"},{"location":"kubernetes/routegroups/#zalandoorgratelimit","title":"zalando.org/ratelimit","text":"<p>The ratelimiting can be defined on the route level among the filters, in the same format as in this annotation.</p>"},{"location":"kubernetes/routegroups/#zalandoorgskipper-ingress-redirect-and-zalandoorgskipper-ingress-redirect-code","title":"zalando.org/skipper-ingress-redirect and zalando.org/skipper-ingress-redirect-code","text":"<p>Skipper ingress provides global HTTPS redirect, but it allows individual ingresses to override the global settings: enabling/disabling it and changing the default redirect code. With route groups, this override can be achieved by simply defining an additional route, with the same matching rules, and therefore the override can be controlled eventually on a route basis. E.g:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\nspec:\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  - name: redirectShunt\n    type: shunt\n  defaultBackends:\n  - backendName: my-backend\n  routes:\n  - pathSubtree: /\n  - pathSubtree: /\n    predicates:\n    - Header(\"X-Forwarded-Proto\", \"http\")\n    filters:\n    - redirectTo(302, \"https:\")\n    backends:\n    - backendName: redirectShunt\n</code></pre>"},{"location":"kubernetes/routegroups/#zalandoorgskipper-loadbalancer","title":"zalando.org/skipper-loadbalancer","text":"<p>Skipper Ingress doesn\u2019t use the ClusterIP of the Service for forwarding the traffic to, but sends it directly to the Endpoints represented by the Service, and balances the load between them with the round-robin algorithm. The algorithm choice can be overridden by this annotation. In case of the RouteGroups, the algorithm is simply an attribute of the backend definition, and it can be set individually for each backend. E.g:</p> <pre><code>  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n    algorithm: consistentHash\n</code></pre> <p>See also:</p> <ul> <li>Load Balancer backend</li> </ul>"},{"location":"kubernetes/routegroups/#zalandoorgskipper-ingress-path-mode","title":"zalando.org/skipper-ingress-path-mode","text":"<p>The route objects support the different path lookup modes, by using the path, pathSubtree or the pathRegexp field. See also the route matching explained for the internals. The mapping is as follows:</p> Ingress pathType: RouteGroup: <code>Exact</code> and <code>/foo</code> path: <code>/foo</code> <code>Prefix</code> and <code>/foo</code> pathSubtree: <code>/foo</code> Ingress (<code>pathType: ImplementationSpecific</code>): RouteGroup: <code>kubernetes-ingress</code> and <code>/foo</code> pathRegexp: <code>^/foo</code> <code>path-regexp</code> and <code>/foo</code> pathRegexp: <code>/foo</code> <code>path-prefix</code> and <code>/foo</code> pathSubtree: <code>/foo</code> <code>kubernetes-ingress</code> and /foo$ path: <code>/foo</code>"},{"location":"kubernetes/routegroups/#multiple-skipper-deployments","title":"Multiple skipper deployments","text":"<p>If you want to split for example <code>internal</code> and <code>public</code> traffic, it might be a good choice to split your RouteGroups. Skipper has the flag <code>--kubernetes-routegroup-class=&lt;string&gt;</code> to only select RouteGroup objects that have the annotation <code>zalando.org/routegroup.class</code> set to <code>&lt;string&gt;</code>. Skipper will only create routes for RouteGroup objects with it\u2019s annotation or RouteGroup objects that do not have this annotation. The default class is <code>skipper</code>, if not set.</p> <p>Example RouteGroup:</p> <pre><code>apiVersion: zalando.org/v1\nkind: RouteGroup\nmetadata:\n  name: my-route-group\n  annotations:\n    zalando.org/routegroup.class: internal\nspec:\n  backends:\n  - name: my-backend\n    type: service\n    serviceName: my-service\n    servicePort: 80\n  defaultBackends:\n  - backendName: my-service\n</code></pre>"},{"location":"operation/deployment/","title":"Deployments and Data-Clients","text":""},{"location":"operation/deployment/#edge-http-routing","title":"Edge HTTP Routing","text":"<p>Edge HTTP routing is the first hit to your production HTTP loadbalancer. Skipper can serve this well and reliably in production since 2016.</p> <p>On the edge you want to dispatch incoming HTTP requests to your backends, which could be a microservice architecture.</p> <p>In this deployment mode you might have 100k HTTP routes, which are used in production and modified by many parties.</p> <p>To support this scenario we have the etcd dataclient.</p> <p>Etcd is a distributed database.</p> <p>TODO: why we use ETCD for this purpose</p>"},{"location":"operation/deployment/#kubernetes-ingress","title":"Kubernetes Ingress","text":"<p>Kubernetes Ingress is the component responsible to route traffic into your Kubernetes cluster. As deployer you can define an ingress object and an ingress controller will make sure incoming traffic gets routed to her backend service as defined. Skipper supports this scenario with the Kubernetes dataclient and is used in production since end of 2016.</p> <p>Skipper as ingress controller does not need to have any file configuration or anything external which configures Skipper. Skipper automatically finds Ingress objects and configures routes automatically, without reloading. The only requirement is to target all traffic you want to serve with Kubernetes to a loadbalancer pool of Skippers. This is a clear advantage over other ingress controllers like nginx, haproxy or envoy.</p> <p>Read more about Skipper\u2019s Kubernetes dataclient.</p>"},{"location":"operation/deployment/#demos-talks","title":"Demos / Talks","text":"<p>In demos you may want to show arbitrary hello world applications. You can easily describe html or json output on the command line with the route-string dataclient.</p>"},{"location":"operation/deployment/#simple-routes-file","title":"Simple Routes File","text":"<p>The most static deployment that is known from apache, nginx or haproxy is write your routes into a file and start your http server. This is what the Eskip file dataclient is about.</p>"},{"location":"operation/operation/","title":"Operations","text":"<p>This is the work in progress operations guide for showing information, which are relevant for production use.</p> <p>Skipper is proven to scale with number of routes beyond 300.000 routes per instance. In Kubernetes we run beyond 15000 routes in a single cluster. A single Skipper instance was tested to respond 65.000 http requests per second in continuous load tests at <code>&lt;=25ms</code> p999 in a production like setup with logs, metrics and tracing enabled. Skipper regularly runs in production at 2 million requests per second running multiple instances.</p>"},{"location":"operation/operation/#connection-options","title":"Connection Options","text":"<p>Skipper\u2019s connection options are allowing you to set Go\u2019s http.Server Options on the client side and http.Transport on the backend side.</p> <p>It is recommended to read this blog post about net http timeouts in order to better understand the impact of these settings.</p>"},{"location":"operation/operation/#backend","title":"Backend","text":"<p>Backend is the side skipper opens a client connection to.</p> <p>Closing idle connections is required for DNS failover, because Go\u2019s http.Transport caches DNS lookups and needs to create new connections for doing so. Skipper will start a goroutine and use the specified time.Duration to call CloseIdleConnections() on that http.Transport.</p> <pre><code>-close-idle-conns-period string\n    period of closing all idle connections in seconds or as a\n    duration string. Not closing when less than 0 (default \"20\")\n</code></pre> <p>This will set MaxIdleConnsPerHost on the http.Transport to limit the number of idle connections per backend such that we do not run out of sockets.</p> <pre><code>-idle-conns-num int\n    maximum idle connections per backend host (default 64)\n</code></pre> <p>This will set MaxIdleConns on the http.Transport to limit the number for all backends such that we do not run out of sockets.</p> <pre><code>-disable-http-keepalives bool\n    forces backend to always create a new connection\n</code></pre> <p>This will set DisableKeepAlives on the http.Transport to disable HTTP keep-alive and to only use the connection for single request.</p> <pre><code>-max-idle-connection-backend int\n    sets the maximum idle connections for all backend connections\n</code></pre> <p>This will set TLSHandshakeTimeout on the http.Transport to have timeouts based on TLS connections.</p> <pre><code>-tls-timeout-backend duration\n    sets the TLS handshake timeout for backend connections (default 1m0s)\n</code></pre> <p>This will set Timeout on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport.</p> <pre><code>-timeout-backend duration\n    sets the TCP client connection timeout for backend connections (default 1m0s)\n</code></pre> <p>This will set KeepAlive on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport.</p> <pre><code>-keepalive-backend duration\n    sets the keepalive for backend connections (default 30s)\n</code></pre> <p>This will set DualStack (IPv4 and IPv6) on net.Dialer that is the implementation of DialContext, which is the TCP connection pool used in the http.Transport.</p> <pre><code>-enable-dualstack-backend\n    enables DualStack for backend connections (default true)\n</code></pre>"},{"location":"operation/operation/#client","title":"Client","text":"<p>Client is the side skipper gets incoming calls from. Here we can set timeouts in different parts of the http connection.</p> <p>This will set ReadTimeout in http.Server handling incoming calls from your clients.</p> <pre><code>-read-timeout-server duration\n    set ReadTimeout for http server connections (default 5m0s)\n</code></pre> <p>This will set ReadHeaderTimeout in http.Server handling incoming calls from your clients.</p> <pre><code>-read-header-timeout-server duration\n    set ReadHeaderTimeout for http server connections (default 1m0s)\n</code></pre> <p>This will set WriteTimeout in http.Server handling incoming calls from your clients.</p> <pre><code>-write-timeout-server duration\n    set WriteTimeout for http server connections (default 1m0s)\n</code></pre> <p>This will set IdleTimeout in http.Server handling incoming calls from your clients. If you have another loadbalancer layer in front of your Skipper http routers, for example AWS Application Load Balancers, you should make sure, that Skipper\u2019s <code>idle-timeout-server</code> setting is bigger than the idle timeout from the loadbalancer in front. Wrong combinations of idle timeouts can lead to a few unexpected HTTP 502.</p> <pre><code>-idle-timeout-server duration\n    maximum idle connections per backend host (default 1m0s)\n</code></pre> <p>This configures maximum number of requests served by server connections:</p> <pre><code>-keepalive-requests-server int\n    sets maximum number of requests for http server connections. The connection is closed after serving this number of requests. Default is 0 for unlimited.\n</code></pre> <p>This configures maximum age for server connections:</p> <pre><code>-keepalive-server duration\n    sets maximum age for http server connections. The connection is closed after it existed for this duration. Default is 0 for unlimited.\n</code></pre> <p>This will set MaxHeaderBytes in http.Server to limit the size of the http header from your clients.</p> <pre><code>-max-header-bytes int\n    set MaxHeaderBytes for http server connections (default 1048576)\n</code></pre>"},{"location":"operation/operation/#tcp-lifo","title":"TCP LIFO","text":"<p>Skipper implements now controlling the maximum incoming TCP client connections.</p> <p>The purpose of the mechanism is to prevent Skipper requesting more memory than available in case of too many concurrent connections, especially in an autoscaling deployment setup, in those case when the scaling is not fast enough to follow sudden connection spikes.</p> <p>This solution relies on a listener implementation combined with a LIFO queue. It allows only a limited number of connections being handled concurrently, defined by the max concurrency configuration. When the max concurrency limit is reached, the new incoming client connections are stored in a queue. When an active (accepted) connection is closed, the most recent pending connection from the queue will be accepted. When the queue is full, the oldest pending connection is closed and dropped, and the new one is inserted into the queue.</p> <p>The feature can be enabled with the <code>-enable-tcp-queue</code> flag. The maximum concurrency can bet set with the <code>-max-tcp-listener-concurrency</code> flag, or, if this flag is not set, then Skipper tries to infer the maximum accepted concurrency from the system by reading the /sys/fs/cgroup/memory/memory.limit_in_bytes file. In this case, it uses the average expected per request memory requirement, which can be set with the <code>-expected-bytes-per-request</code> flag.</p> <p>Note that the automatically inferred limit may not work as expected in an environment other than cgroups v1 or cgroups v2.</p>"},{"location":"operation/operation/#oauth2-tokeninfo","title":"OAuth2 Tokeninfo","text":"<p>OAuth2 filters integrate with external services and have their own connection handling. Outgoing calls to these services have a default timeout of 2s, which can be changed by the flag <code>-oauth2-tokeninfo-timeout=&lt;OAuthTokeninfoTimeout&gt;</code>.</p>"},{"location":"operation/operation/#oauth2-tokenintrospection-rfc7662","title":"OAuth2 Tokenintrospection RFC7662","text":"<p>OAuth2 filters integrate with external services and have their own connection handling. Outgoing calls to these services have a default timeout of 2s, which can be changed by the flag <code>-oauth2-tokenintrospect-timeout=&lt;OAuthTokenintrospectionTimeout&gt;</code>.</p>"},{"location":"operation/operation/#monitoring","title":"Monitoring","text":"<p>Monitoring is one of the most important things you need to run in production and skipper has a godoc page for the metrics package, describing options and most keys you will find in the metrics handler endpoint. The default is listening on <code>:9911/metrics</code>. You can modify the listen port with the <code>-support-listener</code> flag. Metrics can exposed using formats Codahale (json) or Prometheus and be configured by <code>-metrics-flavour=</code>, which defaults to <code>codahale</code>. To expose both formats you can use a comma separated list: <code>-metrics-flavour=codahale,prometheus</code>.</p>"},{"location":"operation/operation/#prometheus","title":"Prometheus","text":"<p>In case you want to get metrics in Prometheus format exposed, use this option to enable it:</p> <pre><code>-metrics-flavour=prometheus\n</code></pre> <p>It will return Prometheus metrics on the common metrics endpoint :9911/metrics.</p> <p>To monitor skipper we recommend the following queries:</p> <ul> <li>P99 Proxy latency: <code>histogram_quantile(0.99, sum(rate(skipper_proxy_total_duration_seconds_bucket{}[1m])) by (le))</code></li> <li>P99 backend latency: <code>histogram_quantile(0.99, sum(rate(skipper_serve_host_duration_seconds_bucket{}[1m])) by (le))</code></li> <li>HTTP 2xx rate: <code>histogram_quantile(0.99, sum(rate(skipper_serve_host_duration_seconds_bucket{code =~ \"2.*\"}[1m])) by (le) )</code></li> <li>HTTP 4xx rate: <code>histogram_quantile(0.99, sum(rate(skipper_serve_host_duration_seconds_bucket{code =~ \"4.*\"}[1m])) by (le) )</code></li> <li>HTTP 5xx rate: <code>histogram_quantile(0.99, sum(rate(skipper_serve_host_duration_seconds_bucket{code =~ \"52.*\"}[1m])) by (le) )</code></li> <li>Max goroutines (depends on label selector): <code>max(go_goroutines{application=\"skipper-ingress\"})</code></li> <li>Max threads (depends on label selector): <code>max(go_threads{application=\"skipper-ingress\"})</code></li> <li>max heap memory in use in MB (depends on label selector): <code>max(go_memstats_heap_inuse_bytes{application=\"skipper-ingress\"}) / 1024 / 1000</code></li> <li>Max number of heap objects (depends on label selector): <code>max(go_memstats_heap_objects{application=\"skipper-ingress\"})</code></li> <li>Max of P75 Go GC runtime in ms (depends on label selector): <code>max(go_gc_duration_seconds{application=\"skipper-ingress\",quantile=\"0.75\"}) * 1000 * 1000</code></li> <li>P99 request filter duration (depends on label selector): <code>histogram_quantile(0.99, sum(rate(skipper_filter_request_duration_seconds_bucket{application=\"skipper-ingress\"}[1m])) by (le) )</code></li> <li>P99 response filter duration (depends on label selector): <code>histogram_quantile(0.99, sum(rate(skipper_filter_response_duration_seconds_bucket{application=\"skipper-ingress\"}[1m])) by (le) )</code></li> <li>If you use Kubernetes limits or Linux cgroup CFS quotas (depends on label selector): <code>sum(rate(container_cpu_cfs_throttled_periods_total{container_name=\"skipper-ingress\"}[1m]))</code></li> </ul> <p>You may add static metrics labels like <code>version</code> using Prometheus relabeling feature.</p>"},{"location":"operation/operation/#proxy-metrics","title":"Proxy Metrics","text":"<p>Skipper Proxy Metrics provides information about the time spent by skipper in processing a request i.e., the time spent by a request inside skipper (this excludes the response application of filters to a req/res, the backend roundtrip and serving the response). The total proxy metrics are enabled by default and these metrics can be used to build KPIs / SLOs, so as to understand and monitor the performance of skipper.</p> <p>The Proxy Metrics excludes the filter processing as this is dependent on which filters the user decides to use for a particular route. The backend round trip time depends on the backend application and the operation being performed. And the serve response depends on the client. These are operations are not in control of skipper and are hence excluded to solely monitor the performance of Skipper.</p> <p>These metrics are exposed in /metrics, the example json structure looks like this:</p> <pre><code>{\n  \"timers\" : {\n    \"skipper.proxy.total\": {\n      \"15m.rate\": 0.2,\n      \"1m.rate\": 0.2,\n      \"5m.rate\": 0.2,\n      \"75%\": 288375,\n      \"95%\": 288375,\n      \"99%\": 288375,\n      \"99.9%\": 288375,\n      \"count\": 1,\n      \"max\": 288375,\n      \"mean\": 288375,\n      \"mean.rate\": 0.7268368234069077,\n      \"median\": 288375,\n      \"min\": 288375,\n      \"stddev\": 0\n    },\n  }\n}\n</code></pre> <p>The proxy metrics can also be fetched in more detail, i.e., splits the proxy total metrics to get the proxy request metrics and proxy response metrics. The Proxy Request Metrics provides the duration / time taken from the start of ServeHTTP till the backend round trip. The Proxy Response Metrics provides the duration / time taken from after the backend round trip till the response is served.</p> <pre><code>-proxy-request-metrics\n    enables the collection proxy request metrics\n-proxy-response-metrics\n    enables the collection proxy response metrics\n</code></pre> <p>If enabled these metrics are also exposed in /metrics, and the example json structure would like the following:</p> <pre><code>{\n  \"timers\": {\n    \"skipper.proxy.request\": {\n      \"15m.rate\": 0.2,\n      \"1m.rate\": 0.2,\n      \"5m.rate\": 0.2,\n      \"75%\": 0,\n      \"95%\": 0,\n      \"99%\": 0,\n      \"99.9%\": 0,\n      \"count\": 1,\n      \"max\": 0,\n      \"mean\": 0,\n      \"mean.rate\": 0.7268396413261223,\n      \"median\": 0,\n      \"min\": 0,\n      \"stddev\": 0\n    },\n    \"skipper.proxy.response\": {\n      \"15m.rate\": 0.2,\n      \"1m.rate\": 0.2,\n      \"5m.rate\": 0.2,\n      \"75%\": 288375,\n      \"95%\": 288375,\n      \"99%\": 288375,\n      \"99.9%\": 288375,\n      \"count\": 1,\n      \"max\": 288375,\n      \"mean\": 288375,\n      \"mean.rate\": 0.7268397290232465,\n      \"median\": 288375,\n      \"min\": 288375,\n      \"stddev\": 0\n    },\n  }\n}\n</code></pre>"},{"location":"operation/operation/#connection-metrics","title":"Connection metrics","text":"<p>This option will enable known loadbalancer connections metrics, like counters for active and new connections. This feature sets a metrics callback on http.Server and uses a counter to collect http.ConnState.</p> <pre><code>-enable-connection-metrics\n    enables connection metrics for http server connections\n</code></pre> <p>It will expose them in /metrics, for example json structure looks like this example:</p> <pre><code>{\n  \"counters\": {\n    \"skipper.lb-conn-active\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-closed\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-idle\": {\n      \"count\": 6\n    },\n    \"skipper.lb-conn-new\": {\n      \"count\": 6\n    }\n  },\n  /* stripped a lot of metrics here */\n}\n</code></pre>"},{"location":"operation/operation/#lifo-metrics","title":"LIFO metrics","text":"<p>When enabled in the routes, LIFO queues can control the maximum concurrency level proxied to the backends and mitigate the impact of traffic spikes. The current level of concurrency and the size of the queue can be monitored with gauges per each route using one of the lifo filters. To enable monitoring for the lifo filters, use the command line option:</p> <pre><code>-enable-route-lifo-metrics\n</code></pre> <p>When queried, it will return metrics like:</p> <pre><code>{\n  \"gauges\": {\n    \"skipper.lifo.routeXYZ.active\": {\n      \"value\": 245\n    },\n    \"skipper.lifo.routeXYZ.queued\": {\n      \"value\": 27\n    }\n  }\n}\n</code></pre>"},{"location":"operation/operation/#application-metrics","title":"Application metrics","text":"<p>Application metrics for your proxied applications you can enable with the option:</p> <pre><code>-serve-host-metrics\n    enables reporting total serve time metrics for each host\n-serve-route-metrics\n    enables reporting total serve time metrics for each route\n</code></pre> <p>This will make sure you will get stats for each \u201cHost\u201d header or the route name as \u201ctimers\u201d. The following is an example for <code>-serve-host-metrics</code>:</p> <pre><code>\"timers\": {\n  \"skipper.servehost.app1_example_com.GET.200\": {\n    \"15m.rate\": 0.06830666203045982,\n    \"1m.rate\": 2.162612637718806e-06,\n    \"5m.rate\": 0.008312609284452856,\n    \"75%\": 236603815,\n    \"95%\": 236603815,\n    \"99%\": 236603815,\n    \"99.9%\": 236603815,\n    \"count\": 3,\n    \"max\": 236603815,\n    \"mean\": 116515451.66666667,\n    \"mean.rate\": 0.0030589345776699827,\n    \"median\": 91273391,\n    \"min\": 21669149,\n    \"stddev\": 89543653.71950394\n  },\n  \"skipper.servehost.app1_example_com.GET.304\": {\n    \"15m.rate\": 0.3503336738177459,\n    \"1m.rate\": 0.07923086447313292,\n    \"5m.rate\": 0.27019839341602214,\n    \"75%\": 99351895.25,\n    \"95%\": 105381847,\n    \"99%\": 105381847,\n    \"99.9%\": 105381847,\n    \"count\": 4,\n    \"max\": 105381847,\n    \"mean\": 47621612,\n    \"mean.rate\": 0.03087161486272533,\n    \"median\": 41676170.5,\n    \"min\": 1752260,\n    \"stddev\": 46489302.203724876\n  },\n  \"skipper.servehost.app1_example_com.GET.401\": {\n    \"15m.rate\": 0.16838468990057648,\n    \"1m.rate\": 0.01572861413072501,\n    \"5m.rate\": 0.1194724817779537,\n    \"75%\": 91094832,\n    \"95%\": 91094832,\n    \"99%\": 91094832,\n    \"99.9%\": 91094832,\n    \"count\": 2,\n    \"max\": 91094832,\n    \"mean\": 58090623,\n    \"mean.rate\": 0.012304914018033056,\n    \"median\": 58090623,\n    \"min\": 25086414,\n    \"stddev\": 33004209\n  }\n},\n</code></pre> <p>Note you can reduce the dimension of the metrics by removing the HTTP status code and method from it. Use the <code>-serve-method-metric=false</code> and/or <code>-serve-status-code-metric=false</code>. Both flags are enabled by default. For prometheus metrics flavour, a counter with both the HTTP method and status code can be enabled with <code>-serve-host-counter</code> or <code>-serve-route-counter</code>, even if these flags are disabled.</p> <p>To change the sampling type of how metrics are handled from uniform to exponential decay, you can use the following option, which is better for not so huge utilized applications (less than 100 requests per second):</p> <pre><code>-metrics-exp-decay-sample\n    use exponentially decaying sample in metrics\n</code></pre>"},{"location":"operation/operation/#go-metrics","title":"Go metrics","text":"<p>Metrics from the go runtime memstats are exposed from skipper to the metrics endpoint, default listener :9911, on path /metrics</p>"},{"location":"operation/operation/#go-metrics-codahale","title":"Go metrics - Codahale","text":"<pre><code>\"gauges\": {\n  \"skipper.runtime.MemStats.Alloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.BuckHashSys\": {\n    \"value\": 1452675\n  },\n  \"skipper.runtime.MemStats.DebugGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.EnableGC\": {\n    \"value\": 1\n  },\n  \"skipper.runtime.MemStats.Frees\": {\n    \"value\": 121\n  },\n  \"skipper.runtime.MemStats.HeapAlloc\": {\n    \"value\": 3083680\n  },\n  \"skipper.runtime.MemStats.HeapIdle\": {\n    \"value\": 778240\n  },\n  \"skipper.runtime.MemStats.HeapInuse\": {\n    \"value\": 4988928\n  },\n  \"skipper.runtime.MemStats.HeapObjects\": {\n    \"value\": 24005\n  },\n  \"skipper.runtime.MemStats.HeapReleased\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.HeapSys\": {\n    \"value\": 5767168\n  },\n  \"skipper.runtime.MemStats.LastGC\": {\n    \"value\": 1516098381155094500\n  },\n  \"skipper.runtime.MemStats.Lookups\": {\n    \"value\": 2\n  },\n  \"skipper.runtime.MemStats.MCacheInuse\": {\n    \"value\": 6944\n  },\n  \"skipper.runtime.MemStats.MCacheSys\": {\n    \"value\": 16384\n  },\n  \"skipper.runtime.MemStats.MSpanInuse\": {\n    \"value\": 77368\n  },\n  \"skipper.runtime.MemStats.MSpanSys\": {\n    \"value\": 81920\n  },\n  \"skipper.runtime.MemStats.Mallocs\": {\n    \"value\": 1459\n  },\n  \"skipper.runtime.MemStats.NextGC\": {\n    \"value\": 4194304\n  },\n  \"skipper.runtime.MemStats.NumGC\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.MemStats.PauseTotalNs\": {\n    \"value\": 683352\n  },\n  \"skipper.runtime.MemStats.StackInuse\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.StackSys\": {\n    \"value\": 524288\n  },\n  \"skipper.runtime.MemStats.Sys\": {\n    \"value\": 9246968\n  },\n  \"skipper.runtime.MemStats.TotalAlloc\": {\n    \"value\": 35127624\n  },\n  \"skipper.runtime.NumCgoCall\": {\n    \"value\": 0\n  },\n  \"skipper.runtime.NumGoroutine\": {\n    \"value\": 11\n  },\n  \"skipper.runtime.NumThread\": {\n    \"value\": 9\n  }\n},\n\"histograms\": {\n  \"skipper.runtime.MemStats.PauseNs\": {\n    \"75%\": 82509.25,\n    \"95%\": 132609,\n    \"99%\": 132609,\n    \"99.9%\": 132609,\n    \"count\": 12,\n    \"max\": 132609,\n    \"mean\": 56946,\n    \"median\": 39302.5,\n    \"min\": 28749,\n    \"stddev\": 31567.015005117817\n  }\n}\n</code></pre>"},{"location":"operation/operation/#go-metrics-prometheus","title":"Go metrics - Prometheus","text":"<pre><code># HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.7279e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.9291e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 7.4e-05\ngo_gc_duration_seconds{quantile=\"0.75\"} 9.55e-05\ngo_gc_duration_seconds{quantile=\"1\"} 0.000199667\ngo_gc_duration_seconds_sum 0.001108339\ngo_gc_duration_seconds_count 13\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 13\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.21.3\"} 1\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 6.4856e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 4.1797384e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.462151e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 507460\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 4.549296e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 6.4856e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 7.421952e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 8.372224e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 70159\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 6.47168e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.5794176e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6987664839728708e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 577619\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 19200\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 31200\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 302904\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 309624\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 8.206808e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 2.402169e+06\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 983040\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 983040\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.5531656e+07\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 22\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 0.42\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 60000\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 10\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.2811392e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.69876646736e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 2.823462912e+09\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n</code></pre>"},{"location":"operation/operation/#redis-rate-limiting-metrics","title":"Redis - Rate limiting metrics","text":"<p>System metrics exposed by the redisclient:</p> <ul> <li>skipper.swarm.redis.shards: known Redis shards to the skipper ringclient</li> <li>skipper.swarm.redis.hits: number of times free connection was found in the pool</li> <li>skipper.swarm.redis.misses: number of times free connection was NOT found in the pool</li> <li>skipper.swarm.redis.timeouts: number of times a wait timeout occurred</li> <li>skipper.swarm.redis.staleconns: number of stale connections removed from the pool</li> <li>skipper.swarm.redis.idleconns: number of idle connections in the pool</li> <li>skipper.swarm.redis.totalconns: number of total connections in the pool</li> </ul> <p>Timer metrics for the latencies and errors of the communication with the auxiliary Redis instances are enabled by the default, and exposed among the timers via the following keys:</p> <ul> <li>skipper.swarm.redis.query.allow.success: successful allow requests to the rate limiter, ungrouped</li> <li>skipper.swarm.redis.query.allow.failure: failed allow requests to the rate limiter, ungrouped, where the redis   communication failed</li> <li>skipper.swarm.redis.query.retryafter.success.: successful allow requests to the rate limiter, grouped   by the rate limiter group name when used <li>skipper.swarm.redis.query.retryafter.failure.: failed allow requests to the rate limiter, ungrouped,   where the redis communication failed, grouped by the rate limiter group name when used <p>See more details about rate limiting at Rate limiting.</p>"},{"location":"operation/operation/#open-policy-agent-metrics","title":"Open Policy Agent metrics","text":"<p>If Open Policy Agent filters are enabled, the following counters show up in the <code>/metrics</code> endpoint. The bundle-name is the first parameter of the filter so that for example increased error codes can be attributed to a specific source bundle / system.</p> <ul> <li><code>skipper.opaAuthorizeRequest.custom.decision.allow.&lt;bundle-name&gt;</code></li> <li><code>skipper.opaAuthorizeRequest.custom.decision.deny.&lt;bundle-name&gt;</code></li> <li><code>skipper.opaAuthorizeRequest.custom.decision.err.&lt;bundle-name&gt;</code></li> <li><code>skipper.opaServeResponse.custom.decision.allow.&lt;bundle-name&gt;</code></li> <li><code>skipper.opaServeResponse.custom.decision.deny.&lt;bundle-name&gt;</code></li> <li><code>skipper.opaServeResponse.custom.decision.err.&lt;bundle-name&gt;</code></li> </ul> <p>The following timer metrics are exposed per used bundle-name:</p> <ul> <li><code>skipper.opaAuthorizeRequest.custom.eval_time.&lt;bundle-name&gt;</code></li> <li><code>skipper.opaServeResponse.custom.eval_time.&lt;bundle-name&gt;</code></li> </ul> <p>Open Policy Agent native Prometheus metrics are passed through if the metrics backend is set to Prometheus (via <code>--metrics-flavour</code>). </p> <p>The OPA native metrics are prefixed with <code>skipper_openpolicyagent_</code>, e.g. <code>skipper_openpolicyagent_plugin_status_gauge</code> will be exposed via Skipper\u2019s <code>/metrics</code> endpoint. Two extra labels are added to all metrics: <code>opa_instance_name</code> (set to the bundle name parameter of the filters) and <code>opa_instance_id</code> (a random ID that identifies the virtual OPA instance).</p>"},{"location":"operation/operation/#routesrv-metrics","title":"RouteSRV metrics","text":"<p>RouteSRV metrics expose the following metrics in Prometheus format:</p> <pre><code>% curl http://127.0.0.1:9911/metrics\n# 8&lt; Go metrics &gt;8\n\n# HELP routesrv_backend_combined_duration_seconds Duration in seconds of a proxy backend combined.\n# TYPE routesrv_backend_combined_duration_seconds histogram\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.005\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.01\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.025\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.05\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.1\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.25\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"0.5\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"1\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"2.5\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"5\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"10\"} 5\nroutesrv_backend_combined_duration_seconds_bucket{le=\"+Inf\"} 5\nroutesrv_backend_combined_duration_seconds_sum 0.001349441\nroutesrv_backend_combined_duration_seconds_count 5\n# HELP routesrv_backend_duration_seconds Duration in seconds of a proxy backend.\n# TYPE routesrv_backend_duration_seconds histogram\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.005\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.01\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.025\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.05\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.1\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.25\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"0.5\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"1\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"2.5\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"5\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"10\"} 5\nroutesrv_backend_duration_seconds_bucket{host=\"\",route=\"routersv\",le=\"+Inf\"} 5\nroutesrv_backend_duration_seconds_sum{host=\"\",route=\"routersv\"} 0.001349441\nroutesrv_backend_duration_seconds_count{host=\"\",route=\"routersv\"} 5\n# HELP routesrv_custom_gauges Gauges number of custom metrics.\n# TYPE routesrv_custom_gauges gauge\nroutesrv_custom_gauges{key=\"polling_started_timestamp\"} 1.69876646881321e+09\nroutesrv_custom_gauges{key=\"redis_endpoints\"} 1\nroutesrv_custom_gauges{key=\"routes.byte\"} 91378\nroutesrv_custom_gauges{key=\"routes.initialized_timestamp\"} 1.6987664689696188e+09\nroutesrv_custom_gauges{key=\"routes.total\"} 258\nroutesrv_custom_gauges{key=\"routes.updated_timestamp\"} 1.698766468969631e+09\n# HELP routesrv_custom_total Total number of custom metrics.\n# TYPE routesrv_custom_total counter\nroutesrv_custom_total{key=\"200\"} 5\n</code></pre> <p>Metrics explanation:</p> <ul> <li><code>routesrv_custom_total{key=\"200\"} 5</code>:   5 requests were responded with status code 200 by the current routesrv   version <code>v0.18.38</code>.</li> <li><code>routesrv_custom_gauges{key=\"polling_started_timestamp\"} 1.69876646881321e+09</code>:   routesrv started to poll at 1.69876646881321e+09 seconds of UNIX beginning   (2023-10-31 16:34:28 1705425/2097152 +0100).</li> <li><code>routesrv_custom_gauges{key=\"redis_endpoints\"} 1</code>:   The routes endpoint <code>/swarm/redis/shards</code> was called 1 times</li> <li><code>routesrv_custom_gauges{key=\"routes.byte\"} 91378</code>:   The number of bytes that are served at <code>/routes</code> is 91378.</li> <li><code>routesrv_custom_gauges{key=\"routes.initialized_timestamp\"} 1.6987664689696188e+09</code>:   routesrv initialized the routes at 1.6987664689696188e+09 seconds of UNIX beginning.   (2023-10-31 16:34:28 1016719/1048576 +0100)</li> <li><code>routesrv_custom_gauges{key=\"routes.total\"} 258</code>:   The number of routes that are served at <code>/routes</code> are 258.</li> <li><code>routesrv_custom_gauges{key=\"routes.updated_timestamp\"} 1.698766468969631e+09</code>:   The last update of routes by routesrv was at 1.698766468969631e+09.   (2023-10-31 16:34:28 4066927/4194304 +0100)</li> </ul> <p>If you want to read more about RouteSRV see deploy RouteSRV.</p>"},{"location":"operation/operation/#route-validation-metrics","title":"Route validation metrics","text":"<p>Skipper provides metrics to track the success and failure rates of route processing during configuration updates. These metrics help monitor the health of route definitions and identify common configuration issues.</p>"},{"location":"operation/operation/#gauge-metrics","title":"Gauge metrics","text":"<p>The following gauge metrics show individual invalid routes with detailed context:</p> <ul> <li><code>skipper_route_invalid{route_id=\"&lt;id&gt;\", reason=\"&lt;reason&gt;\"}</code>: Individual invalid route (1 = invalid, 0 = was invalid but now valid)</li> <li><code>routes.total</code>: Total number of valid routes currently loaded (available as   <code>routesrv_custom_gauges{key=\"routes.total\"}</code> in RouteSRV)</li> </ul> <p>Each invalid route gets its own metric with the route ID and failure reason as labels. When a route becomes valid, its metric is automatically set to 0 (rather than deleted) to maintain time series continuity. This provides detailed tracking of exactly which routes are invalid and why, while preserving historical data for trend analysis.</p>"},{"location":"operation/operation/#failure-reasons","title":"Failure reasons","text":"<p>The metrics track different types of route validation failures:</p> <ul> <li><code>unknown_filter</code>: Route uses a filter that is not registered or available</li> <li><code>invalid_filter_params</code>: Route has a filter with invalid parameters</li> <li><code>unknown_predicate</code>: Route uses a predicate that is not registered or available</li> <li><code>invalid_predicate_params</code>: Route has a predicate with invalid parameters</li> <li><code>failed_backend_split</code>: Route has an invalid backend URL or configuration</li> <li><code>other</code>: Route has other unclassified validation errors</li> </ul>"},{"location":"operation/operation/#prometheus-example","title":"Prometheus example","text":"<pre><code># HELP skipper_route_invalid Invalid route by route ID.\n# TYPE skipper_route_invalid gauge\nskipper_route_invalid{reason=\"unknown_filter\",route_id=\"api_route_1\"} 1\nskipper_route_invalid{reason=\"unknown_filter\",route_id=\"web_route_2\"} 1\nskipper_route_invalid{reason=\"unknown_filter\",route_id=\"mobile_api\"} 1\nskipper_route_invalid{reason=\"invalid_filter_params\",route_id=\"bad_params_route\"} 1\nskipper_route_invalid{reason=\"failed_backend_split\",route_id=\"broken_backend_1\"} 1\nskipper_route_invalid{reason=\"failed_backend_split\",route_id=\"broken_backend_2\"} 1\n\n# Routes that were invalid but are now fixed (set to 0 for historical tracking)\nskipper_route_invalid{reason=\"unknown_filter\",route_id=\"fixed_route_1\"} 0\nskipper_route_invalid{reason=\"failed_backend_split\",route_id=\"fixed_route_2\"} 0\n\n# HELP skipper_custom_gauges Gauges number of custom metrics.\n# TYPE skipper_custom_gauges gauge\nskipper_custom_gauges{key=\"routes.total\"} 1250\n</code></pre>"},{"location":"operation/operation/#codahale-example","title":"Codahale example","text":"<pre><code>{\n  \"gauges\": {\n    \"route.invalid.api_route_1.unknown_filter\": {\n      \"value\": 1\n    },\n    \"route.invalid.web_route_2.unknown_filter\": {\n      \"value\": 1\n    },\n    \"route.invalid.mobile_api.unknown_filter\": {\n      \"value\": 1\n    },\n    \"route.invalid.bad_params_route.invalid_filter_params\": {\n      \"value\": 1\n    },\n    \"route.invalid.broken_backend_1.failed_backend_split\": {\n      \"value\": 1\n    },\n    \"route.invalid.broken_backend_2.failed_backend_split\": {\n      \"value\": 1\n    },\n    \"route.invalid.fixed_route_1.unknown_filter\": {\n      \"value\": 0\n    },\n    \"route.invalid.fixed_route_2.failed_backend_split\": {\n      \"value\": 0\n    }\n  }\n}\n</code></pre> <p>These metrics are particularly useful for:</p> <ul> <li>Monitoring configuration deployment health for individual routes</li> <li>Identifying specific routes with configuration errors</li> <li>Alerting on individual route configuration issues</li> <li>Tracking which exact routes fail during updates</li> <li>Debugging route-specific problems with detailed context</li> <li>Historical analysis of route stability (metrics set to 0 when fixed, preserving time series)</li> <li>Trend analysis over your retention period (e.g., 30 days)</li> </ul>"},{"location":"operation/operation/#opentracing","title":"OpenTracing","text":"<p>Skipper has support for different OpenTracing API vendors, including jaeger, lightstep and instana.</p> <p>You can configure tracing implementations with a flag and pass information and tags to the tracer:</p> <pre><code>-opentracing=&lt;vendor&gt; component-name=skipper-ingress ... tag=cluster=mycluster ...\n</code></pre> <p>The best tested tracer is the lightstep tracer, because we use it in our setup. In case you miss something for your chosen tracer, please open an issue or pull request in our repository.</p>"},{"location":"operation/operation/#opentelemetry","title":"OpenTelemetry","text":"<p>Skipper supports OpenTelemetry tracing using standard environment variables and the <code>-open-telemetry</code> flag.</p> <p>To enable and configure OpenTelemetry using environment variables set <code>-open-telemetry</code> to an empty YAML object:</p> <pre><code>OTEL_TRACES_EXPORTER=\"otlp\" \\\nOTEL_EXPORTER_OTLP_PROTOCOL=\"grpc\" \\\nOTEL_EXPORTER_OTLP_ENDPOINT=\"https://telemetry-otlp-endpoint.test:4317\" \\\nOTEL_EXPORTER_OTLP_HEADERS=\"telemetry-token=telemetry-token-value\" \\\nOTEL_RESOURCE_ATTRIBUTES=\"service.name=skipper-ingress,cluster=production\" \\\nOTEL_PROPAGATORS=\"tracecontext,ottrace,b3multi,baggage\" \\\nOTEL_BSP_SCHEDULE_DELAY=\"5s\" \\\nOTEL_BSP_EXPORT_TIMEOUT=\"30s\" \\\nOTEL_BSP_MAX_QUEUE_SIZE=\"2048\" \\\nOTEL_BSP_MAX_EXPORT_BATCH_SIZE=\"512\" \\\nskipper -open-telemetry={}\n</code></pre> <p>To enable and  configure OpenTelemetry using the <code>-open-telemetry</code> flag, provide a YAML configuration as the value:</p> <pre><code>skipper -open-telemetry='\ntracesExporter: otlp\nexporterOtlp:\n  protocol: grpc\n  endpoint: \"https://telemetry-otlp-endpoint.test:4317\"\n  headers:\n    telemetry-token: \"telemetry-token-value\"\nresourceAttributes:\n  service.name: skipper-ingress\n  cluster: production\npropagators: [tracecontext, ottrace, b3multi, baggage]\nbatchSpanProcessor:\n  scheduleDelay: 5s\n  exportTimeout: 30s\n  maxQueueSize: 2048\n  maxExportBatchSize: 512\n'\n</code></pre> <p>Skipper creates up to 5 different spans: </p> <p>Some Tag details are added to all spans. </p>"},{"location":"operation/operation/#ingress-span","title":"Ingress span","text":"<p>The Ingress span is active from getting the request in Skipper\u2019s main http handler, until we served the response to the client of the request.</p> <p>Tags:</p> <ul> <li>component: skipper</li> <li>hostname: ip-10-149-64-142</li> <li>http.host: hostname.example.org</li> <li>http.method: GET</li> <li>http.path: /</li> <li>http.remote_addr: 10.149.66.207:14574</li> <li>http.url: /</li> <li>span.kind: server</li> </ul> <p></p>"},{"location":"operation/operation/#proxy-span","title":"Proxy span","text":"<p>The Proxy span starts just before executing the backend call.</p> <p>Tags:</p> <ul> <li>component: skipper</li> <li>hostname: ip-10-149-65-70</li> <li>http.host: hostname.example.org</li> <li>http.method: GET</li> <li>http.path: /</li> <li>http.remote_addr:</li> <li>http.status_code: 200</li> <li>http.url: http://10.2.0.11:9090/</li> <li>skipper.route_id: <code>kube_default__example_ingress_hostname_example_org____example_backend</code></li> <li>span.kind: client</li> </ul> <p></p> <p>Proxy span has logs to measure connect (<code>dial_context</code>), http roundtrip (<code>http_roundtrip</code>), stream headers from backend to client (<code>stream_Headers</code>), stream body from backend to client (<code>streamBody.byte</code>) and events by the Go runtime.</p> <p></p> <p>In addition to the manual instrumented proxy client logs, we use <code>net/http/httptrace.ClientTrace</code> to show events by the Go runtime. Full logs of the Proxy span:</p> <ul> <li><code>http_roundtrip: \"start\"</code>: just before http roundtrip</li> <li><code>http_roundtrip: \"end\"</code>: just after http roundtrip</li> <li><code>get_conn: \"start\"</code>: try to get a connection from the connection pool httptrace.ClientTrace</li> <li><code>get_conn: \"end\"</code>: got a connection from the connection pool httptrace.ClientTrace</li> <li><code>DNS: \"start\"</code>: try to resolve DNS httptrace.ClientTrace</li> <li><code>DNS: \"end\"</code>: got an IP httptrace.ClientTrace</li> <li><code>TLS: \"start\"</code>: start TLS connection httptrace.ClientTrace</li> <li><code>TLS: \"end\"</code>: established TLS connection httptrace.ClientTrace</li> <li><code>connect: \"start\"</code>: start to establish TCP/IP connection httptrace.ClientTrace</li> <li><code>connect: \"end\"</code>: established TCP/IP connection httptrace.ClientTrace</li> <li><code>wrote_headers: \"done\"</code>: wrote HTTP Headers into the socket httptrace.ClientTrace</li> <li><code>wrote_request: \"done\"</code>: wrote full HTTP Request into the socket httptrace.ClientTrace</li> <li><code>got_first_byte: \"done\"</code>: Got first byte of the HTTP response from   the backend httptrace.ClientTrace</li> </ul> <p></p>"},{"location":"operation/operation/#request-filters-span","title":"Request filters span","text":"<p>The request filters span logs show <code>start</code> and <code>end</code> events for each filter applied.</p> <p></p>"},{"location":"operation/operation/#response-filters-span","title":"Response filters span","text":"<p>The response filters span logs show <code>start</code> and <code>end</code> events for each filter applied.</p> <p></p> <p>Request and response filters event logging can be disabled by setting the <code>-opentracing-log-filter-lifecycle-events=false</code> flag and span creation can be disabled altogether by the <code>-opentracing-disable-filter-spans</code> flag.</p>"},{"location":"operation/operation/#auth-filters-span","title":"Auth filters span","text":"<p>Auth filters are special, because they might call an authorization endpoint, which should be also visible in the trace. This span can have the name \u201ctokeninfo\u201d, \u201ctokenintrospection\u201d or \u201cwebhook\u201d depending on the filter used by the matched route.</p> <p>Tags: - http.url: https://auth.example.org</p> <p>The auth filters have trace log values <code>start</code> and <code>end</code> for DNS, TCP connect, TLS handshake and connection pool:</p> <p></p>"},{"location":"operation/operation/#open-policy-agent-span","title":"Open Policy Agent span","text":"<p>When one of the Open Policy Agent filters is used, child spans with the operation name <code>open-policy-agent</code> are added to the Trace.</p> <p>The following tags are added to the Span, labels are taken from the OPA configuration YAML file as is and are not interpreted: - <code>opa.decision_id=&lt;decision id that was recorded&gt;</code> - <code>opa.labels.&lt;label1&gt;=&lt;value1&gt;</code></p> <p>The labels can for example be used to link to a specific decision in the control plane if they contain URL fragments for the receiving entity.</p>"},{"location":"operation/operation/#redis-rate-limiting-spans","title":"Redis rate limiting spans","text":""},{"location":"operation/operation/#operation-redis_allow_check_card","title":"Operation: redis_allow_check_card","text":"<p>Operation executed when the cluster rate limiting relies on the auxiliary Redis instances, and the Allow method checks if the rate exceeds the configured limit.</p>"},{"location":"operation/operation/#operation-redis_allow_add_card","title":"Operation: redis_allow_add_card","text":"<p>Operation setting the counter of the measured request rate for cluster rate limiting with auxiliary Redis instances.</p>"},{"location":"operation/operation/#operation-redis_oldest_score","title":"Operation: redis_oldest_score","text":"<p>Operation querying the oldest request event for the rate limiting Retry-After header with cluster rate limiting when used with auxiliary Redis instances.</p>"},{"location":"operation/operation/#dataclient","title":"Dataclient","text":"<p>Dataclients poll some kind of data source for routes. To change the timeout for calls that polls a dataclient, which could be the Kubernetes API, use the following option:</p> <pre><code>-source-poll-timeout int\n    polling timeout of the routing data sources, in milliseconds (default 3000)\n</code></pre>"},{"location":"operation/operation/#routing-table-information","title":"Routing table information","text":"<p>Skipper allows you to get some runtime insights. You can get the current routing table from skipper with in the eskip file format:</p> <pre><code>curl localhost:9911/routes\n*\n-&gt; \"http://localhost:12345/\"\n</code></pre> <p>You also can get the number of routes <code>X-Count</code> and the UNIX timestamp of the last route table update <code>X-Timestamp</code>, using a HEAD request:</p> <pre><code>curl -I localhost:9911/routes\nHTTP/1.1 200 OK\nContent-Type: text/plain\nX-Count: 1\nX-Timestamp: 1517777628\nDate: Sun, 04 Feb 2018 20:54:31 GMT\n</code></pre> <p>The number of routes given is limited (1024 routes by default). In order to control this limits, there are two parameters: <code>limit</code> and <code>offset</code>. The <code>limit</code> defines the number of routes to get and <code>offset</code> where to start the list. Thanks to this, it\u2019s possible to get the results paginated or getting all of them at the same time.</p> <pre><code>curl localhost:9911/routes?offset=200&amp;limit=100\n</code></pre>"},{"location":"operation/operation/#passive-health-check","title":"Passive Health Check","text":"<p>Skipper has an option to automatically detect and mitigate faulty backend endpoints, this feature is called Passive Health Check (PHC).</p> <p>PHC works the following way: the entire uptime is divided in chunks of <code>period</code>, per every period Skipper calculates the total amount of requests and amount of requests failed per every endpoint. While next period is going on, the Skipper takes a look at previous period and if the amount of requests in the previous period is more than <code>min-requests</code> and failed requests ratio is more than <code>min-drop-probability</code> for the given endpoints then Skipper will send reduced (the more <code>max-drop-probability</code> and failed requests ratio in previous period are, the stronger reduction is) amount of requests compared to amount sent without PHC. If the ratio of unhealthy endpoints is more than <code>max-unhealthy-endpoints-ratio</code> then PHC becomes fail-open. This effectively means if there are too many unhealthy endpoints PHC does not try to mitigate them any more and requests are sent like there is no PHC at all.</p> <p>Having this, we expect less requests to fail because a lot of them would be sent to endpoints that seem to be healthy instead.</p> <p>To enable this feature, you need to provide <code>-passive-health-check</code> option having forementioned parameters (<code>period</code>, <code>min-requests</code>, <code>min-drop-probability</code>, <code>max-drop-probability</code>, <code>max-unhealthy-endpoints-ratio</code>) defined. <code>period</code>, <code>min-requests</code>, <code>max-drop-probability</code> are required parameters, it is not possible for PHC to be enabled without them explicitly defined by user. <code>min-drop-probability</code> is implicitly defined as <code>0.0</code> if not explicitly set by user. <code>max-unhealthy-endpoints-ratio</code> is defined as <code>1.0</code> if not explicitly set by user. Valid examples of <code>-passive-health-check</code> are:</p> <ul> <li><code>-passive-health-check=period=1s,min-requests=10,min-drop-probability=0.05,max-drop-probability=0.9,max-unhealthy-endpoints-ratio=0.3</code></li> <li><code>-passive-health-check=period=1s,min-requests=10,max-drop-probability=0.9,max-unhealthy-endpoints-ratio=0.3</code></li> <li><code>-passive-health-check=period=1s,min-requests=10,min-drop-probability=0.05,max-drop-probability=0.9</code></li> <li><code>-passive-health-check=period=1s,min-requests=10,max-drop-probability=0.9</code></li> </ul> <p>If <code>-passive-health-check</code> option is provided, but some required parameters are not defined, Skipper will not start. Skipper will run without this feature, if no <code>-passive-health-check</code> is provided at all.</p> <p>The parameters of <code>-passive-health-check</code> option are:</p> <ul> <li><code>period=&lt;duration&gt;</code> - the duration of stats reset period</li> <li><code>min-requests=&lt;int&gt;</code> - the minimum number of requests per <code>period</code> per backend endpoint required to activate PHC for this endpoint</li> <li><code>min-drop-probability=[0.0 &lt;= p &lt; max-drop-probability)</code> - the minimum possible probability of unhealthy endpoint being not considered while choosing the endpoint for the given request. The same value is in fact used as minimal failed requests ratio for PHC to be enabled for this endpoint</li> <li><code>max-drop-probability=(min-drop-probability &lt; p &lt;= 1.0]</code> - the maximum possible probability of unhealthy endpoint being not considered while choosing the endpoint for the given request</li> <li><code>max-unhealthy-endpoints-ratio=[0.0 &lt;= r &lt;= 1.0]</code> - the maximum ratio of unhealthy endpoints for PHC to try to mitigate ongoing requests</li> </ul>"},{"location":"operation/operation/#metrics","title":"Metrics","text":"<p>A set of metrics will be exposed to track passive health check:</p> <ul> <li><code>passive-health-check.endpoints.dropped</code>: Number of all endpoints dropped before load balancing a request, so after N requests and M endpoints are being dropped this counter would be N*M.</li> <li><code>passive-health-check.requests.passed</code>: Number of unique requests where PHC was able to avoid sending them to unhealthy endpoints.</li> </ul>"},{"location":"operation/operation/#memory-consumption","title":"Memory consumption","text":"<p>While Skipper is generally not memory bound, some features may require some attention and planning regarding the memory consumption.</p> <p>Potentially high memory consumers:</p> <ul> <li>Metrics</li> <li>Filters</li> <li>Slow Backends and chatty clients</li> </ul> <p>Make sure you monitor backend latency, request and error rates. Additionally use Go metrics for the number of goroutines and threads, GC pause times should be less than 1ms in general, route lookup time, request and response filter times and heap memory.</p>"},{"location":"operation/operation/#metrics_1","title":"Metrics","text":"<p>Memory consumption of metrics are dependent on enabled command line flags. Make sure to monitor Go metrics.</p> <p>If you use <code>-metrics-flavour=codahale,prometheus</code> you enable both storage backends.</p> <p>If you use the Prometheus histogram buckets <code>-histogram-metric-buckets</code>.</p> <p>If you enable route based <code>-route-backend-metrics</code> <code>-route-response-metrics</code> <code>-serve-route-metrics</code>, error codes <code>-route-response-metrics</code> and host <code>-serve-host-metrics</code> based metrics it can count up. Please check the support listener endpoint (default 9911) to understand the usage:</p> <pre><code>% curl localhost:9911/metrics\n</code></pre> <p>By default, the route and host metrics include the labels for the request HTTP response status code and the HTTP method. You can customize it by setting <code>-serve-method-metric=false</code> and/or <code>-serve-status-code-metric=false</code>. These two flags will enable or disable the method and status code labels from your metrics reducing the number of metrics generated and memory consumption.</p>"},{"location":"operation/operation/#filters","title":"Filters","text":"<p>Ratelimit filter <code>clusterClientRatelimit</code> implementation using the swim based protocol, consumes roughly 15MB per filter for 100.000 individual clients and 10 maximum hits. Make sure you monitor Go metrics. Ratelimit filter <code>clusterClientRatelimit</code> implementation using the Redis ring based solution, adds 2 additional roundtrips to redis per hit. Make sure you monitor redis closely, because skipper will fall back to allow traffic if redis cannot be reached.</p>"},{"location":"operation/operation/#slow-backends","title":"Slow Backends","text":"<p>Skipper has to keep track of all active connections and http Requests. Slow Backends can pile up in number of connections, that will consume each a little memory per request. If you have high traffic per instance and a backend times out it can start to increase your memory consumption. Make sure you monitor backend latency, request and error rates.</p>"},{"location":"operation/operation/#default-filters","title":"Default Filters","text":"<p>Default filters will be applied to all routes created or updated.</p>"},{"location":"operation/operation/#global-default-filters","title":"Global Default Filters","text":"<p>Global default filters can be specified via two different command line flags <code>-default-filters-prepend</code> and <code>-default-filters-append</code>. Filters passed to these command line flags will be applied to all routes. The difference <code>prepend</code> and <code>append</code> is where in the filter chain these default filters are applied.</p> <p>For example a user specified the route: <code>r: * -&gt; setPath(\"/foo\")</code> If you run skipper with <code>-default-filters-prepend=enableAccessLog(4,5) -&gt; lifo(100,100,\"10s\")</code>, the actual route will look like this: <code>r: * -&gt; enableAccessLog(4,5) -&gt; lifo(100,100,\"10s\") -&gt; setPath(\"/foo\")</code>. If you run skipper with <code>-default-filters-append=enableAccessLog(4,5) -&gt; lifo(100,100,\"10s\")</code>, the actual route will look like this: <code>r: *  -&gt; setPath(\"/foo\") -&gt; enableAccessLog(4,5) -&gt; lifo(100,100,\"10s\")</code>.</p>"},{"location":"operation/operation/#kubernetes-default-filters","title":"Kubernetes Default Filters","text":"<p>Kubernetes dataclient supports default filters. You can enable this feature by specifying <code>default-filters-dir</code>. The defined directory must contain per-service filter configurations, with file name following the pattern <code>${service}.${namespace}</code>. The content of the files is the actual filter configurations. These filters are then prepended to the filters already defined in Ingresses.</p> <p>The default filters are supposed to be used only if the filters of the same kind are not configured on the Ingress resource. Otherwise, it can and will lead to potentially contradicting filter configurations and race conditions, i.e. you should specify a specific filter either on the Ingress resource or as a default filter.</p>"},{"location":"operation/operation/#scheduler","title":"Scheduler","text":"<p>HTTP request schedulers change the queuing behavior of in-flight requests. A queue has two generic properties: a limit of requests and a concurrency level.  The limit of request can be unlimited (unbounded queue), or limited (bounded queue).  The concurrency level is either limited or unlimited.</p> <p>The default scheduler is an unbounded first in first out (FIFO) queue, that is provided by Go\u2019s standard library.</p> <p>In skipper we have two queues that are part of the scheduling decision:</p> <ol> <li>TCP accept() handler LIFO</li> <li>Filters: <code>fifo()</code>, <code>lifo()</code> and <code>lifoGroup()</code></li> </ol> <p></p>"},{"location":"operation/operation/#the-problem","title":"The Problem","text":"<p>Why should you use boundaries to limit concurrency level and limit the queue?</p> <p>The short answer is resiliency. If you have one route, that is timing out, the request queue of skipper will pile up and consume much more memory, than before. This can lead to out of memory kill, which will affect all other routes. In this Go issue you can see the memory spike if you can trigger to spike in connections. An internal load test with different latency conditions showed usage increased in Go\u2019s standard library <code>bufio</code> package in recorded profiles.</p> <p>Why LIFO queue instead of FIFO queue?</p> <p>In normal cases the queue should not contain many requests. Skipper is able to process many requests concurrently without letting the queue piling up. In overrun situations you might want to process at least some fraction of requests instead of timing out all requests. LIFO would not time out all requests within the queue, if the backend is capable of responding some requests fast enough.</p>"},{"location":"operation/operation/#solution-tcp-accept-handler","title":"Solution - TCP Accept Handler","text":"<p>Our Go package queuelistener provides the functionality to limit the number of accepted connections and goroutines that work on HTTP requests. This will protect the skipper process from out of memory kill (OOM), if you run the process within cgroup v1 or v2 with memory limits. This is true if you run it in Kubernetes. The queuelistener implements a LIFO queue between accepting connections and working on HTTP requests.</p> <p>Options to change the behavior:</p> <pre><code>-enable-tcp-queue\n-expected-bytes-per-request=\n-max-tcp-listener-concurrency=\n-max-tcp-listener-queue=\n</code></pre>"},{"location":"operation/operation/#solution-filters","title":"Solution - Filters","text":"<p>Skipper provides 2 last in first out (LIFO) filters and 1 first in first out filter (FIFO) to change the scheduling behavior for a route.</p> <p>On failure conditions, Skipper will return HTTP status code:</p> <ul> <li>503 if the queue is full, which is expected on the route with a failing backend</li> <li>502 if queue access times out, because the queue access was not fast enough</li> <li>500 on unknown errors, please create an issue</li> </ul> <p>Skipper has two filters <code>lifo()</code> and <code>lifoGroup()</code> and one <code>fifo()</code> filter, that can limit the number of requests for a route.  A documented load test shows the behavior with an enabled <code>lifo(100,100,\"10s\")</code> filter for all routes, that was added by default. You can do this, if you pass the following flag to skipper: <code>-default-filters-prepend=lifo(100,100,\"10s\")</code>.</p> <p>Both LIFO filters will, use a last in first out queue to handle most requests fast. If skipper is in an overrun mode, it will serve some requests fast and some will timeout. The idea is based on Dropbox bandaid proxy, which is not opensource. Dropbox shared their idea in a public blogpost.</p> <p>Skipper\u2019s scheduler implementation makes sure, that one route will not interfere with other routes, if these routes are not in the same scheduler group. <code>LifoGroup</code> has a user chosen scheduler group and <code>lifo()</code> will get a per route unique scheduler group. We found out that the implementation of LIFO filters are showing lock contention on high traffic routes. In case you fear this behavior we recommend to use the FIFO filter that only use a semaphore to reduce lock contention. The <code>fifo()</code> is working similar to the <code>lifo()</code> filter.</p> <p>We recommend to isolate routes from each other by configuring a <code>fifo()</code> filter by <code>-default-filters-prepend=</code> to add it to every route.</p> <p>The following picture shows the isolation in action. You can see that routeA is suffering, by high active requests and the green dots that show the queuing of requests in routeA. On the other hand you can see routeB, routeC, routeD and routeE, that show normal behavior, so these do not have an impact. </p>"},{"location":"operation/operation/#uri-standards-interpretation","title":"URI standards interpretation","text":"<p>Considering the following request path: /foo%2Fbar, Skipper can handle it in two different ways. The current default way is that when the request is parsed purely relying on the Go stdlib url package, this path becomes /foo/bar. According to RFC 2616 and RFC 3986, this may be considered wrong, and this path should be parsed as /foo%2Fbar. This is possible to achieve centrally, when Skipper is started with the -rfc-patch-path flag. It is also possible to allow the default behavior and only force the alternative interpretation on a per-route basis with the rfcPath() filter. See <code>rfcPath()</code>.</p> <p>If the second interpretation gets considered the right way, and the other one a bug, then the default value for this flag may become to be on.</p>"},{"location":"operation/operation/#debugging-requests","title":"Debugging Requests","text":"<p>Skipper provides filters, that can change HTTP requests. You might want to inspect how the request was changed, during the route processing and check the request that would be made to the backend. Luckily with <code>-debug-listener=:9922</code>, Skipper can provide you this information.</p> <p>For example you have the following route:</p> <pre><code>kube_default__foo__foo_teapot_example_org_____foo: Host(/^foo[.]teapot[.]example[.]org$/) &amp;&amp; PathSubtree(\"/\")\n  -&gt; setRequestHeader(\"X-Foo\", \"hello-world\")\n  -&gt; &lt;roundRobin, \"http://10.2.0.225:9090\", \"http://10.2.1.244:9090\"&gt;;\n</code></pre> <p>If you sent now a request to the debug listener, that will be matched by the route, Skipper will respond with information that show you the matched route, the incoming request, the transformed request and all predicates and filters involved in the route processing:</p> <pre><code>% curl -s http://127.0.0.1:9922/ -H\"Host: foo.teapot.example.org\" | jq .\n{\n  \"route_id\": \"kube_default__foo__foo_teapot_example_org_____foo\",\n  \"route\": \"Host(/^foo[.]teapot[.]example[.]org$/) &amp;&amp; PathSubtree(\\\"/\\\") -&gt; setRequestHeader(\\\"X-Foo\\\", \\\"hello-world\\\") -&gt; &lt;roundRobin, \\\"http://10.2.0.225:9090\\\", \\\"http://10.2.1.244:9090\\\"&gt;\",\n  \"incoming\": {\n    \"method\": \"GET\",\n    \"uri\": \"/\",\n    \"proto\": \"HTTP/1.1\",\n    \"header\": {\n      \"Accept\": [\n        \"*/*\"\n      ],\n      \"User-Agent\": [\n        \"curl/7.49.0\"\n      ]\n    },\n    \"host\": \"foo.teapot.example.org\",\n    \"remote_address\": \"127.0.0.1:32992\"\n  },\n  \"outgoing\": {\n    \"method\": \"GET\",\n    \"uri\": \"\",\n    \"proto\": \"HTTP/1.1\",\n    \"header\": {\n      \"Accept\": [\n        \"*/*\"\n      ],\n      \"User-Agent\": [\n        \"curl/7.49.0\"\n      ],\n      \"X-Foo\": [\n        \"hello-world\"\n      ]\n    },\n    \"host\": \"foo.teapot.example.org\"\n  },\n  \"response_mod\": {\n    \"header\": {\n      \"Server\": [\n        \"Skipper\"\n      ]\n    }\n  },\n  \"filters\": [\n    {\n      \"name\": \"setRequestHeader\",\n      \"args\": [\n        \"X-Foo\",\n        \"hello-world\"\n      ]\n    }\n  ],\n  \"predicates\": [\n    {\n      \"name\": \"PathSubtree\",\n      \"args\": [\n        \"/\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"operation/operation/#profiling","title":"Profiling","text":"<p>Go profiling is explained in Go\u2019s diagnostics documentation.</p>"},{"location":"operation/operation/#profiling-skipper-or-routesrv","title":"Profiling skipper or RouteSRV","text":"<p>To enable profiling in skipper you have to use <code>-enable-profile</code>. This will start a profiling route at <code>/debug/pprof/profile</code> on the support listener, which defaults to <code>:9911</code>.</p>"},{"location":"operation/operation/#profiling-example","title":"Profiling example","text":"<p>Start skipper with enabled profiling:</p> <pre><code>skipper -inline-routes='r1: * -&gt; inlineContent(\"hello\") -&gt; &lt;shunt&gt;' -enable-profile\n</code></pre> <p>Use Go tool pprof to download profiling sample to analyze (sample is not from the example):</p> <pre><code>% go tool pprof http://127.0.0.1:9911\nFetching profile over HTTP from http://127.0.0.1:9911/debug/pprof/profile\nSaved profile in /$HOME/pprof/pprof.skipper.samples.cpu.004.pb.gz\nFile: skipper\nBuild ID: 272c31a7bd60c9fabb637bdada37a3331a919b01\nType: cpu\nTime: Oct 7, 2020 at 6:17pm (CEST)\nDuration: 30s, Total samples = 0\nNo samples were found with the default sample value type.\nTry \"sample_index\" command to analyze different sample values.\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\n(pprof) top\nShowing nodes accounting for 2140ms, 50.00% of 4280ms total\nDropped 330 nodes (cum &lt;= 21.40ms)\nShowing top 10 nodes out of 303\n      flat  flat%   sum%        cum   cum%\n     560ms 13.08% 13.08%      640ms 14.95%  syscall.Syscall\n     420ms  9.81% 22.90%      430ms 10.05%  runtime.nanotime\n     410ms  9.58% 32.48%      410ms  9.58%  runtime.futex\n     170ms  3.97% 36.45%      450ms 10.51%  runtime.mallocgc\n     170ms  3.97% 40.42%      180ms  4.21%  runtime.walltime\n     160ms  3.74% 44.16%      220ms  5.14%  runtime.scanobject\n      80ms  1.87% 46.03%       80ms  1.87%  runtime.heapBitsSetType\n      70ms  1.64% 47.66%       70ms  1.64%  runtime.epollwait\n      50ms  1.17% 48.83%      120ms  2.80%  compress/flate.(*compressor).deflate\n      50ms  1.17% 50.00%       50ms  1.17%  encoding/json.stateInString\n(pprof) web\n--&gt; opens browser with SVG\n</code></pre> <p></p>"},{"location":"operation/operation/#response-serving","title":"Response serving","text":"<p>When serving a response from a backend, Skipper serves first the HTTP response headers. After that Skipper streams the response payload and uses one 8kB buffer to stream the data through this 8kB buffer. It uses Flush() to make sure the 8kB chunk is written to the client. Details can be observed by opentracing in the logs of the Proxy Span.</p>"},{"location":"operation/operation/#forwarded-headers","title":"Forwarded headers","text":"<p>Skipper can be configured to add <code>X-Forwarded-*</code> headers:</p> <pre><code>  -forwarded-headers value\n        comma separated list of headers to add to the incoming request before routing\n        X-Forwarded-For sets or appends with comma the remote IP of the request to the X-Forwarded-For header value\n        X-Forwarded-Host sets X-Forwarded-Host value to the request host\n        X-Forwarded-Port=&lt;port&gt; sets X-Forwarded-Port value, or set to auto to use the port of the listener\n        X-Forwarded-Proto=&lt;http|https|auto&gt; sets X-Forwarded-Proto value, or set to auto to use http or https depending on the listener tls state\n  -forwarded-headers-exclude-cidrs value\n        disables addition of forwarded headers for the remote host IPs from the comma separated list of CIDRs\n</code></pre>"},{"location":"operation/operation/#converting-routes","title":"Converting Routes","text":"<p>For migrations you need often to convert X to Y. This is also true in case you want to switch one predicate to another one or one filter to another one. In skipper we have <code>-edit-route</code> and <code>-clone-route</code> that either modifies matching routes or copy matching routes and change the copy.</p> <p>Example:</p> <p>A route with <code>edit-route</code> <pre><code>% skipper -inline-routes='Path(\"/foo\") -&gt; setResponseHeader(\"X-Foo\",\"bar\") -&gt; inlineContent(\"hi\") -&gt; &lt;shunt&gt;' \\\n-edit-route='/inlineContent[(][\"](.*)[\"][)]/inlineContent(\"modified \\\"$1\\\" response\")/'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] route settings, reset, route: : Path(\"/foo\") -&gt; setResponseHeader(\"X-Foo\", \"bar\") -&gt; inlineContent(\"hi\") -&gt; &lt;shunt&gt;\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n</code></pre></p> <p>Modified route: <pre><code>curl localhost:9911/routes\nPath(\"/foo\")\n  -&gt; setResponseHeader(\"X-Foo\", \"bar\")\n  -&gt; inlineContent(\"modified \\\"hi\\\" response\")\n  -&gt; &lt;shunt&gt;\n</code></pre></p> <p>Modified response body: <pre><code>% curl -v http://localhost:9090/foo\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET /foo HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Content-Length: 22\n&lt; Content-Type: text/plain; charset=utf-8\n&lt; Server: Skipper\n&lt; X-Foo: bar\n&lt; Date: Thu, 14 Oct 2021 08:41:53 GMT\n&lt;\n* Connection #0 to host localhost left intact\nmodified \"hi\" response\n</code></pre></p> <p>With <code>edit-route</code> and <code>-clone-route</code> you can modify Predicates and Filters to convert from <code>SourceFromLast()</code> to <code>ClientIP</code>, for example if you want to migrate AWS cloud load balancer from Application Load Balancer to Network Load Balancer, you can use <code>-clone-route='/SourceFromLast[(](.*)[)]/ClientIP($1)/'</code> to create additional routes for</p> <p><pre><code>r: SourceFromLast(\"9.0.0.0/8\",\"2001:67c:20a0::/48\") -&gt; ...`\n</code></pre> to change to <pre><code>r: SourceFromLast(\"9.0.0.0/8\",\"2001:67c:20a0::/48\") -&gt; ...`\nclone_r: ClientIP(\"9.0.0.0/8\",\"2001:67c:20a0::/48\") -&gt; ...`\n</code></pre> for migration time.</p> <p><code>/</code> symbol is not the only option for the separator for <code>-edit-route</code> and <code>-clone-route</code>, any first symbol you will specify in those options could be used as separator. This could be useful for IP mask changes, for example, you can use <code>-edit-route='#/26#/24#</code>. In this case <pre><code>r: SourceFromLast(\"9.0.0.0/26\",\"2001:67c:20a0::/48\") -&gt; ...`\n</code></pre> will be changed to <pre><code>r: SourceFromLast(\"9.0.0.0/24\",\"2001:67c:20a0::/48\") -&gt; ...`\n</code></pre></p>"},{"location":"reference/architecture/","title":"Architecture","text":"<p>Skipper is written as a library and is also a multi binary project with 2 binaries, named <code>skipper</code> and <code>eskip</code>. <code>Skipper</code> is the HTTP proxy and <code>eskip</code> is a CLI application to verify, print, update or delete Skipper routes.</p> <p>Skipper\u2019s internal architecture is split into different packages. The <code>skipper</code> package has connections to multiple <code>dataclient</code>, that pull information from different sources, for example static routes from an eskip file or dynamic routes from Kubernetes ingress objects.</p> <p>The <code>proxy</code> package gets the routes populated by skipper and has always a current routing table which will be replaced on change.</p> <p>A route is one entry in the routing table. A route consists of one or more <code>predicate</code>, that are used to find a route for a given HTTP request. A route can also have one or more <code>filter</code>, that can modify the content of the request or response.  A route can point to a backend, it can be a <code>&lt;shunt&gt;</code>, meaning that skipper serves the requests for the route, a <code>&lt;loopback&gt;</code>, meaning that the requests will be matched against the routing table again after filters have modified them, or a <code>&lt;dynamic&gt;</code>, meaning that the target url can be set dynamically  by a filter (e.g. setDynamicBackendUrl). </p> <p>Opentracing API is supported via skipper-plugins. For example Jaeger is supported.</p> <p>Skipper has a rich set of metrics that are exposed as json, but can be exported in Prometheus format.</p> <p></p>"},{"location":"reference/architecture/#route-processing","title":"Route processing","text":"<p>Package <code>skipper</code> has a Go <code>http.Server</code> and does the <code>ListenAndServe</code> call with the <code>loggingHandler</code> wrapped <code>proxy</code>.  The <code>loggingHandler</code> is basically a middleware for the <code>proxy</code> providing access logs and both implement the plain Go http.Handler interface.</p> <p>For each incoming <code>http.Request</code> the <code>proxy</code> will create a request context and enhance it with an Opentracing API Span. It will check proxy global ratelimits first and after that lookup the route in the routing table. After that skipper will apply all request filters, that can modify the <code>http.Request</code>. It will then check the route local ratelimits, the circuitbreakers and do the backend call. If the backend call got a TCP or TLS connection error in a loadbalanced route, skipper will do a retry to another backend of that loadbalanced group automatically. Just before the response to the caller, skipper will process the response filters, that can change the <code>http.Response</code>.</p> <p>In two special cases, skipper doesn\u2019t forward the request to the backend. When the route is shunted (<code>&lt;shunt&gt;</code>), skipper serves the request alone, by using only the filters. When the route is a <code>&lt;loopback&gt;</code>, the request is passed to the routing table for finding another route, based on the changes that the filters made to the request.</p> <p></p>"},{"location":"reference/architecture/#routing-mechanism","title":"Routing mechanism","text":"<p>The routing executes the following steps in the typical case:</p> <ol> <li> <p>Select the best fitting route by matching the request against the    predicates. When no route found, respond with 404 (unless the default    status code is configured to a different value).</p> </li> <li> <p>Execute the filters defined in the route in normal order on the    request. The filters may or may not alter the request.</p> </li> <li> <p>Forward the request to the backend defined by the route and receive    a response.</p> </li> <li> <p>Execute the filters defined in the route in reverse order on the    response. The filters may or may not alter the response.</p> </li> <li> <p>Respond to the incoming request with the resulting response.</p> </li> </ol>"},{"location":"reference/architecture/#route-matching","title":"Route matching","text":"<p>Skipper can handle a relatively large number of routes with acceptable performance, while being able to use any attribute of the incoming HTTP requests to distinguish between them. In order to be able to do so, the path matching predicates (<code>Path()</code> and <code>PathSubtree()</code> but not <code>PathRegexp()</code>) have a special role during route matching, which is a tradeoff by design, and needs to be kept in mind to understand in some cases why a certain route was matched for a request instead of another.</p> <p>The route matching logic can be summed up as follows:</p> <ol> <li> <p>Lookup in the path tree based on the <code>Path()</code> and the <code>PathSubtree()</code>    predicates, using the path component of the incoming request\u2019s URI. Then    the remaining predicates of the found route(s) are evaluated.</p> <ul> <li> <p>the path lookup is a radix tree with O(log(n)) time complexity</p> </li> <li> <p>in case of intersecting paths, the more specific path is matched in  the tree</p> </li> <li> <p><code>PathRegexp()</code> is not used in the tree, but it is evaluated only after  <code>Path()</code> or <code>PathSubtree()</code>, just like e.g. <code>Method()</code> or <code>Host()</code>.</p> </li> </ul> </li> <li> <p>If step #1 matches multiple routes, which means there are multiple    routes in the same position of the path tree, and all other predicates    match the request, too, then the route with the highest     weight is matched.</p> <ul> <li> <p>this is an O(n) lookup, but only on the same leaf</p> </li> <li> <p>the root of the tree is considered a single leaf, so if not using the   <code>Path()</code> or <code>PathSubtree()</code> predicates, the entire lookup will become O(n)   over all the routes.</p> </li> </ul> </li> <li> <p>If #2 results in multiple matching routes, then one route will be    selected. It is unspecified which one.</p> </li> </ol>"},{"location":"reference/backends/","title":"Backends","text":"<p>A backend is the last part of a route and will define the backend to call for a given request that match the route.</p> <p>Generic route example:</p> <pre><code>routeID: Predicate1 &amp;&amp; Predicate2 -&gt; filter1 -&gt; filter2 -&gt; &lt;backend&gt;;\n</code></pre>"},{"location":"reference/backends/#network-backend","title":"Network backend","text":"<p>A network backend is an arbitrary HTTP or HTTPS URL, that will be called by the proxy.</p> <p>Route example with a network backend <code>\"https://www.zalando.de/\"</code>: <pre><code>r0: Method(\"GET\")\n    -&gt; setRequestHeader(\"X-Passed-Skipper\", \"true\")\n    -&gt; \"https://www.zalando.de/\";\n</code></pre></p> <p>Proxy example with request in access log <pre><code>./bin/skipper -inline-routes 'r0: Method(\"GET\") -&gt; setRequestHeader(\"X-Passed-Skipper\", \"true\") -&gt; \"https://www.zalando.de/\";'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings, reset, route: r0: Method(\"GET\") -&gt; setRequestHeader(\"X-Passed-Skipper\", \"true\") -&gt; \"https://www.zalando.de/\"\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n\n::1 - - [05/Feb/2019:14:31:05 +0100] \"GET / HTTP/1.1\" 200 164408 \"-\" \"curl/7.49.0\" 457 localhost:9090 - -\n</code></pre></p> <p>Client example with request and response headers: <pre><code>$ curl -v localhost:9090 &gt;/dev/null\n* Rebuilt URL to: localhost:9090/\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Cache-Control: no-cache, no-store, must-revalidate\n&lt; Content-Type: text/html\n&lt; Date: Tue, 05 Feb 2019 13:31:38 GMT\n&lt; Link: &lt;https://mosaic01.ztat.net/base-assets/require-2.1.22.min.js&gt;; rel=\"preload\"; as=\"script\"; nopush; crossorigin\n&lt; Pragma: no-cache\n&lt; Server: Skipper\n&lt; Set-Cookie: ...; Path=/; Domain=zalando.de; Expires=Sun, 04 Aug 2019 13:31:38 GMT; Max-Age=15552000; HttpOnly; Secure\n&lt; Vary: Accept-Encoding\n&lt; Transfer-Encoding: chunked\n&lt;\n{ [3205 bytes data]\n</code></pre></p>"},{"location":"reference/backends/#shunt-backend","title":"Shunt backend","text":"<p>A shunt backend, <code>&lt;shunt&gt;</code>, will not call a backend, but reply directly from the proxy itself. This can be used to shortcut, for example have a default that replies with 404 or use skipper as a backend serving static content in demos.</p> <p>Route Example proxying to <code>\"https://www.zalando.de/\"</code> when Host header is set to <code>\"zalando\"</code> and rest will be served HTTP status code <code>404</code> with the body <code>\"no matching route\"</code>:</p> <pre><code>r0: Host(\"zalando\")\n    -&gt; \"https://www.zalando.de/\";\nrest: *\n      -&gt; status(404)\n      -&gt; inlineContent(\"no matching route\")\n      -&gt; &lt;shunt&gt;;\n</code></pre> <p>Proxy configured as defined above with access log showing 404: <pre><code>$ ./bin/skipper -inline-routes 'r0: Host(\"zalando\") -&gt; \"https://www.zalando.de/\"; rest: * -&gt; status(404) -&gt; inlineContent(\"no matching route\")  -&gt; \"http://localhost:9999/\";'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings, reset, route: r0: Host(/zalando/) -&gt; \"https://www.zalando.de/\"\n[APP]INFO[0000] route settings, reset, route: rest: * -&gt; status(404) -&gt; inlineContent(\"no matching route\") -&gt; \"http://localhost:9999/\"\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n::1 - - [05/Feb/2019:14:39:26 +0100] \"GET / HTTP/1.1\" 404 17 \"-\" \"curl/7.49.0\" 0 localhost:9090 - -\n</code></pre></p> <p>Client example with request and response headers: <pre><code>$ curl -sv localhost:9090\n* Rebuilt URL to: localhost:9090/\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 404 Not Found\n&lt; Content-Length: 17\n&lt; Content-Type: text/plain; charset=utf-8\n&lt; Server: Skipper\n&lt; Date: Tue, 05 Feb 2019 13:37:27 GMT\n&lt;\n* Connection #0 to host localhost left intact\nno matching route\n</code></pre></p>"},{"location":"reference/backends/#loopback-backend","title":"Loopback backend","text":"<p>The loopback backend, <code>&lt;loopback&gt;</code>, will lookup again the routing table to a better matching route after processing the current route. Like this you can add some headers or change the request path for some specific matching requests.</p> <p>Example:</p> <ul> <li>Route <code>r0</code> is a route with loopback backend that will be matched for requests with paths that start with <code>/api</code>. The route will modify the http request removing /api in the path of the incoming request. In the second step of the routing, the modified request will be matched by route <code>r1</code>.</li> <li>Route <code>r1</code> is a default route with a network backend to call <code>\"https://www.zalando.de/\"</code></li> </ul> <pre><code>r0: PathSubtree(\"/api\")\n    -&gt; modPath(\"^/api\", \"\")\n    -&gt; &lt;loopback&gt;;\nr1: * -&gt; \"https://www.zalando.de/\";\n</code></pre> <p>Proxy configured as defined above with access logs showing 404 for the first call and 200 for the second: <pre><code>$ ./bin/skipper -inline-routes 'r0: PathSubtree(\"/api\") -&gt; setRequestHeader(\"X-Passed-Skipper\", \"true\") -&gt; modPath(/^\\/api/, \"\") -&gt; &lt;loopback&gt;;\nr1: * -&gt; \"https://www.zalando.de/\";'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] route settings, reset, route: r0: PathSubtree(\"/api\") -&gt; setRequestHeader(\"X-Passed-Skipper\", \"true\") -&gt; modPath(\"^/api\", \"\") -&gt; &lt;loopback&gt;\n[APP]INFO[0000] route settings, reset, route: r1: * -&gt; \"https://www.zalando.de/\"\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n::1 - - [05/Feb/2019:14:54:14 +0100] \"GET /api/foo HTTP/1.1\" 404 98348 \"-\" \"curl/7.49.0\" 562 localhost:9090 - -\n::1 - - [05/Feb/2019:14:54:28 +0100] \"GET /api HTTP/1.1\" 200 164408 \"-\" \"curl/7.49.0\" 120 localhost:9090 - -\n</code></pre></p> <p>Client example with request and response headers: <pre><code>$ curl -sv localhost:9090/api/foo &gt;/dev/null\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET /api/foo HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 404 Not Found\n&lt; Content-Language: de-DE\n&lt; Content-Type: text/html;charset=UTF-8\n&lt; Date: Tue, 05 Feb 2019 14:00:33 GMT\n&lt; Transfer-Encoding: chunked\n&lt;\n{ [2669 bytes data]\n* Connection #0 to host localhost left intact\n\n\n$ curl -sv localhost:9090/api &gt;/dev/null\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET /api HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Cache-Control: no-cache, no-store, must-revalidate\n&lt; Content-Type: text/html\n&lt; Date: Tue, 05 Feb 2019 14:00:44 GMT\n&lt; Link: &lt;https://mosaic01.ztat.net/base-assets/require-2.1.22.min.js&gt;; rel=\"preload\"; as=\"script\"; nopush; crossorigin\n&lt; Transfer-Encoding: chunked\n&lt;\n{ [3491 bytes data]\n</code></pre></p> <p>If the request processing reaches the maximum number of loopbacks (by default max=9), the routing will result in an error.</p>"},{"location":"reference/backends/#dynamic-backend","title":"Dynamic backend","text":"<p>The dynamic backend, <code>&lt;dynamic&gt;</code>, will get the backend to call by data provided by filters.  This allows skipper as library users to do proxy calls to a certain target from their own implementation dynamically looked up by their filters.</p> <p>Example shows how to set a target by a provided filter, which would be similar to a network backend:</p> <pre><code>r0: * -&gt; setDynamicBackendUrl(\"https://www.zalando.de\") -&gt; &lt;dynamic&gt;;\n</code></pre> <p>Proxy configured as defined above with access logs showing 200 for the  call: <pre><code>$ ./bin/skipper -inline-routes 'r0: * -&gt; setDynamicBackendUrl(\"https://www.zalando.de\") -&gt; &lt;dynamic&gt;;'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings, reset, route: r0: * -&gt; setDynamicBackendUrl(\"https://www.zalando.de\") -&gt; &lt;dynamic&gt;\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n::1 - - [05/Feb/2019:15:09:34 +0100] \"GET / HTTP/1.1\" 200 164408 \"-\" \"curl/7.49.0\" 132 localhost:9090 - -\n</code></pre></p> <p>Client example with request and response headers: <pre><code>$ curl -sv localhost:9090/ &gt;/dev/null\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Cache-Control: no-cache, no-store, must-revalidate\n&lt; Content-Type: text/html\n&lt; Date: Tue, 05 Feb 2019 14:09:34 GMT\n&lt; Link: &lt;https://mosaic01.ztat.net/base-assets/require-2.1.22.min.js&gt;; rel=\"preload\"; as=\"script\"; nopush; crossorigin\n&lt; Pragma: no-cache\n&lt; Server: Skipper\n&lt; Transfer-Encoding: chunked\n&lt;\n{ [3491 bytes data]\n* Connection #0 to host localhost left intact\n</code></pre></p> <p>When no filters modifying the target are set (e.g. <code>r0: * -&gt; &lt;dynamic&gt;;</code>), the target host defaults to either the <code>Host</code> header or the host name given in the URL, and the target scheme defaults to either <code>https</code> when TLS is configured or <code>http</code> when TLS is not configured.</p>"},{"location":"reference/backends/#forward-backend","title":"Forward backend","text":"<p>The forward backend, <code>&lt;forward&gt;</code>, will set the backend to operators choice set by <code>-forward-backend-url</code>.  This can be useful for data plane migrations. In one case we want to switch from one Kubernetes cluster to another Kubernetes cluster, but both cluster data planes can reach each other. The route with the <code>&lt;forward&gt;</code> will get cleaned all filters so there is no duplicate filter execution. This is useful because old and new clusters will have the same routing objects, that apply a set of routes with filters. Filters, for example <code>modPath</code>, can create an unexpected change to requests and responses passing through a chain of proxies with duplicated routes.</p> <p>Example: <pre><code>old&gt; skipper -inline-routes='r: * -&gt; modPath(\"^/\", \"/foo/\") -&gt; &lt;forward&gt;' -address :9090 -forward-backend-url=http://127.0.0.1:9003\nnew&gt; skipper -inline-routes='r: * -&gt; modPath(\"^/\",\"/foo/\") -&gt; \"http://127.0.0.1:12345\"' -address :9003\n\n% nc -l 12345\nGET /foo/bar?q=a HTTP/1.1\nHost: 127.0.0.1:12345\nUser-Agent: curl/7.49.0\nAccept: */*\nAccept-Encoding: gzip\n\ncurl http://localhost:9090/bar\\?q\\=a -v\n*   Trying ::1...\n* Connected to localhost (::1) port 9090 (#0)\n&gt; GET /bar?q=a HTTP/1.1\n&gt; Host: localhost:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n</code></pre></p> <p>You can see our netcat (nc) backend observes <code>/foo/bar</code> as path and not <code>/foo/bar/bar</code>, if filters would be applied in the route with <code>&lt;forward&gt;</code>.</p>"},{"location":"reference/backends/#load-balancer-backend","title":"Load Balancer backend","text":"<p>The loadbalancer backend, <code>&lt;$algorithm, \"backend1\", \"backend2\"&gt;</code>, will balance the load across all given backends using the algorithm set in <code>$algorithm</code>. If <code>$algorithm</code> is not specified it will use the default algorithm set by Skipper at start.</p> <p>Current implemented algorithms:</p> <ul> <li><code>roundRobin</code>: backend is chosen by the round robin algorithm, starting with a random selected backend to spread across all backends from the beginning</li> <li><code>random</code>: backend is chosen at random</li> <li><code>consistentHash</code>: backend is chosen by consistent hashing algorithm based on the request key. The request key is derived from <code>X-Forwarded-For</code> header or request remote IP address as the fallback. Use <code>consistentHashKey</code> filter to set the request key. Use <code>consistentHashBalanceFactor</code> to prevent popular keys from overloading a single backend endpoint.</li> <li><code>powerOfRandomNChoices</code>: backend is chosen by powerOfRandomNChoices algorithm with selecting N random endpoints and picking the one with least outstanding requests from them. (http://www.eecs.harvard.edu/~michaelm/postscripts/handbook2001.pdf)</li> <li>TODO: https://github.com/zalando/skipper/issues/557</li> </ul> <p>Route example with 2 backends and the <code>roundRobin</code> algorithm: <pre><code>r0: * -&gt; &lt;roundRobin, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;\n</code></pre></p> <p>Route example with 2 backends and the <code>random</code> algorithm: <pre><code>r0: * -&gt; &lt;random, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;\n</code></pre></p> <p>Route example with 2 backends and the <code>consistentHash</code> algorithm: <pre><code>r0: * -&gt; &lt;consistentHash, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;\n</code></pre></p> <p>Route example with 2 backends and the <code>powerOfRandomNChoices</code> algorithm: <pre><code>r0: * -&gt; &lt;powerOfRandomNChoices, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;\n</code></pre></p> <p>Proxy with <code>roundRobin</code> loadbalancer and two backends: <pre><code>$ ./bin/skipper -inline-routes 'r0: *  -&gt; &lt;roundRobin, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] route settings, reset, route: r0: * -&gt; &lt;roundRobin, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings applied\n::1 - - [05/Feb/2019:15:39:06 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 3 localhost:9090 - -\n::1 - - [05/Feb/2019:15:39:07 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 localhost:9090 - -\n::1 - - [05/Feb/2019:15:39:08 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 localhost:9090 - -\n::1 - - [05/Feb/2019:15:39:09 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 localhost:9090 - -\n</code></pre></p> <p>Backend1 returns \u201cA\u201d in the body: <pre><code>$ ./bin/skipper -address=\":9998\" -inline-routes 'r0: * -&gt; inlineContent(\"A\") -&gt; &lt;shunt&gt;;'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9998\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings, reset, route: r0: * -&gt; inlineContent(\"A\") -&gt; &lt;shunt&gt;\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n127.0.0.1 - - [05/Feb/2019:15:39:06 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 127.0.0.1:9998 - -\n127.0.0.1 - - [05/Feb/2019:15:39:08 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 127.0.0.1:9998 - -\n</code></pre></p> <p>Backend2 returns \u201cB\u201d in the body: <pre><code>$ ./bin/skipper -address=\":9997\" -inline-routes 'r0: * -&gt; inlineContent(\"B\") -&gt; &lt;shunt&gt;;'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9997\n[APP]INFO[0000] route settings, reset, route: r0: * -&gt; inlineContent(\"B\") -&gt; &lt;shunt&gt;\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n127.0.0.1 - - [05/Feb/2019:15:39:07 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 127.0.0.1:9997 - -\n127.0.0.1 - - [05/Feb/2019:15:39:09 +0100] \"GET / HTTP/1.1\" 200 1 \"-\" \"curl/7.49.0\" 0 127.0.0.1:9997 - -\n</code></pre></p> <p>Client: <pre><code>$ curl -s http://localhost:9090/\nA\n$ curl -s http://localhost:9090/\nB\n$ curl -s http://localhost:9090/\nA\n$ curl -s http://localhost:9090/\nB\n</code></pre></p>"},{"location":"reference/backends/#backend-protocols","title":"Backend Protocols","text":"<p>Current implemented protocols:</p> <ul> <li><code>http</code>: (default) http protocol</li> <li><code>fastcgi</code>: (experimental) directly connect Skipper with a FastCGI backend like PHP FPM.</li> </ul> <p>Route example that uses FastCGI (experimental): <pre><code>php: * -&gt; setFastCgiFilename(\"index.php\") -&gt; \"fastcgi://127.0.0.1:9000\";\nphp_lb: * -&gt; setFastCgiFilename(\"index.php\") -&gt; &lt;roundRobin, \"fastcgi://127.0.0.1:9000\", \"fastcgi://127.0.0.1:9001\"&gt;;\n</code></pre></p>"},{"location":"reference/development/","title":"Development","text":""},{"location":"reference/development/#how-to-develop-a-filter","title":"How to develop a Filter","text":"<p>A filter is part of a route and can change arbitrary http data in the <code>http.Request</code> and <code>http.Response</code> path of a proxy.</p> <p>The filter example shows a non trivial diff of a filter implementation, that implements an authnz webhook. It shows global settings passed via flags, user documentation, developer documentation for library users, the filter implementation and some test cases. Tests should test the actual filter implementation in a proxy setup.</p>"},{"location":"reference/development/#how-to-pass-options-to-your-filter","title":"How to pass options to your filter","text":"<p>Set a <code>default</code> and a <code>Usage</code> string as const.  Add a var to hold the value and put the flag to the category, that makes the most sense.</p> <p>If a filter, predicate or dataclient need <code>Options</code> passed from flags, then you should register the filter in <code>skipper.go</code>, the main library entrypoint. In case you do not need options from flags, use <code>MakeRegistry()</code> in <code>./filters/builtin/builtin.go</code> to register your filter.</p> <pre><code>diff --git a/cmd/skipper/main.go b/cmd/skipper/main.go\nindex 28f18f9..4530b85 100644\n--- a/cmd/skipper/main.go\n+++ b/cmd/skipper/main.go\n@@ -59,9 +59,10 @@ const (\n    defaultOAuthTokeninfoTimeout          = 2 * time.Second\n    defaultOAuthTokenintrospectionTimeout = 2 * time.Second\n+   defaultWebhookTimeout                 = 2 * time.Second\n\n    // generic:\n    addressUsage                         = \"network address that skipper should listen on\"\n@@ -141,6 +142,8 @@ const (\n    oauth2TokeninfoURLUsage              = \"sets the default tokeninfo URL to query information about an incoming OAuth2 token in oauth2Tokeninfo filters\"\n    oauth2TokeninfoTimeoutUsage          = \"sets the default tokeninfo request timeout duration to 2000ms\"\n    oauth2TokenintrospectionTimeoutUsage = \"sets the default tokenintrospection request timeout duration to 2000ms\"\n+   webhookTimeoutUsage                  = \"sets the webhook request timeout duration, defaults to 2s\"\n+\n    // connections, timeouts:\n    idleConnsPerHostUsage           = \"maximum idle connections per backend host\"\n    closeIdleConnsPeriodUsage       = \"period of closing all idle connections in seconds or as a duration string. Not closing when less than 0\"\n@@ -243,13 +246,14 @@ var (\n    oauth2TokeninfoURL              string\n    oauth2TokeninfoTimeout          time.Duration\n    oauth2TokenintrospectionTimeout time.Duration\n+   webhookTimeout                  time.Duration\n\n    // connections, timeouts:\n    idleConnsPerHost           int\n@@ -351,13 +355,14 @@ func init() {\n    flag.DurationVar(&amp;oauth2TokeninfoTimeout, \"oauth2-tokeninfo-timeout\", defaultOAuthTokeninfoTimeout, oauth2TokeninfoTimeoutUsage)\n    flag.DurationVar(&amp;oauth2TokenintrospectionTimeout, \"oauth2-tokenintrospect-timeout\", defaultOAuthTokenintrospectionTimeout, oauth2TokenintrospectionTimeoutUsage)\n+   flag.DurationVar(&amp;webhookTimeout, \"webhook-timeout\", defaultWebhookTimeout, webhookTimeoutUsage)\n\n    // connections, timeouts:\n    flag.IntVar(&amp;idleConnsPerHost, \"idle-conns-num\", proxy.DefaultIdleConnsPerHost, idleConnsPerHostUsage)\n@@ -536,13 +541,14 @@ func main() {\n        OAuthTokeninfoURL:              oauth2TokeninfoURL,\n        OAuthTokeninfoTimeout:          oauth2TokeninfoTimeout,\n        OAuthTokenintrospectionTimeout: oauth2TokenintrospectionTimeout,\n+       WebhookTimeout:                 webhookTimeout,\n\n        // connections, timeouts:\n        IdleConnectionsPerHost:     idleConnsPerHost,\n\ndiff --git a/skipper.go b/skipper.go\nindex 10d5769..da46fe0 100644\n--- a/skipper.go\n+++ b/skipper.go\n@@ -443,6 +443,9 @@ type Options struct {\n    // OAuthTokenintrospectionTimeout sets timeout duration while calling oauth tokenintrospection service\n    OAuthTokenintrospectionTimeout time.Duration\n\n+   // WebhookTimeout sets timeout duration while calling a custom webhook auth service\n+   WebhookTimeout time.Duration\n+\n    // MaxAuditBody sets the maximum read size of the body read by the audit log filter\n    MaxAuditBody int\n }\n@@ -677,7 +680,8 @@ func Run(o Options) error {\n        auth.NewOAuthTokenintrospectionAnyClaims(o.OAuthTokenintrospectionTimeout),\n        auth.NewOAuthTokenintrospectionAllClaims(o.OAuthTokenintrospectionTimeout),\n        auth.NewOAuthTokenintrospectionAnyKV(o.OAuthTokenintrospectionTimeout),\n-       auth.NewOAuthTokenintrospectionAllKV(o.OAuthTokenintrospectionTimeout))\n+       auth.NewOAuthTokenintrospectionAllKV(o.OAuthTokenintrospectionTimeout),\n+       auth.NewWebhook(o.WebhookTimeout))\n\n    // create a filter registry with the available filter specs registered,\n    // and register the custom filters\n</code></pre>"},{"location":"reference/development/#user-documentation","title":"User documentation","text":"<p>Documentation for users should be done in <code>docs/</code>.</p> <pre><code>diff --git a/docs/filters.md b/docs/filters.md\nindex d3bb872..a877062 100644\n--- a/docs/filters.md\n+++ b/docs/filters.md\n@@ -382,6 +382,24 @@ basicAuth(\"/path/to/htpasswd\")\n basicAuth(\"/path/to/htpasswd\", \"My Website\")\n ```\n\n+## webhook\n+\n+The `webhook` filter makes it possible to have your own authentication and\n+authorization endpoint as a filter.\n+\n+Headers from the incoming request will be copied into the request that\n+is being done to the webhook endpoint. Responses from the webhook with\n+status code less than 300 will be authorized, rest unauthorized.\n+\n+Examples:\n+\n+```\n+webhook(\"https://custom-webhook.example.org/auth\")\n+```\n+\n+The webhook timeout has a default of 2 seconds and can be globally\n+changed, if skipper is started with `-webhook-timeout=2s` flag.\n+\n ## oauthTokeninfoAnyScope\n\n If skipper is started with `-oauth2-tokeninfo-url` flag, you can use\n</code></pre>"},{"location":"reference/development/#add-godoc","title":"Add godoc","text":"<p>Godoc is meant for developers using skipper as library, use <code>doc.go</code> of the package to document generic functionality, usage and library usage.</p> <pre><code>diff --git a/filters/auth/doc.go b/filters/auth/doc.go\nindex 696d3fd..1d6e3a8 100644\n--- a/filters/auth/doc.go\n+++ b/filters/auth/doc.go\n@@ -318,5 +318,12 @@ filter after the auth filter.\n     a: Path(\"/only-allowed-audit-log\") -&gt; oauthTokeninfoAnyScope(\"bar-w\") -&gt; auditLog() -&gt; \"https://internal.example.org/\";\n     b: Path(\"/all-access-requests-audit-log\") -&gt; auditLog() -&gt; oauthTokeninfoAnyScope(\"foo-r\") -&gt; \"https://internal.example.org/\";\n\n+Webhook - webhook() filter\n+\n+The filter webhook allows you to have a custom authentication and\n+authorization endpoint for a route.\n+\n+    a: Path(\"/only-allowed-by-webhook\") -&gt; webhook(\"https://custom-webhook.example.org/auth\") -&gt; \"https://protected-backend.example.org/\";\n+\n */\n package auth\n</code></pre>"},{"location":"reference/development/#filter-implementation","title":"Filter implementation","text":"<p>A filter can modify the incoming <code>http.Request</code> before calling the backend and the outgoing <code>http.Response</code> from the backend to the client.</p> <p>A filter consists of at least two types a <code>spec</code> and a <code>filter</code>. Spec consists of everything that is needed and known before a user will instantiate a filter.</p> <p>A spec will be created in the bootstrap procedure of a skipper process. A spec has to satisfy the <code>Spec</code> interface <code>Name() string</code> and <code>CreateFilter([]interface{}) (filters.Filter, error)</code>.</p> <p>The actual filter implementation has to satisfy the <code>Filter</code> interface <code>Request(filters.FilterContext)</code> and <code>Response(filters.FilterContext)</code>.</p> <pre><code>diff --git a/filters/auth/webhook.go b/filters/auth/webhook.go\nnew file mode 100644\nindex 0000000..f0632a6\n--- /dev/null\n+++ b/filters/auth/webhook.go\n@@ -0,0 +1,84 @@\n+package auth\n+\n+import (\n+   \"net/http\"\n+   \"time\"\n+\n+   \"github.com/zalando/skipper/filters\"\n+)\n+\n+const (\n+   WebhookName = \"webhook\"\n+)\n+\n+type (\n+   webhookSpec struct {\n+       Timeout time.Duration\n+   }\n+   webhookFilter struct {\n+       authClient *authClient\n+   }\n+)\n+\n+// NewWebhook creates a new auth filter specification\n+// to validate authorization for requests.\n+func NewWebhook(d time.Duration) filters.Spec {\n+   return &amp;webhookSpec{Timeout: d}\n+}\n+\n+func (*webhookSpec) Name() string {\n+   return WebhookName\n+}\n+\n+// CreateFilter creates an auth filter. The first argument is an URL\n+// string.\n+//\n+//     s.CreateFilter(\"https://my-auth-service.example.org/auth\")\n+//\n+func (ws *webhookSpec) CreateFilter(args []interface{}) (filters.Filter, error) {\n+   if l := len(args); l == 0 || l &gt; 2 {\n+       return nil, filters.ErrInvalidFilterParameters\n+   }\n+\n+   s, ok := args[0].(string)\n+   if !ok {\n+       return nil, filters.ErrInvalidFilterParameters\n+   }\n+\n+   ac, err := newAuthClient(s, ws.Timeout)\n+   if err != nil {\n+       return nil, filters.ErrInvalidFilterParameters\n+   }\n+\n+   return &amp;webhookFilter{authClient: ac}, nil\n+}\n+\n+func copyHeader(to, from http.Header) {\n+   for k, v := range from {\n+       to[http.CanonicalHeaderKey(k)] = v\n+   }\n+}\n+\n+func (f *webhookFilter) Request(ctx filters.FilterContext) {\n+   statusCode, err := f.authClient.getWebhook(ctx.Request())\n+   if err != nil {\n+       unauthorized(ctx, WebhookName, authServiceAccess, f.authClient.url.Hostname())\n+   }\n+   // redirects, auth errors, webhook errors\n+   if statusCode &gt;= 300 {\n+       unauthorized(ctx, WebhookName, invalidAccess, f.authClient.url.Hostname())\n+   }\n+   authorized(ctx, WebhookName)\n+}\n+\n+func (*webhookFilter) Response(filters.FilterContext) {}\n</code></pre>"},{"location":"reference/development/#writing-tests","title":"Writing tests","text":"<p>Skipper uses normal table driven Go tests without frameworks.</p> <p>This example filter test creates a backend, an auth service to be called by our filter, and a filter configured by our table driven test.</p> <p>In general we use real backends with dynamic port allocations. We call these and inspect the <code>http.Response</code> to check, if we get expected results for invalid and valid data.</p> <p>Skipper has some helpers to create the test proxy in the <code>proxytest</code> package. Backends can be created with <code>httptest.NewServer</code> as in the example below.</p> <pre><code>diff --git a/filters/auth/webhook_test.go b/filters/auth/webhook_test.go\nnew file mode 100644\nindex 0000000..d43c4ea\n--- /dev/null\n+++ b/filters/auth/webhook_test.go\n@@ -0,0 +1,128 @@\n+package auth\n+\n+import (\n+   \"fmt\"\n+   \"io\"\n+   \"net/http\"\n+   \"net/http/httptest\"\n+   \"net/url\"\n+   \"testing\"\n+   \"time\"\n+\n+   \"github.com/zalando/skipper/eskip\"\n+   \"github.com/zalando/skipper/filters\"\n+   \"github.com/zalando/skipper/proxy/proxytest\"\n+)\n+\n+func TestWebhook(t *testing.T) {\n+   for _, ti := range []struct {\n+       msg        string\n+       token      string\n+       expected   int\n+       authorized bool\n+       timeout    bool\n+   }{{\n+       msg:        \"invalid-token-should-be-unauthorized\",\n+       token:      \"invalid-token\",\n+       expected:   http.StatusUnauthorized,\n+       authorized: false,\n+   }, {\n+       msg:        \"valid-token-should-be-authorized\",\n+       token:      testToken,\n+       expected:   http.StatusOK,\n+       authorized: true,\n+   }, {\n+       msg:        \"webhook-timeout-should-be-unauthorized\",\n+       token:      testToken,\n+       expected:   http.StatusUnauthorized,\n+       authorized: false,\n+       timeout:    true,\n+   }} {\n+       t.Run(ti.msg, func(t *testing.T) {\n+           backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n+               w.WriteHeader(http.StatusOK)\n+               io.WriteString(w, \"Hello from backend\")\n+               return\n+           }))\n+           defer backend.Close()\n+\n+           authServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+               if ti.timeout {\n+                   time.Sleep(time.Second + time.Millisecond)\n+               }\n+\n+               if r.Method != \"GET\" {\n+                   w.WriteHeader(489)\n+                   io.WriteString(w, \"FAIL - not a GET request\")\n+                   return\n+               }\n+\n+               tok := r.Header.Get(authHeaderName)\n+               tok = tok[len(authHeaderPrefix):len(tok)]\n+               switch tok {\n+               case testToken:\n+                   w.WriteHeader(200)\n+                   fmt.Fprintln(w, \"OK - Got token: \"+tok)\n+                   return\n+               }\n+               w.WriteHeader(402)                            //http.StatusUnauthorized)\n+               fmt.Fprintln(w, \"Unauthorized - Got token: \") //+tok)\n+           }))\n+           defer authServer.Close()\n+\n+           spec := NewWebhook(time.Second)\n+\n+           args := []interface{}{\n+               \"http://\" + authServer.Listener.Addr().String(),\n+           }\n+           f, err := spec.CreateFilter(args)\n+           if err != nil {\n+               t.Errorf(\"error in creating filter for %s: %v\", ti.msg, err)\n+               return\n+           }\n+\n+           f2 := f.(*webhookFilter)\n+           defer f2.Close()\n+\n+           fr := make(filters.Registry)\n+           fr.Register(spec)\n+           r := &amp;eskip.Route{Filters: []*eskip.Filter{{Name: spec.Name(), Args: args}}, Backend: backend.URL}\n+\n+           proxy := proxytest.New(fr, r)\n+           defer proxy.Close()\n+\n+           reqURL, err := url.Parse(proxy.URL)\n+           if err != nil {\n+               t.Errorf(\"Failed to parse url %s: %v\", proxy.URL, err)\n+               return\n+           }\n+\n+           req, err := http.NewRequest(\"GET\", reqURL.String(), nil)\n+           if err != nil {\n+               t.Errorf(\"failed to create request %v\", err)\n+               return\n+           }\n+           req.Header.Set(authHeaderName, authHeaderPrefix+ti.token)\n+\n+           rsp, err := http.DefaultClient.Do(req)\n+           if err != nil {\n+               t.Errorf(\"failed to get response: %v\", err)\n+               return\n+           }\n+           defer rsp.Body.Close()\n+\n+           buf := make([]byte, 128)\n+           var n int\n+           if n, err = rsp.Body.Read(buf); err != nil &amp;&amp; err != io.EOF {\n+               t.Errorf(\"Could not read response body: %v\", err)\n+               return\n+           }\n+\n+           t.Logf(\"%d %d\", rsp.StatusCode, ti.expected)\n+           if rsp.StatusCode != ti.expected {\n+               t.Errorf(\"unexpected status code: %v != %v %d %s\", rsp.StatusCode, ti.expected, n, buf)\n+               return\n+           }\n+       })\n+   }\n+}\n</code></pre>"},{"location":"reference/development/#using-a-debugger","title":"Using a debugger","text":"<p>Skipper supports plugins and to offer this support it uses the <code>plugin</code> library. Due to Go compiler issue #23733, a debugger cannot be used. This issue will be fixed in Go 1.12 but until then the only workaround is to remove references to the <code>plugin</code> library. The following patch can be used for debugging.</p> <pre><code>diff --git a/plugins.go b/plugins.go\nindex 837b6cf..aa69f09 100644\n--- a/plugins.go\n+++ b/plugins.go\n@@ -1,5 +1,6 @@\n package skipper\n\n+/*\n import (\n    \"fmt\"\n    \"os\"\n@@ -13,8 +14,13 @@ import (\n    \"github.com/zalando/skipper/filters\"\n    \"github.com/zalando/skipper/routing\"\n )\n+*/\n\n func (o *Options) findAndLoadPlugins() error {\n+   return nil\n+}\n+\n+/*\n    found := make(map[string]string)\n    done := make(map[string][]string)\n\n@@ -366,3 +372,4 @@ func readPluginConfig(plugin string) (conf []string, err error) {\n    }\n    return conf, nil\n }\n+*/\n</code></pre> <p>The patch can be applied with the <code>git apply $PATCH_FILE</code> command. Please do not commit the modified <code>plugins.go</code> along with your changes.</p>"},{"location":"reference/egress/","title":"Egress Proxy","text":"<p>Disclaimer: Egress features are probably not feature complete. Please create GitHub Issues to show your ideas about this topic.</p> <p>The picture below shows an authentication use case with Bearer token injection, to show the egress traffic flow: </p> <p>Skipper has some features, which are egress specific. Some features, for example dropRequestHeader or ratelimit, might also be used, but are not listed here:</p> <ul> <li>circuit breaker filters</li> <li>consecutiveBreaker</li> <li>rateBreaker</li> <li>disableBreaker</li> <li>bearerinjector filter, that injects tokens for an app</li> <li>The secrets module that does</li> <li>automated secrets rotation read from files used by <code>bearerinjector filter</code></li> <li>dynamic secrets lookup used by <code>bearerinjector filter</code></li> <li>encryption and decryption used by OpenID Connect filters</li> </ul>"},{"location":"reference/egress/#secrets-module","title":"Secrets Module","text":"<p>Disclaimer: the specified features might be changed to make use   cases work in the future.</p>"},{"location":"reference/egress/#automated-secrets-rotation","title":"Automated Secrets rotation","text":"<p>Secrets are read from files. Files can be rewritten by third party tools to integrate whatever provider you want. In Kubernetes you can write Secrets with an API and read them using a rotated, mounted files from skipper for example.</p> <p>To specify files or directories to find secrets, you can use <code>-credentials-paths</code> command line flag. Filenames are used to define the name of the secret, which will be used as a lookup key.</p> <p>The files need to be created before skipper is started, and as of today skipper doesn\u2019t find new files automatically. This might change in the future.</p> <p>To change the default update interval, which defaults to <code>10m</code>, you can use the <code>-credentials-update-interval</code> command line flag.</p>"},{"location":"reference/egress/#example-bearer-injection","title":"Example bearer injection","text":"<p>Create file <code>/tmp/secrets/mytoken</code>, that contains <code>mytoken</code>:</p> <pre><code>mkdir /tmp/secrets; echo mytoken &gt;/tmp/secrets/mytoken`.\n</code></pre> <p>start fake service</p> <pre><code>nc -l 8080\n</code></pre> <p>start skipper proxy</p> <pre><code>skipper -inline-routes='Host(\"host1\") -&gt; bearerinjector(\"/tmp/secrets/mytoken\") -&gt; \"http://127.0.0.1:8080/\"' -credentials-paths=/tmp/secrets -credentials-update-interval=10s\n..\n[APP]INFO[0004] Updated secret file: /tmp/secrets/mytoken\n..\n</code></pre> <p>Client calls skipper proxy</p> <pre><code>% curl -H\"Host: host1\" localhost:9090/foo\n^C\n</code></pre> <p>fake service shows</p> <pre><code>GET /foo HTTP/1.1\nHost: 127.0.0.1:8080\nUser-Agent: curl/7.49.0\nAccept: */*\nAuthorization: Bearer mytoken\nAccept-Encoding: gzip\n</code></pre> <p>Change the secret: <code>echo changedtoken &gt;/tmp/secrets/mytoken</code>. Wait until skipper logs: <code>[APP]INFO[0010] update secret file: /tmp/secrets/mytoken</code></p> <p>Restart fake service (CTRL-c to stop)</p> <pre><code>nc -l 8080\n</code></pre> <p>Client calls skipper proxy retry:</p> <pre><code>% curl -H\"Host: host1\" localhost:9090/foo\n^C\n</code></pre> <p>fake service shows</p> <pre><code>GET /foo HTTP/1.1\nHost: 127.0.0.1:8080\nUser-Agent: curl/7.49.0\nAccept: */*\nAuthorization: Bearer changedtoken\nAccept-Encoding: gzip\n</code></pre> <p>This example showed bearer injection with secrets rotation.</p>"},{"location":"reference/egress/#reach-multiple-services","title":"Reach multiple services","text":"<p>Often your service wants to reach multiple services, so you need to differentiate these routes, somehow.</p> <p>For example your service needs to access <code>a.example.com</code> and <code>b.example.com</code>.</p> <p>One example is to use <code>.localhost</code> domain, so <code>a.localhost</code> and <code>b.localhost</code> in your application and in skipper routes you would have:</p> <pre><code>a: Host(\"a.localhost\") -&gt; bearerinjector(\"/tmp/secrets/mytoken\") -&gt; \"https://a.example.com\"\nb: Host(\"b.localhost\") -&gt; bearerinjector(\"/tmp/secrets/mytoken\") -&gt; \"https://b.example.com\"\n</code></pre> <p>You can also use host aliases, in Linux <code>/etc/hosts</code>, or in Kubernetes <code>hostAliases</code>:</p> <p>Pod spec:</p> <pre><code>spec:\n  hostAliases:\n  - ip: 127.0.0.1\n    hostnames:\n    - a.local\n    - b.local\n</code></pre>"},{"location":"reference/egress/#future-todos","title":"Future - TODOs","text":"<p>We want to experiment in how to best use skipper as egress proxy.  One idea is to implement forward proxy via HTTP CONNECT and being able to use the routing to inject the right Authorization headers with the bearerinjector filter, for example.</p> <p>If you have ideas please add your thoughts in one of the issues, that match your idea or create a new one.</p>"},{"location":"reference/filters/","title":"Skipper Filters","text":"<p>The parameters can be strings, regex or float64 / int</p> <ul> <li><code>string</code> is a string surrounded by double quotes (<code>\"</code>)</li> <li><code>regex</code> is a regular expression, surrounded by <code>/</code>, e.g. <code>/^www\\.example\\.org(:\\d+)?$/</code></li> <li><code>int</code> / <code>float64</code> are usual (decimal) numbers like <code>401</code> or <code>1.23456</code></li> <li><code>time</code> is a string in double quotes, parsable by time.Duration)</li> </ul> <p>Filters are a generic tool and can change HTTP header and body in the request and response path. Filter can be chained using the arrow operator <code>-&gt;</code>.</p> <p>Example route with a match all, 2 filters and a backend:</p> <pre><code>all: * -&gt; filter1 -&gt; filter2 -&gt; \"http://127.0.0.1:1234/\";\n</code></pre>"},{"location":"reference/filters/#template-placeholders","title":"Template placeholders","text":"<p>Several filters support template placeholders (<code>${var}</code>) in string parameters.</p> <p>Template placeholder is replaced by the value that is looked up in the following sources:</p> <ul> <li>request method (<code>${request.method}</code>)</li> <li>request host (<code>${request.host}</code>)</li> <li>request url path (<code>${request.path}</code>)</li> <li>request url rawquery (<code>${request.rawQuery}</code>, encoded request URL query without <code>?</code>, e.g. <code>q=foo&amp;r=bar</code>)</li> <li>request url query (if starts with <code>request.query.</code> prefix, e.g <code>${request.query.q}</code> is replaced by <code>q</code> query parameter value)</li> <li>request headers (if starts with <code>request.header.</code> prefix, e.g <code>${request.header.Content-Type}</code> is replaced by <code>Content-Type</code> request header value)</li> <li>request cookies (if starts with <code>request.cookie.</code> prefix, e.g <code>${request.cookie.PHPSESSID}</code> is replaced by <code>PHPSESSID</code> request cookie value)</li> <li>request IP address<ul> <li><code>${request.source}</code> - first IP address from <code>X-Forwarded-For</code> header or request remote IP address if header is absent, similar to Source predicate</li> <li><code>${request.sourceFromLast}</code> - last IP address from <code>X-Forwarded-For</code> header or request remote IP address if header is absent, similar to SourceFromLast predicate</li> <li><code>${request.clientIP}</code> - request remote IP address similar to ClientIP predicate</li> </ul> </li> <li>response headers (if starts with <code>response.header.</code> prefix, e.g <code>${response.header.Location}</code> is replaced by <code>Location</code> response header value)</li> <li>filter context path parameters (e.g. <code>${id}</code> is replaced by <code>id</code> path parameter value)</li> </ul> <p>Missing value interpretation depends on the filter.</p> <p>Example route that rewrites path using template placeholder:</p> <pre><code>u1: Path(\"/user/:id\") -&gt; setPath(\"/v2/user/${id}\") -&gt; &lt;loopback&gt;;\n</code></pre> <p>Example route that creates header from query parameter: <pre><code>r: Path(\"/redirect\") &amp;&amp; QueryParam(\"to\") -&gt; status(303) -&gt; setResponseHeader(\"Location\", \"${request.query.to}\") -&gt; &lt;shunt&gt;;\n</code></pre></p>"},{"location":"reference/filters/#status","title":"status","text":"<p>Sets the response status code to the given value, with no regards to the backend response.</p> <p>Parameters:</p> <ul> <li>status code (int)</li> </ul> <p>Example:</p> <pre><code>route1: Host(/^all401\\.example\\.org$/) -&gt; status(401) -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/filters/#comment","title":"comment","text":"<p>No operation, only to comment the route or a group of filters of a route</p> <p>Parameters:</p> <ul> <li>msg (string)</li> </ul> <p>Example:</p> <pre><code>route1: *\n    -&gt; comment(\"nothing to see\")\n    -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/filters/#annotate","title":"annotate","text":"<p>Annotate the route, subsequent annotations using the same key will overwrite the value. Other subsequent filters can use annotations to make decisions and should document the key and value they use.</p> <p>Parameters:</p> <ul> <li>key (string)</li> <li>value (string)</li> </ul> <p>Example:</p> <pre><code>route1: *\n    -&gt; annotate(\"never\", \"gonna give you up\")\n    -&gt; annotate(\"never\", \"gonna let you down\")\n    -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/filters/#http-headers","title":"HTTP Headers","text":""},{"location":"reference/filters/#preservehost","title":"preserveHost","text":"<p>Sets the incoming <code>Host:</code> header on the outgoing backend connection.</p> <p>It can be used to override the <code>proxyPreserveHost</code> behavior for individual routes.</p> <p>Parameters: \u201ctrue\u201d or \u201cfalse\u201d</p> <ul> <li>\u201ctrue\u201d - use the Host header from the incoming request</li> <li>\u201cfalse\u201d - use the host from the backend address</li> </ul> <p>Example: <pre><code>route1: * -&gt; preserveHost(\"true\") -&gt; \"http://backend.example.org\";\n</code></pre></p> <p>Default <code>proxyPreserveHost</code> behavior can be configured by <code>-proxy-preserve-host</code> flag which is <code>false</code> by default.</p>"},{"location":"reference/filters/#modrequestheader","title":"modRequestHeader","text":"<p>Replace all matched regex expressions in the given header.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>the expression to match (regex)</li> <li>the replacement (string)</li> </ul> <p>Example:</p> <pre><code>enforce_www: * -&gt; modRequestHeader(\"Host\", \"^zalando\\.(\\w+)$\", \"www.zalando.$1\") -&gt; redirectTo(301);\n</code></pre>"},{"location":"reference/filters/#setrequestheader","title":"setRequestHeader","text":"<p>Set headers for requests.</p> <p>Header value may contain template placeholders. If a template placeholder can\u2019t be resolved then filter does not set the header.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>header value (string)</li> </ul> <p>Examples:</p> <pre><code>foo: * -&gt; setRequestHeader(\"X-Passed-Skipper\", \"true\") -&gt; \"https://backend.example.org\";\n</code></pre> <pre><code>// Ratelimit per resource\nPath(\"/resource/:id\") -&gt; setRequestHeader(\"X-Resource-Id\", \"${id}\") -&gt; clusterClientRatelimit(\"resource\", 10, \"1m\", \"X-Resource-Id\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#appendrequestheader","title":"appendRequestHeader","text":"<p>Same as setRequestHeader, but appends the provided value to the already existing ones.</p>"},{"location":"reference/filters/#droprequestheader","title":"dropRequestHeader","text":"<p>Removes a header from the request</p> <p>Parameters:</p> <ul> <li>header name (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; dropRequestHeader(\"User-Agent\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#droprequestheadervalueregexp","title":"dropRequestHeaderValueRegexp","text":"<p>Removes header values matched by regex from the request</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>the expression to match (regex)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; dropRequestHeaderValueRegexp(\"User-Agent\", \"^value.\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#modresponseheader","title":"modResponseHeader","text":"<p>Same as modRequestHeader, only for responses</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>the expression to match (regex)</li> <li>the replacement (string)</li> </ul> <p>Example:</p> <pre><code>do_not_avoid_caching: * -&gt; modResponseHeader(\"cache-control\", \"no-cache\", \"cache\") -&gt; \"https://zalando.de\";\n</code></pre>"},{"location":"reference/filters/#setresponseheader","title":"setResponseHeader","text":"<p>Same as setRequestHeader, only for responses</p> <p>Example:</p> <pre><code>set_cookie_with_path_param:\n  Path(\"/path/:id\") &amp;&amp; Method(\"GET\")\n  -&gt; setResponseHeader(\"Set-Cookie\", \"cid=${id}; Max-Age=36000; Secure\")\n  -&gt; redirectTo(302, \"/\")\n  -&gt; &lt;shunt&gt;\n</code></pre>"},{"location":"reference/filters/#appendresponseheader","title":"appendResponseHeader","text":"<p>Same as appendRequestHeader, only for responses</p>"},{"location":"reference/filters/#dropresponseheader","title":"dropResponseHeader","text":"<p>Same as dropRequestHeader but for responses from the backend</p>"},{"location":"reference/filters/#dropresponseheadervalueregexp","title":"dropResponseHeaderValueRegexp","text":"<p>Same as dropRequestHeaderValueRegexp but for responses from the backend</p>"},{"location":"reference/filters/#setcontextrequestheader","title":"setContextRequestHeader","text":"<p>Set headers for requests using values from the filter context (state bag). If the provided key (second parameter) cannot be found in the state bag, then it doesn\u2019t set the header.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>key in the state bag (string)</li> </ul> <p>The route in the following example checks whether the request is authorized with the oauthTokeninfoAllScope() filter. This filter stores the authenticated user with \u201cauth-user\u201d key in the context, and the setContextRequestHeader() filter in the next step stores it in the header of the outgoing request with the X-Uid name:</p> <pre><code>foo: * -&gt; oauthTokeninfoAllScope(\"address_service.all\") -&gt; setContextRequestHeader(\"X-Uid\", \"auth-user\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#appendcontextrequestheader","title":"appendContextRequestHeader","text":"<p>Same as setContextRequestHeader, but appends the provided value to the already existing ones.</p>"},{"location":"reference/filters/#setcontextresponseheader","title":"setContextResponseHeader","text":"<p>Same as setContextRequestHeader, except for responses.</p>"},{"location":"reference/filters/#appendcontextresponseheader","title":"appendContextResponseHeader","text":"<p>Same as appendContextRequestHeader, except for responses.</p>"},{"location":"reference/filters/#copyrequestheader","title":"copyRequestHeader","text":"<p>Copies value of a given request header to another header.</p> <p>Parameters:</p> <ul> <li>source header name (string)</li> <li>target header name (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; copyRequestHeader(\"X-Foo\", \"X-Bar\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#copyresponseheader","title":"copyResponseHeader","text":"<p>Same as copyRequestHeader, except for responses.</p>"},{"location":"reference/filters/#corsorigin","title":"corsOrigin","text":"<p>The filter accepts an optional variadic list of acceptable origin parameters. If the input argument list is empty, the header will always be set to <code>*</code> which means any origin is acceptable. Otherwise the header is only set if the request contains an Origin header and its value matches one of the elements in the input list. The header is only set on the response.</p> <p>Parameters:</p> <ul> <li>url (variadic string)</li> </ul> <p>Examples:</p> <pre><code>corsOrigin()\ncorsOrigin(\"https://www.example.org\")\ncorsOrigin(\"https://www.example.org\", \"http://localhost:9001\")\n</code></pre> <p>Note</p> <p>To enable CORS functionality, you must create a dedicated route that handles <code>OPTIONS</code> requests.</p> <p>Example: <pre><code>main_route:\nPathSubtree(\"/\")\n -&gt; corsOrigin()\n -&gt; setResponseHeader(\"Access-Control-Allow-Credentials\", \"true\")\n -&gt; setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, HEAD, OPTIONS, POST, PUT, PATCH, DELETE\")\n -&gt; \"http://backend.example.org\";\n\npreflight_route:\nPathSubtree(\"/\") &amp;&amp; Method(\"OPTIONS\")\n -&gt; corsOrigin()\n -&gt; setResponseHeader(\"Access-Control-Allow-Credentials\", \"true\")\n -&gt; setResponseHeader(\"Access-Control-Allow-Methods\", \"GET, HEAD, OPTIONS, POST, PUT, PATCH, DELETE\")\n -&gt; setResponseHeader(\"Access-Control-Allow-Headers\", \"authorization, origin, content-type, accept\")\n -&gt; status(200)\n -&gt; &lt;shunt&gt;;\n</code></pre></p>"},{"location":"reference/filters/#encoderequestheader","title":"encodeRequestHeader","text":"<p>The filter has 2 arguments, the header name and the encoding. If the encoding cannot be changed we set the header value to empty string. Supported encodings are listed in https://pkg.go.dev/golang.org/x/text/encoding/charmap .</p> <p>Example: <pre><code>encodeRequestHeader(\"X-Foo\", \"Windows1252\")\n</code></pre></p>"},{"location":"reference/filters/#encoderesponseheader","title":"encodeResponseHeader","text":"<p>The filter has 2 arguments, the header name and the encoding. If the encoding cannot be changed we set the header value to empty string. Supported encodings are listed in https://pkg.go.dev/golang.org/x/text/encoding/charmap .</p> <p>Example: <pre><code>encodeResponseHeader(\"X-Foo\", \"Windows1252\")\n</code></pre></p>"},{"location":"reference/filters/#headertoquery","title":"headerToQuery","text":"<p>Filter which assigns the value of a given header from the incoming Request to a given query param</p> <p>Parameters:</p> <ul> <li>The name of the header to pick from request</li> <li>The name of the query param key to add to request</li> </ul> <p>Examples:</p> <pre><code>headerToQuery(\"X-Foo-Header\", \"foo-query-param\")\n</code></pre> <p>The above filter will set <code>foo-query-param</code> query param respectively to the <code>X-Foo-Header</code> header and will override the value if the queryparam exists already</p>"},{"location":"reference/filters/#flowid","title":"flowId","text":"<p>Sets an X-Flow-Id header, if it\u2019s not already in the request. This allows you to have a trace in your logs, that traces from the incoming request on the edge to all backend services.</p> <p>Flow IDs must be in a certain format to be reusable in skipper. Valid formats depend on the generator used in skipper. Default generator creates IDs of length 16 matching the following regex: <code>^[0-9a-zA-Z+-]+$</code></p> <p>Parameters:</p> <ul> <li>no parameter: resets always the X-Flow-Id header to a new value</li> <li><code>\"reuse\"</code>: only create X-Flow-Id header if not already set or if the value is invalid in the request</li> </ul> <p>Example:</p> <pre><code>* -&gt; flowId() -&gt; \"https://some-backend.example.org\";\n* -&gt; flowId(\"reuse\") -&gt; \"https://some-backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#xforward","title":"xforward","text":"<p>Standard proxy headers. Appends the client remote IP to the X-Forwarded-For and sets the X-Forwarded-Host header.</p>"},{"location":"reference/filters/#xforwardfirst","title":"xforwardFirst","text":"<p>Same as xforward, but instead of appending the last remote IP, it prepends it to comply with the approach of certain LB implementations.</p>"},{"location":"reference/filters/#http-path","title":"HTTP Path","text":""},{"location":"reference/filters/#modpath","title":"modPath","text":"<p>Replace all matched regex expressions in the path.</p> <p>Parameters:</p> <ul> <li>the expression to match (regex)</li> <li>the replacement (string)</li> </ul> <p>Example:</p> <pre><code>rm_api: Path(\"/api\") -&gt; modPath(\"/api\", \"/\") -&gt; \"https://backend.example.org\";\nappend_bar: Path(\"/foo\") -&gt; modPath(\"/foo\", \"/foo/bar\") -&gt; \"https://backend.example.org\";\nnew_base: PathSubtree(\"/base\") -&gt; modPath(\"/base\", \"/new/base) -&gt; \"https://backend.example.org\";\nrm_api_regex: Path(\"/api\") -&gt; modPath(\"^/api/(.*)/v2$\", \"/$1\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#setpath","title":"setPath","text":"<p>Replace the path of the original request to the replacement.</p> <p>Parameters:</p> <ul> <li>the replacement (string)</li> </ul> <p>The replacement may contain template placeholders. If a template placeholder can\u2019t be resolved then empty value is used for it.</p>"},{"location":"reference/filters/#http-redirect","title":"HTTP Redirect","text":""},{"location":"reference/filters/#redirectto","title":"redirectTo","text":"<p>Creates an HTTP redirect response.</p> <p>Parameters:</p> <ul> <li>redirect status code (int)</li> <li>location (string) - optional</li> </ul> <p>Example:</p> <pre><code>redirect1: PathRegexp(/^\\/foo\\/bar/) -&gt; redirectTo(302, \"/foo/newBar\") -&gt; &lt;shunt&gt;;\nredirect2: * -&gt; redirectTo(301) -&gt; &lt;shunt&gt;;\n</code></pre> <ul> <li>Route redirect1 will do a redirect with status code 302 to https   with new path <code>/foo/newBar</code> for requests, that match the path <code>/foo/bar</code>.</li> <li>Route redirect2 will do a <code>https</code> redirect with status code 301 for all   incoming requests that match no other route</li> </ul> <p>see also redirect-handling</p>"},{"location":"reference/filters/#redirecttolower","title":"redirectToLower","text":"<p>Same as redirectTo, but replaces all strings to lowercase.</p>"},{"location":"reference/filters/#http-query","title":"HTTP Query","text":""},{"location":"reference/filters/#stripquery","title":"stripQuery","text":"<p>Removes the query parameter from the request URL, and if the first filter parameter is <code>\"true\"</code>, preserves the query parameter in the form of <code>x-query-param-&lt;queryParamName&gt;: &lt;queryParamValue&gt;</code> headers, so that <code>?foo=bar</code> becomes <code>x-query-param-foo: bar</code></p> <p>Example: <pre><code>* -&gt; stripQuery() -&gt; \"http://backend.example.org\";\n* -&gt; stripQuery(\"true\") -&gt; \"http://backend.example.org\";\n</code></pre></p>"},{"location":"reference/filters/#setquery","title":"setQuery","text":"<p>Set the query string <code>?k=v</code> in the request to the backend to a given value.</p> <p>Parameters:</p> <ul> <li>key (string)</li> <li>value (string)</li> </ul> <p>Key and value may contain template placeholders. If a template placeholder can\u2019t be resolved then empty value is used for it.</p> <p>Example:</p> <pre><code>setQuery(\"k\", \"v\")\n</code></pre>"},{"location":"reference/filters/#dropquery","title":"dropQuery","text":"<p>Delete the query string <code>?k=v</code> in the request to the backend for a given key.</p> <p>Parameters:</p> <ul> <li>key (string)</li> </ul> <p>Key may contain template placeholders. If a template placeholder can\u2019t be resolved then empty value is used for it.</p> <p>Example:</p> <pre><code>dropQuery(\"k\")\n</code></pre>"},{"location":"reference/filters/#querytoheader","title":"queryToHeader","text":"<p>Filter which assigns the value of a given query param from the incoming Request to a given Header with optional format string value.</p> <p>Parameters:</p> <ul> <li>The name of the query param key to pick from request</li> <li>The name of the header to add to request</li> <li>The format string used to create the header value, which gets the   value from the query value as before</li> </ul> <p>Examples:</p> <pre><code>queryToHeader(\"foo-query-param\", \"X-Foo-Header\")\nqueryToHeader(\"access_token\", \"Authorization\", \"Bearer %s\")\n</code></pre> <p>The first filter will set <code>X-Foo-Header</code> header respectively to the <code>foo-query-param</code> query param and will not override the value if the header exists already.</p> <p>The second filter will set <code>Authorization</code> header to the <code>access_token</code> query param with a prefix value <code>Bearer</code> and will not override the value if the header exists already.</p>"},{"location":"reference/filters/#tls","title":"TLS","text":"<p>Filters that provide access to TLS data of a request.</p>"},{"location":"reference/filters/#tlspassclientcertificates","title":"tlsPassClientCertificates","text":"<p>This filter copies TLS client certificates encoded as pem into the X-Forwarded-Tls-Client-Cert header. Multiple certificates are separated by <code>,</code>.</p> <p>Example:</p> <pre><code>* -&gt; tlsPassClientCertificates() -&gt; \"http://10.2.5.21:8080\";\n</code></pre>"},{"location":"reference/filters/#diagnostics","title":"Diagnostics","text":"<p>These filters are meant for diagnostic or load testing purposes.</p>"},{"location":"reference/filters/#randomcontent","title":"randomContent","text":"<p>Generate response with random text of specified length.</p> <p>Parameters:</p> <ul> <li>length of data (int)</li> </ul> <p>Example:</p> <pre><code>* -&gt; randomContent(42) -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/filters/#repeatcontent","title":"repeatContent","text":"<p>Generate response of specified size from repeated text.</p> <p>Parameters:</p> <ul> <li>text to repeat (string)</li> <li>size of response in bytes (int)</li> </ul> <p>Example:</p> <pre><code>* -&gt; repeatContent(\"I will not waste chalk. \", 1000) -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/filters/#repeatcontenthex","title":"repeatContentHex","text":"<p>Generate response of specified size from repeated bytes.</p> <p>Parameters:</p> <ul> <li>bytes to repeat (hexadecimal string)</li> <li>size of response in bytes (int)</li> </ul> <p>Example:</p> <pre><code>* -&gt; repeatContentHex(\"00\", 100) -&gt; &lt;shunt&gt;\n</code></pre> <pre><code>// Create binary response using size equal to the number of bytes to repeat, i.e. repeat once\n* -&gt; repeatContentHex(\"68657861646563696d616c\", 11) -&gt; &lt;shunt&gt;\n</code></pre>"},{"location":"reference/filters/#wrapcontent","title":"wrapContent","text":"<p>Add prefix and suffix to the response.</p> <p>Parameters:</p> <ul> <li>prefix (string)</li> <li>suffix (string)</li> </ul> <p>Examples:</p> <pre><code>* -&gt; wrapContent(\"foo\", \"baz\") -&gt; inlineContent(\"bar\") -&gt; &lt;shunt&gt;\n</code></pre> <pre><code>// JSON array of 100 zeros\n* -&gt; wrapContent(\"[\", \"0]\") -&gt; repeatContent(\"0, \", 297) -&gt; &lt;shunt&gt;\n</code></pre>"},{"location":"reference/filters/#wrapcontenthex","title":"wrapContentHex","text":"<p>Add prefix and suffix to the response.</p> <p>Parameters:</p> <ul> <li>prefix (hexadecimal string)</li> <li>suffix (hexadecimal string)</li> </ul> <p>Examples:</p> <pre><code>* -&gt; wrapContentHex(\"68657861\", \"6d616c\") -&gt; inlineContent(\"deci\") -&gt; &lt;shunt&gt;\n</code></pre> <pre><code>// 1G of gzip-compressed text\n*\n-&gt; setResponseHeader(\"Content-Encoding\", \"gzip\")\n-&gt; wrapContentHex(\n  \"1f8b08000000000004ffecd6b10d00200804c05598c5b80a852d0ee422762ce61c2657d212f8bf9915bb6f9f8c51b9c26c1feec13fc80379a80ff4210ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ff0000ffce781070000ffffecd6810c000000c0207feb737c8ba2f8cd6f7ef39bdffce637bf\",\n  \"7dc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077ce0ff81000000ffffecd6810000000080207feb418ea278ce739ef39ce73ce739cf7de0f581000000ffff010000ffff5216994600ca9a3b\"\n)\n-&gt; repeatContentHex(\"7dc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077cc0077ce0ff81000000ffffecd6810c000000c0207feb737c8ba278ce739ef39ce73ce739cf\", 8300624)\n-&gt; &lt;shunt&gt;\n</code></pre> <p>You may use https://github.com/AlexanderYastrebov/unrepeat to decompose binary file into prefix, repeating content and suffix.</p>"},{"location":"reference/filters/#latency","title":"latency","text":"<p>Enable adding artificial latency</p> <p>Parameters:</p> <ul> <li>latency in milliseconds (int) or in <code>time</code> as a string in double quotes, parsable by time.Duration)</li> </ul> <p>Example:</p> <pre><code>* -&gt; latency(120) -&gt; \"https://www.example.org\";\n* -&gt; latency(\"120ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#bandwidth","title":"bandwidth","text":"<p>Enable bandwidth throttling.</p> <p>Parameters:</p> <ul> <li>bandwidth in kb/s (int)</li> </ul> <p>Example:</p> <pre><code>* -&gt; bandwidth(30) -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#chunks","title":"chunks","text":"<p>Enables adding chunking responses with custom chunk size with artificial delays in between response chunks. To disable delays, set the second parameter to \u201c0\u201d.</p> <p>Parameters:</p> <ul> <li>byte length (int)</li> <li>time duration (time.Duration)</li> </ul> <p>Example:</p> <pre><code>* -&gt; chunks(1024, \"120ms\") -&gt; \"https://www.example.org\";\n* -&gt; chunks(1024, \"0\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#backendlatency","title":"backendLatency","text":"<p>Same as latency filter, but on the request path and not on the response path.</p>"},{"location":"reference/filters/#backendbandwidth","title":"backendBandwidth","text":"<p>Same as bandwidth filter, but on the request path and not on the response path.</p>"},{"location":"reference/filters/#backendchunks","title":"backendChunks","text":"<p>Same as chunks filter, but on the request path and not on the response path.</p>"},{"location":"reference/filters/#tarpit","title":"tarpit","text":"<p>The tarpit filter discards the request and respond with a never ending stream of chunked response payloads. The goal is to consume the client connection without letting the client know what is happening.</p> <p>Parameters:</p> <ul> <li>time duration (time.Duration)</li> </ul> <p>Example:</p> <pre><code>* -&gt; tarpit(\"1s\") -&gt; &lt;shunt&gt;;\n</code></pre> <p>The example will send every second a chunk of response payload.</p>"},{"location":"reference/filters/#absorb","title":"absorb","text":"<p>The absorb filter reads and discards the payload of the incoming requests. It logs with INFO level and a unique ID per request:</p> <ul> <li>the event of receiving the request</li> <li>partial and final events for consuming request payload and total consumed byte count</li> <li>the finishing event of the request</li> <li>any read errors other than EOF</li> </ul>"},{"location":"reference/filters/#absorbsilent","title":"absorbSilent","text":"<p>The absorbSilent filter reads and discards the payload of the incoming requests. It only logs read errors other than EOF.</p>"},{"location":"reference/filters/#uniformrequestlatency","title":"uniformRequestLatency","text":"<p>The uniformRequestLatency filter introduces uniformly distributed jitter latency within <code>[mean-delta, mean+delta]</code> interval for requests. The first parameter is the mean and the second is delta. In the example we would sleep for <code>100ms+/-10ms</code>.</p> <p>Example:</p> <pre><code>* -&gt; uniformRequestLatency(\"100ms\", \"10ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#normalrequestlatency","title":"normalRequestLatency","text":"<p>The normalRequestLatency filter introduces normally distributed jitter latency with configured mean value for requests. The first parameter is \u00b5 (mean) and the second is \u03c3 as in https://en.wikipedia.org/wiki/Normal_distribution.</p> <p>Example:</p> <pre><code>* -&gt; normalRequestLatency(\"10ms\", \"5ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#histogramrequestlatency","title":"histogramRequestLatency","text":"<p>The histogramRequestLatency adds latency to requests according to the histogram distribution. It expects a list of interleaved duration strings and numbers that defines a histogram. Duration strings define boundaries of consecutive buckets and numbers define bucket weights. The filter randomly selects a bucket with probability equal to its weight divided by the sum of all bucket weights (which must be non-zero) and then sleeps for a random duration in between bucket boundaries.</p> <p>Example:</p> <pre><code>r: * -&gt; histogramRequestLatency(\"0ms\", 50, \"5ms\", 0, \"10ms\", 30, \"15ms\", 20, \"20ms\") -&gt; \"https://www.example.org\";\n</code></pre> <p>The example above adds a latency * between 0ms and 5ms to 50% of the requests * between 5ms and 10ms to 0% of the requests * between 10ms and 15ms to 30% of the requests * and between 15ms and 20ms to 20% of the requests.</p>"},{"location":"reference/filters/#uniformresponselatency","title":"uniformResponseLatency","text":"<p>The uniformResponseLatency filter introduces uniformly distributed jitter latency within <code>[mean-delta, mean+delta]</code> interval for responses. The first parameter is the mean and the second is delta. In the example we would sleep for <code>100ms+/-10ms</code>.</p> <p>Example:</p> <pre><code>* -&gt; uniformRequestLatency(\"100ms\", \"10ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#normalresponselatency","title":"normalResponseLatency","text":"<p>The normalResponseLatency filter introduces normally distributed jitter latency with configured mean value for responses. The first parameter is \u00b5 (mean) and the second is \u03c3 as in https://en.wikipedia.org/wiki/Normal_distribution.</p> <p>Example:</p> <pre><code>* -&gt; normalRequestLatency(\"10ms\", \"5ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#histogramresponselatency","title":"histogramResponseLatency","text":"<p>The histogramResponseLatency adds latency to responses according to the histogram distribution, similar to histogramRequestLatency.</p>"},{"location":"reference/filters/#logheader","title":"logHeader","text":"<p>The <code>logHeader</code> filter prints the request line and the header, but not the body, to stderr. Note that this filter should be used only in diagnostics setup and with care, since the request headers may contain sensitive data, and they also can explode the amount of logs. Authorization headers will be truncated in request and response header logs. You can log request or response headers, which defaults for backwards compatibility to request headers.</p> <p>Parameters:</p> <ul> <li>no arg, similar to: \u201crequest\u201d</li> <li>\u201crequest\u201d or \u201cresponse\u201d (string varargs)</li> </ul> <p>Example:</p> <pre><code>* -&gt; logHeader() -&gt; \"https://www.example.org\";\n* -&gt; logHeader(\"request\") -&gt; \"https://www.example.org\";\n* -&gt; logHeader(\"response\") -&gt; \"https://www.example.org\";\n* -&gt; logHeader(\"request\", \"response\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#logbody","title":"logBody","text":"<p>The <code>logBody</code> filter logs the request or response body in chunks while streaming. Chunks start with <code>logBody(\"request\") $flowid:</code> or <code>logBody(\"response\") $flowid:</code>, such that you can find all chunks belonging to a given flow. See also flowId() filter.</p> <p>Note that this filter should be used only in diagnostics setup and with care, since the request and response body may contain sensitive data. Logs can also explode in the amount of bytes, so you have to choose a limit. You can log request or response bodies. This filter has close to no overhead other than the I/O created by the logger.</p> <p>Parameters:</p> <ul> <li>type: \u201crequest\u201d or \u201cresponse\u201d (string)</li> <li>limit: maximum number of bytes to log (int)</li> </ul> <p>Example:</p> <pre><code>* -&gt; logBody(\"request\", 1024) -&gt; \"https://www.example.org\";\n* -&gt; logBody(\"response\", 1024) -&gt; \"https://www.example.org\";\n* -&gt; logBody(\"request\", 1024) -&gt; logBody(\"response\", 1024) -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#timeout","title":"Timeout","text":""},{"location":"reference/filters/#backendtimeout","title":"backendTimeout","text":"<p>Configure backend timeout. Skipper responds with <code>504 Gateway Timeout</code> status if obtaining a connection, sending the request, and reading the backend response headers and body takes longer than the configured timeout. However, if response streaming has already started it will be terminated, i.e. client will receive backend response status and truncated response body.</p> <p>Parameters:</p> <ul> <li>timeout (duration string)</li> </ul> <p>Example:</p> <pre><code>* -&gt; backendTimeout(\"10ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#readtimeout","title":"readTimeout","text":"<p>Configure read timeout will set a read deadline on the server socket connected to the client connecting to the proxy. Skipper will log 499 client timeout with context canceled. We are not able to differentiate between client hang up and read timeout.</p> <p>Parameters:</p> <ul> <li>timeout (duration string)</li> </ul> <p>Example:</p> <pre><code>* -&gt; readTimeout(\"10ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#writetimeout","title":"writeTimeout","text":"<p>Configure write timeout will set a write deadline on the server socket connected to the client connecting to the proxy. Skipper will show access logs as if the response was served as expected, but the client can show an error. You can observe an increase in streaming errors via metrics or a in opentracing proxy span you can see Tag <code>streamBody.byte</code> with value <code>streamBody error</code> or in debug logs something like <code>error while copying the response stream: write tcp 127.0.0.1:9090-&gt;127.0.0.1:38574: i/o timeout</code>.</p> <p>Parameters:</p> <ul> <li>timeout (duration string)</li> </ul> <p>Example:</p> <pre><code>* -&gt; writeTimeout(\"10ms\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#fallback","title":"Fallback","text":""},{"location":"reference/filters/#loopbackifstatus","title":"loopbackIfStatus","text":"<p>Fallbacks to the given path if the response has the specified code. The filter replaces the response coming from the backend or the previous filters.</p> <p>Parameters:</p> <ul> <li>status code (int)</li> <li>path (string)</li> </ul> <p>Example:</p> <pre><code>loopback_404: Path(\"/loopback-404\") -&gt; inlineContent(\"The page you are looking for is not available!\") -&gt; &lt;shunt&gt;\nr: Path(\"/page/:id\") -&gt; loopbackIfStatus(404, \"/loopback-404\") -&gt; \"https://www.example.org\"\n</code></pre>"},{"location":"reference/filters/#shadow-traffic","title":"Shadow Traffic","text":""},{"location":"reference/filters/#tee","title":"tee","text":"<p>Provides a unix-like <code>tee</code> feature for routing.</p> <p>Using this filter, the request will be sent to a \u201cshadow\u201d backend in addition to the main backend of the route.</p> <p>Example:</p> <pre><code>* -&gt; tee(\"https://audit-logging.example.org\") -&gt; \"https://foo.example.org\";\n</code></pre> <p>This will send an identical request for foo.example.org to audit-logging.example.org. Another use case could be using it for benchmarking a new backend with some real traffic. This we call \u201cshadow traffic\u201d.</p> <p>The above route will forward the request to <code>https://foo.example.org</code> as it normally would do, but in addition to that, it will send an identical request to <code>https://audit-logging.example.org</code>. The request sent to <code>https://audit-logging.example.org</code> will receive the same method and headers, and a copy of the body stream. The <code>tee</code> response is ignored for this shadow backend.</p> <p>It is possible to change the path of the tee request, in a similar way to the modPath filter:</p> <pre><code>Path(\"/api/v1\") -&gt; tee(\"https://api.example.org\", \"^/v1\", \"/v2\" ) -&gt; \"http://api.example.org\";\n</code></pre> <p>In the above example, one can test how a new version of an API would behave on incoming requests.</p>"},{"location":"reference/filters/#teenf","title":"teenf","text":"<p>The same as tee filter, but does not follow redirects from the backend.</p>"},{"location":"reference/filters/#teeloopback","title":"teeLoopback","text":"<p>This filter provides a unix-like tee feature for routing, but unlike the tee, this filter feeds the copied request to the start of the routing, including the route lookup and executing the filters on the matched route.</p> <p>It is recommended to use this solution instead of the tee filter, because the same routing facilities are used for the outgoing tee requests as for the normal requests, and all the filters and backend types are supported.</p> <p>To ensure that the right route, or one of the right set of routes, is matched after the loopback, use the filter together with the Tee predicate, however, this is not mandatory if the request is changed via other filters, such that other predicates ensure matching the right route. To avoid infinite looping, the number of requests spawn from a single incoming request is limited similarly as in case of the loopback backend.</p> <p>Parameters:</p> <ul> <li>tee group (string): a label identifying which routes should match the loopback   request, marked with the Tee predicate</li> </ul> <p>Example, generate shadow traffic from 10% of the production traffic:</p> <pre><code>main: * -&gt; \"https://main-backend.example.org\";\nsplit: Traffic(.1) -&gt; teeLoopback(\"test-A\") -&gt; \"https://main-backend.example.org\";\nshadow: Tee(\"test-A\") &amp;&amp; True() -&gt; \"https://test-backend.example.org\";\n</code></pre> <p>See also:</p> <ul> <li>Tee predicate</li> <li>Shadow Traffic Tutorial</li> </ul>"},{"location":"reference/filters/#teeresponse","title":"teeResponse","text":"<p>The teeResponse filter provides the possibility to send the HTTP body of the response to some other HTTP endpoint as request body.</p> <pre><code>r: * -&gt; teeResponse(\"https://another-api.example.org\") -&gt; \"http://api.example.org\";\n</code></pre>"},{"location":"reference/filters/#http-body","title":"HTTP Body","text":""},{"location":"reference/filters/#compress","title":"compress","text":"<p>The filter, when executed on the response path, checks if the response entity can be compressed. To decide, it checks the Content-Encoding, the Cache-Control and the Content-Type headers. It doesn\u2019t compress the content if the Content-Encoding is set to other than identity, or the Cache-Control applies the no-transform pragma, or the Content-Type is set to an unsupported value.</p> <p>The default supported content types are: <code>text/plain</code>, <code>text/html</code>, <code>application/json</code>, <code>application/javascript</code>, <code>application/x-javascript</code>, <code>text/javascript</code>, <code>text/css</code>, <code>image/svg+xml</code>, <code>application/octet-stream</code>.</p> <p>The default set of MIME types can be reset or extended by passing in the desired types as filter arguments. When extending the defaults, the first argument needs to be <code>\"...\"</code>. E.g. to compress tiff in addition to the defaults:</p> <pre><code>* -&gt; compress(\"...\", \"image/tiff\") -&gt; \"https://www.example.org\"\n</code></pre> <p>To reset the supported types, e.g. to compress only HTML, the \u201c\u2026\u201d argument needs to be omitted:</p> <pre><code>* -&gt; compress(\"text/html\") -&gt; \"https://www.example.org\"\n</code></pre> <p>It is possible to control the compression level, by setting it as the first filter argument, in front of the MIME types. The default compression level is best-speed. The possible values are integers between 0 and 9 (inclusive), where 0 means no-compression, 1 means best-speed and 11 means best-compression. Example:</p> <pre><code>* -&gt; compress(11, \"image/tiff\") -&gt; \"https://www.example.org\"\n</code></pre> <p>The filter also checks the incoming request, if it accepts the supported encodings, explicitly stated in the Accept-Encoding header. The filter currently supports by default <code>gzip</code>, <code>deflate</code> and <code>br</code> (can be overridden with flag <code>compress-encodings</code>). It does not assume that the client accepts any encoding if the Accept-Encoding header is not set. It ignores * in the Accept-Encoding header.</p> <p>Supported encodings are prioritized on: - quality value provided by client - compress-encodings flag following order as provided if quality value is equal - <code>gzip</code>, <code>deflate</code>, <code>br</code> in this order otherwise</p> <p>When compressing the response, it updates the response header. It deletes the <code>Content-Length</code> value triggering the proxy to always return the response with chunked transfer encoding, sets the Content-Encoding to the selected encoding and sets the <code>Vary: Accept-Encoding</code> header, if missing.</p> <p>The compression happens in a streaming way, using only a small internal buffer.</p>"},{"location":"reference/filters/#decompress","title":"decompress","text":"<p>The filter, when executed on the response path, checks if the response entity is compressed by a supported algorithm (<code>gzip</code>, <code>deflate</code>, <code>br</code>). To decide, it checks the Content-Encoding header.</p> <p>When compressing the response, it updates the response header. It deletes the <code>Content-Length</code> value triggering the proxy to always return the response with chunked transfer encoding, deletes the Content-Encoding and the Vary headers, if set.</p> <p>The decompression happens in a streaming way, using only a small internal buffer.</p> <p>Example:</p> <pre><code>* -&gt; decompress() -&gt; \"https://www.example.org\"\n</code></pre>"},{"location":"reference/filters/#static","title":"static","text":"<p>Serves static content from the filesystem.</p> <p>Parameters:</p> <ul> <li>Request path to strip (string)</li> <li>Target base path in the filesystem (string)</li> </ul> <p>Example:</p> <p>This serves files from <code>/srv/www/dehydrated</code> when requested via <code>/.well-known/acme-challenge/</code>, e.g. the request <code>GET /.well-known/acme-challenge/foo</code> will serve the file <code>/srv/www/dehydrated/foo</code>. <pre><code>acme: Host(/./) &amp;&amp; Method(\"GET\") &amp;&amp; Path(\"/.well-known/acme-challenge/*\")\n    -&gt; static(\"/.well-known/acme-challenge/\", \"/srv/www/dehydrated\") -&gt; &lt;shunt&gt;;\n</code></pre></p> <p>Notes:</p> <ul> <li>redirects to the directory when a file <code>index.html</code> exists and it is requested, i.e. <code>GET /foo/index.html</code> redirects to <code>/foo/</code> which serves then the <code>/foo/index.html</code></li> <li>serves the content of the <code>index.html</code> when a directory is requested</li> <li>does a simple directory listing of files / directories when no <code>index.html</code> is present</li> </ul>"},{"location":"reference/filters/#inlinecontent","title":"inlineContent","text":"<p>Returns arbitrary content in the HTTP body.</p> <p>Parameters:</p> <ul> <li>content (string)</li> <li>content type (string) - optional</li> </ul> <p>Example:</p> <pre><code>* -&gt; inlineContent(\"&lt;h1&gt;Hello&lt;/h1&gt;\") -&gt; &lt;shunt&gt;\n* -&gt; inlineContent(\"[1,2,3]\", \"application/json\") -&gt; &lt;shunt&gt;\n* -&gt; status(418) -&gt; inlineContent(\"Would you like a cup of tea?\") -&gt; &lt;shunt&gt;\n</code></pre> <p>Content type will be automatically detected when not provided using https://mimesniff.spec.whatwg.org/#rules-for-identifying-an-unknown-mime-type algorithm. Note that content detection algorithm does not contain any rules for recognizing JSON.</p> <p>Note</p> <p><code>inlineContent</code> filter sets the response on request path and starts the response path immediately. The rest of the filter chain and backend are ignored and therefore <code>inlineContent</code> filter must be the last in the chain.</p>"},{"location":"reference/filters/#inlinecontentifstatus","title":"inlineContentIfStatus","text":"<p>Returns arbitrary content in the HTTP body, if the response has the specified status code.</p> <p>Parameters:</p> <ul> <li>status code (int)</li> <li>content (string)</li> <li>content type (string) - optional</li> </ul> <p>Example:</p> <pre><code>* -&gt; inlineContentIfStatus(404, \"&lt;p class=\\\"problem\\\"&gt;We don't have what you're looking for.&lt;/p&gt;\") -&gt; \"https://www.example.org\"\n* -&gt; inlineContentIfStatus(401, \"{\\\"error\\\": \\\"unauthorized\\\"}\", \"application/json\") -&gt; \"https://www.example.org\"\n</code></pre> <p>The content type will be automatically detected when not provided.</p>"},{"location":"reference/filters/#blockcontent","title":"blockContent","text":"<p>Block a request based on it\u2019s body content.</p> <p>The filter max buffer size is 2MiB by default and can be overridden with <code>-max-matcher-buffer-size=&lt;int&gt;</code>.</p> <p>Parameters:</p> <ul> <li>toblockList (List of strings)</li> </ul> <p>Example:</p> <pre><code>* -&gt; blockContent(\"Malicious Content\") -&gt; \"http://example.com\";\n</code></pre>"},{"location":"reference/filters/#blockcontenthex","title":"blockContentHex","text":"<p>Block a request based on it\u2019s body content.</p> <p>The filter max buffer size is 2MiB by default and can be overridden with <code>-max-matcher-buffer-size=&lt;int&gt;</code>.</p> <p>Parameters:</p> <ul> <li>toblockList (List of hex string)</li> </ul> <p>Example:</p> <pre><code>* -&gt; blockContentHex(`000a`) -&gt; \"http://example.com\";\n* -&gt; blockContentHex(\"deadbeef\", \"000a\") -&gt; \"http://example.com\";\n</code></pre>"},{"location":"reference/filters/#sed","title":"sed","text":"<p>The filter sed replaces all occurrences of a pattern with a replacement string in the response body.</p> <p>Example:</p> <pre><code>editorRoute: * -&gt; sed(\"foo\", \"bar\") -&gt; \"https://www.example.org\";\n</code></pre> <p>Example with larger max buffer:</p> <pre><code>editorRoute: * -&gt; sed(\"foo\", \"bar\", 64000000) -&gt; \"https://www.example.org\";\n</code></pre> <p>This filter expects a regexp pattern and a replacement string as arguments. During the streaming of the response body, every occurrence of the pattern will be replaced with the replacement string. The editing doesn\u2019t happen right when the filter is executed, only later when the streaming normally happens, after all response filters were called.</p> <p>The sed() filter accepts two optional arguments, the max editor buffer size in bytes, and max buffer handling flag. The max buffer size, when set, defines how much data can be buffered at a given time by the editor. The default value is 2MiB. The max buffer handling flag can take one of two values: \u201cabort\u201d or \u201cbest-effort\u201d (default). Setting \u201cabort\u201d means that the stream will be aborted when reached the limit. Setting \u201cbest-effort\u201d, will run the replacement on the available content, in case of certain patterns, this may result in content that is different from one that would have been edited in a single piece. See more details below.</p> <p>The filter uses the go regular expression implementation: https://github.com/google/re2/wiki/Syntax . Due to the streaming nature, matches with zero length are ignored.</p>"},{"location":"reference/filters/#memory-handling-and-limitations","title":"Memory handling and limitations","text":"<p>In order to avoid unbound buffering of unprocessed data, the sed* filters need to apply some limitations. Some patterns, e.g. <code>.*</code> would allow to match the complete payload, and it could result in trying to buffer it all and potentially causing running out of available memory. Similarly, in case of certain expressions, when they don\u2019t match, it\u2019s impossible to tell if they would match without reading more data from the source, and so would potentially need to buffer the entire payload.</p> <p>To prevent too high memory usage, the max buffer size is limited in case of each variant of the filter, by default to 2MiB, which is the same limit as the one we apply when reading the request headers by default. When the limit is reached, and the buffered content matches the pattern, then it is processed by replacing it, when it doesn\u2019t match the pattern, then it is forwarded unchanged. This way, e.g. <code>sed(\".*\", \"\")</code> can be used safely to consume and discard the payload.</p> <p>As a result of this, with large payloads, it is possible that the resulting content will be different than if we had run the replacement on the entire content at once. If we have enough preliminary knowledge about the payload, then it may be better to use the delimited variant of the filters, e.g. for line based editing.</p> <p>If the max buffer handling is set to \u201cabort\u201d, then the stream editing is stopped and the rest of the payload is dropped.</p>"},{"location":"reference/filters/#seddelim","title":"sedDelim","text":"<p>Like sed(), but it expects an additional argument, before the optional max buffer size argument, that is used to delimit chunks to be processed at once. The pattern replacement is executed only within the boundaries of the chunks defined by the delimiter, and matches across the chunk boundaries are not considered.</p> <p>Example:</p> <pre><code>editorRoute: * -&gt; sedDelim(\"foo\", \"bar\", \"\\n\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#sedrequest","title":"sedRequest","text":"<p>Like sed(), but for the request content.</p> <p>Example:</p> <pre><code>editorRoute: * -&gt; sedRequest(\"foo\", \"bar\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#sedrequestdelim","title":"sedRequestDelim","text":"<p>Like sedDelim(), but for the request content.</p> <p>Example:</p> <pre><code>editorRoute: * -&gt; sedRequestDelim(\"foo\", \"bar\", \"\\n\") -&gt; \"https://www.example.org\";\n</code></pre>"},{"location":"reference/filters/#authentication-and-authorization","title":"Authentication and Authorization","text":""},{"location":"reference/filters/#basicauth","title":"basicAuth","text":"<p>Enable Basic Authentication</p> <p>The filter accepts two parameters, the first mandatory one is the path to the htpasswd file usually used with Apache or nginx. The second one is the optional realm name that will be displayed in the browser. MD5, SHA1 and BCrypt are supported for Basic authentication password storage, see also the http-auth module page.</p> <p>Examples:</p> <pre><code>basicAuth(\"/path/to/htpasswd\")\nbasicAuth(\"/path/to/htpasswd\", \"My Website\")\n</code></pre>"},{"location":"reference/filters/#webhook","title":"webhook","text":"<p>The <code>webhook</code> filter makes it possible to have your own authentication and authorization endpoint as a filter.</p> <p>Headers from the incoming request will be copied into the request that is being done to the webhook endpoint. It is possible to copy headers from the webhook response into the continuing request by specifying the headers to copy as an optional second argument to the filter.</p> <p>Responses from the webhook will be treated as follows:</p> <ul> <li>Authorized if the status code is less than 300</li> <li>Forbidden if the status code is 403</li> <li>Unauthorized for remaining status codes</li> </ul> <p>Examples:</p> <pre><code>webhook(\"https://custom-webhook.example.org/auth\")\nwebhook(\"https://custom-webhook.example.org/auth\", \"X-Copy-Webhook-Header,X-Copy-Another-Header\")\n</code></pre> <p>The webhook timeout has a default of 2 seconds and can be globally changed, if skipper is started with <code>-webhook-timeout=2s</code> flag.</p>"},{"location":"reference/filters/#tokeninfo","title":"Tokeninfo","text":"<p>Tokeninfo handled by another service. The filters just validate the response from the tokeninfo service to do authorization as defined in the filter.</p>"},{"location":"reference/filters/#oauthtokeninfoanyscope","title":"oauthTokeninfoAnyScope","text":"<p>If skipper is started with <code>-oauth2-tokeninfo-url</code> flag, you can use this filter.</p> <p>The filter accepts variable number of string arguments, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. There are two rejection scenarios for this filter. If the token is not successfully validated by the oauth server, then a 401 Unauthorized response will be returned. However, if the token is successfully validated but the required scope match isn\u2019t satisfied, then a 403 Forbidden response will be returned. If any of the configured scopes from the filter is found inside the tokeninfo result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokeninfoAnyScope(\"s1\", \"s2\", \"s3\")\n</code></pre>"},{"location":"reference/filters/#oauthtokeninfoallscope","title":"oauthTokeninfoAllScope","text":"<p>If skipper is started with <code>-oauth2-tokeninfo-url</code> flag, you can use this filter.</p> <p>The filter accepts variable number of string arguments, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. There are two rejection scenarios for this filter. If the token is not successfully validated by the oauth server, then a 401 Unauthorized response will be returned. However, if the token is successfully validated but the required scope match isn\u2019t satisfied, then a 403 Forbidden response will be returned. If all of the configured scopes from the filter are found inside the tokeninfo result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokeninfoAllScope(\"s1\", \"s2\", \"s3\")\n</code></pre>"},{"location":"reference/filters/#oauthtokeninfoanykv","title":"oauthTokeninfoAnyKV","text":"<p>If skipper is started with <code>-oauth2-tokeninfo-url</code> flag, you can use this filter.</p> <p>The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. There are two rejection scenarios for this filter. If the token is not successfully validated by the oauth server, then a 401 Unauthorized response will be returned. However, if the token is successfully validated but the required scope match isn\u2019t satisfied, then a 403 Forbidden response will be returned. If any of the configured key value pairs from the filter is found inside the tokeninfo result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokeninfoAnyKV(\"k1\", \"v1\", \"k2\", \"v2\")\noauthTokeninfoAnyKV(\"k1\", \"v1\", \"k1\", \"v2\")\n</code></pre>"},{"location":"reference/filters/#oauthtokeninfoallkv","title":"oauthTokeninfoAllKV","text":"<p>If skipper is started with <code>-oauth2-tokeninfo-url</code> flag, you can use this filter.</p> <p>The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. There are two rejection scenarios for this filter. If the token is not successfully validated by the oauth server, then a 401 Unauthorized response will be returned. However, if the token is successfully validated but the required scope match isn\u2019t satisfied, then a 403 Forbidden response will be returned. If all of the configured key value pairs from the filter are found inside the tokeninfo result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokeninfoAllKV(\"k1\", \"v1\", \"k2\", \"v2\")\n</code></pre>"},{"location":"reference/filters/#oauthtokeninfovalidate","title":"oauthTokeninfoValidate","text":"<p>This filter is experimental and may change in the future, please see tests for example usage.</p> <p>The filter obtains token info and allows request if there was no error otherwise it responds with <code>401 Unauthorized</code> status and configured response body.</p> <p>It does nothing if any preceding filter already validated the token or if route is annotated with configured annotations.</p> <p>It is useful as a default filter to ensure each request has a valid token. jwtMetrics filter may be used to discover routes serving requests without a valid token.</p> <p>The filter requires single string argument that is parsed as YAML. For convenience use flow style format.</p> <p>Examples:</p> <pre><code>// without opt-out annotation validates the token\noauthTokeninfoValidate(\"{optOutAnnotations: [oauth.disabled], unauthorizedResponse: 'Authentication required, see https://auth.test/foo'}\")\n</code></pre> <pre><code>// with opt-out annotation does not validate the token\nannotate(\"oauth.disabled\", \"this endpoint is public\") -&gt;\noauthTokeninfoValidate(\"{optOutAnnotations: [oauth.disabled], unauthorizedResponse: 'Authentication required, see https://auth.test/foo'}\")\n</code></pre> <pre><code>// does not validate the token when request host matches one of the patterns:\noauthTokeninfoValidate(\"{optOutAnnotations: [oauth.disabled], optOutHosts: ['^.+[.]domain[.]test$', '^exact.test$'], unauthorizedResponse: 'Authentication required, see https://auth.test/foo'}\")\n</code></pre>"},{"location":"reference/filters/#tokenintrospection","title":"Tokenintrospection","text":"<p>Tokenintrospection handled by another service. The filters just validate the response from the tokenintrospection service to do authorization as defined in the filter.</p>"},{"location":"reference/filters/#oauthtokenintrospectionanyclaims","title":"oauthTokenintrospectionAnyClaims","text":"<p>The filter accepts variable number of string arguments, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>If one of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokenintrospectionAnyClaims(\"https://accounts.google.com\", \"c1\", \"c2\", \"c3\")\n</code></pre>"},{"location":"reference/filters/#oauthtokenintrospectionallclaims","title":"oauthTokenintrospectionAllClaims","text":"<p>The filter accepts variable number of string arguments, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>If all of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokenintrospectionAllClaims(\"https://accounts.google.com\", \"c1\", \"c2\", \"c3\")\n</code></pre>"},{"location":"reference/filters/#oauthtokenintrospectionanykv","title":"oauthTokenintrospectionAnyKV","text":"<p>The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header.  The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>If one of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokenintrospectionAnyKV(\"https://accounts.google.com\", \"k1\", \"v1\", \"k2\", \"v2\")\noauthTokenintrospectionAnyKV(\"https://accounts.google.com\", \"k1\", \"v1\", \"k1\", \"v2\")\n</code></pre>"},{"location":"reference/filters/#oauthtokenintrospectionallkv","title":"oauthTokenintrospectionAllKV","text":"<p>The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header.  The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>If all of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>oauthTokenintrospectionAllKV(\"https://accounts.google.com\", \"k1\", \"v1\", \"k2\", \"v2\")\n</code></pre>"},{"location":"reference/filters/#secureoauthtokenintrospectionanyclaims","title":"secureOauthTokenintrospectionAnyClaims","text":"<p>The filter accepts variable number of string arguments, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>Second and third arguments are the client-id and client-secret. Use this filter if the Token Introspection endpoint requires authorization to validate and decode the incoming token. The filter will optionally read client-id and client-secret from environment variables: OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET</p> <p>If one of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>secureOauthTokenintrospectionAnyClaims(\"issuerURL\", \"client-id\", \"client-secret\", \"claim1\", \"claim2\")\n</code></pre> <p>Read client-id and client-secret from environment variables <pre><code>secureOauthTokenintrospectionAnyClaims(\"issuerURL\", \"\", \"\", \"claim1\", \"claim2\")\n</code></pre></p>"},{"location":"reference/filters/#secureoauthtokenintrospectionallclaims","title":"secureOauthTokenintrospectionAllClaims","text":"<p>The filter accepts variable number of string arguments, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header. The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>Second and third arguments are the client-id and client-secret. Use this filter if the Token Introspection endpoint requires authorization to validate and decode the incoming token. The filter will optionally read client-id and client-secret from environment variables: OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET</p> <p>If all of the configured and supported claims from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>secureOauthTokenintrospectionAllClaims(\"issuerURL\", \"client-id\", \"client-secret\", \"claim1\", \"claim2\")\n</code></pre> <p>Read client-id and client-secret from environment variables <pre><code>secureOauthTokenintrospectionAllClaims(\"issuerURL\", \"\", \"\", \"claim1\", \"claim2\")\n</code></pre></p>"},{"location":"reference/filters/#secureoauthtokenintrospectionanykv","title":"secureOauthTokenintrospectionAnyKV","text":"<p>The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header.  The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>Second and third arguments are the client-id and client-secret. Use this filter if the Token Introspection endpoint requires authorization to validate and decode the incoming token. The filter will optionally read client-id and client-secret from environment variables: OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET</p> <p>If one of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>secureOauthTokenintrospectionAnyKV(\"issuerURL\", \"client-id\", \"client-secret\", \"k1\", \"v1\", \"k2\", \"v2\")\n</code></pre> <p>Read client-id and client-secret from environment variables <pre><code>secureOauthTokenintrospectionAnyKV(\"issuerURL\", \"\", \"\", \"k1\", \"v1\", \"k2\", \"v2\")\n</code></pre></p>"},{"location":"reference/filters/#secureoauthtokenintrospectionallkv","title":"secureOauthTokenintrospectionAllKV","text":"<p>The filter accepts an even number of variable arguments of type string, which are used to validate the incoming token from the <code>Authorization: Bearer &lt;token&gt;</code> header.  The first argument to the filter is the issuer URL, for example <code>https://accounts.google.com</code>, that will be used as described in RFC Draft to find the configuration and for example supported claims.</p> <p>Second and third arguments are the client-id and client-secret. Use this filter if the Token Introspection endpoint requires authorization to validate and decode the incoming token. The filter will optionally read client-id and client-secret from environment variables: OAUTH_CLIENT_ID, OAUTH_CLIENT_SECRET</p> <p>If all of the configured key value pairs from the filter are found inside the tokenintrospection (RFC7662) result for the incoming token, it will allow the request to pass.</p> <p>Examples:</p> <pre><code>secureOauthTokenintrospectionAllKV(\"issuerURL\", \"client-id\", \"client-secret\", \"k1\", \"v1\", \"k2\", \"v2\")\n</code></pre> <p>Read client-id and client-secret from environment variables <pre><code>secureOauthTokenintrospectionAllKV(\"issuerURL\", \"\", \"\", \"k1\", \"v1\", \"k2\", \"v2\")\n</code></pre></p>"},{"location":"reference/filters/#jwt","title":"JWT","text":""},{"location":"reference/filters/#jwtvalidation","title":"jwtValidation","text":"<p>The filter parses bearer jwt token from Authorization header and validates the signature using public keys discovered via /.well-known/openid-configuration endpoint. Takes issuer url as single parameter. The filter stores token claims into the state bag where they can be used by oidcClaimsQuery, forwardToken or forwardTokenField filters.</p> <p>Examples:</p> <pre><code>jwtValidation(\"https://login.microsoftonline.com/{tenantId}/v2.0\")\n</code></pre>"},{"location":"reference/filters/#jwtmetrics","title":"jwtMetrics","text":"<p>This filter is experimental and may change in the future, please see tests for example usage.</p> <p>The filter parses (but does not validate) JWT token from <code>Authorization</code> request header on response path and increments the following counters:</p> <ul> <li><code>missing-token</code>: request does not have <code>Authorization</code> header</li> <li><code>invalid-token-type</code>: <code>Authorization</code> header value is not a <code>Bearer</code> type</li> <li><code>invalid-token</code>: <code>Authorization</code> header does not contain a JWT token</li> <li><code>missing-issuer</code>: DEPRECATED JWT token does not have <code>iss</code> claim</li> <li><code>invalid-issuer</code>: DEPRECATED JWT token does not have any of the configured issuers</li> <li><code>invalid-claims</code>: JWT token does not have any of the configured claims</li> </ul> <p>Each counter name uses concatenation of request method, escaped hostname and response status as a prefix, e.g.:</p> <pre><code>jwtMetrics.custom.GET.example_org.200.invalid-token\n</code></pre> <p>and therefore requires approximately <code>count(HTTP methods) * count(Hosts) * count(Statuses) * 8</code> bytes of additional memory.</p> <p>The filter does nothing if response status is 4xx or route is opt-out via annotation, state bag value or request host pattern.</p> <p>The filter requires single string argument that is parsed as YAML. For convenience use flow style format.</p> <p>Examples:</p> <pre><code>jwtMetrics(\"{issuers: ['https://example.com', 'https://example.org']}\")\n</code></pre> <pre><code>jwtMetrics(\"{claims: [{'iss': 'https://example.com', 'realm': 'emp'}, {'iss': 'https://example.org', 'realm': 'org'}]}\")\n</code></pre> <pre><code>// opt-out by annotation\nannotate(\"oauth.disabled\", \"this endpoint is public\") -&gt;\njwtMetrics(\"{issuers: ['https://example.com', 'https://example.org'], optOutAnnotations: [oauth.disabled]}\")\n\n// opt-out by annotation with claims\nannotate(\"oauth.disabled\", \"this endpoint is public\") -&gt;\njwtMetrics(\"{claims: [{'iss': 'https://example.com', 'realm': 'emp'}], optOutAnnotations: [oauth.disabled]}\")\n</code></pre> <pre><code>// opt-out by state bag:\n// oauthTokeninfo* and oauthGrant filters store token info in the state bag using \"tokeninfo\" key.\noauthTokeninfoAnyKV(\"foo\", \"bar\") -&gt;\njwtMetrics(\"{issuers: ['https://example.com', 'https://example.org'], optOutStateBag: [tokeninfo]}\")\n</code></pre> <pre><code>// opt-out by matching request host pattern:\njwtMetrics(\"{issuers: ['https://example.com', 'https://example.org'], optOutHosts: ['^.+[.]domain[.]test$', '^exact.test$']}\")\n</code></pre>"},{"location":"reference/filters/#forward-token-data","title":"Forward Token Data","text":""},{"location":"reference/filters/#forwardtoken","title":"forwardToken","text":"<p>The filter takes the header name as its first argument and sets header value to the token info or token introspection result serialized as a JSON object. To include only particular fields provide their names as additional arguments.</p> <p>If this filter is used when there is no token introspection or token info data then it does not have any effect.</p> <p>Examples:</p> <pre><code>forwardToken(\"X-Tokeninfo-Forward\")\nforwardToken(\"X-Tokeninfo-Forward\", \"access_token\", \"token_type\")\n</code></pre>"},{"location":"reference/filters/#forwardtokenfield","title":"forwardTokenField","text":"<p>The filter takes a header name and a field as its first and second arguments. The corresponding field from the result of token info, token introspection or oidc user info is added as corresponding header when the request is passed to the backend.</p> <p>If this filter is used when there is no token introspection, token info or oidc user info data then it does not have any effect.</p> <p>To forward multiple fields filters can be sequenced</p> <p>Examples:</p> <pre><code>forwardTokenField(\"X-Tokeninfo-Forward-Oid\", \"oid\") -&gt; forwardTokenField(\"X-Tokeninfo-Forward-Sub\", \"sub\")\n</code></pre>"},{"location":"reference/filters/#oauth2","title":"OAuth2","text":""},{"location":"reference/filters/#oauthgrant","title":"oauthGrant","text":"<p>Enables authentication and authorization with an OAuth2 authorization code grant flow as specified by RFC 6749 Section 1.3.1. Automatically redirects unauthenticated users to log in at their provider\u2019s authorization endpoint. Supports token refreshing and stores access and refresh tokens in an encrypted cookie. Supports credential rotation for the OAuth2 client ID and secret.</p> <p>The filter consumes and drops the grant token request cookie to prevent it from leaking to untrusted downstream services.</p> <p>The filter will inject the OAuth2 bearer token into the request headers if the flag <code>oauth2-access-token-header-name</code> is set.</p> <p>The filter must be used in conjunction with the grantCallback filter where the OAuth2 provider can redirect authenticated users with an authorization code. Skipper will make sure to add the <code>grantCallback</code> filter for you to your routes when you pass the <code>-enable-oauth2-grant-flow</code> flag.</p> <p>The filter may be used with the grantClaimsQuery filter to perform authz and access control.</p> <p>The filter also supports javascript login redirect stub that can be used e.g. to store location hash. To enable the stub, add preceding annotate filter with <code>oauthGrant.loginRedirectStub</code> key and content that will be served to the client with <code>200 OK</code> status instead of <code>307 Temporary Redirect</code> to the authorization URL. The filter will replace <code>{authCodeURL}</code> (and <code>{{authCodeURL}}</code>) placeholders in the content with the actual authorization URL and add <code>X-Auth-Code-Url</code> response header with the same value.</p> <p>See the tutorial for step-by-step instructions.</p> <p>Examples:</p> <pre><code>all:\n    *\n    -&gt; oauthGrant()\n    -&gt; \"http://localhost:9090\";\n</code></pre> <pre><code>single_page_app:\n    *\n    -&gt; annotate(\"oauthGrant.loginRedirectStub\", `\n          &lt;!doctype html&gt;\n          &lt;html lang=\"en\"&gt;\n            &lt;head&gt;\n              &lt;title&gt;Redirecting...&lt;/title&gt;\n              &lt;script&gt;\n                if (window.location.hash !== null) {\n                  localStorage.setItem('original-location-hash', window.location.hash);\n                }\n                window.location.replace('{authCodeURL}');\n              &lt;/script&gt;\n            &lt;/head&gt;\n          &lt;/html&gt;\n    `)\n    -&gt; oauthGrant()\n    -&gt; \"http://localhost:9090\";\n</code></pre> <p>Skipper arguments:</p> Argument Required? Description <code>-enable-oauth2-grant-flow</code> yes toggle flag to enable the <code>oauthGrant()</code> filter. Must be set if you use the filter in routes. Example: <code>-enable-oauth2-grant-flow</code> <code>-oauth2-auth-url</code> yes URL of the OAuth2 provider\u2019s authorize endpoint. Example: <code>-oauth2-auth-url=https://identity.example.com/oauth2/authorize</code> <code>-oauth2-token-url</code> yes URL of the OAuth2 provider\u2019s token endpoint. Example: <code>-oauth2-token-url=https://identity.example.com/oauth2/token</code> <code>-oauth2-tokeninfo-url</code> yes URL of the OAuth2 provider\u2019s tokeninfo endpoint. Example: <code>-oauth2-tokeninfo-url=https://identity.example.com/oauth2/tokeninfo</code> <code>-oauth2-secret-file</code> yes path to the file containing the secret for encrypting and decrypting the grant token cookie (the secret can be anything). Example: <code>-oauth2-secret-file=/path/to/secret</code> <code>-oauth2-client-id-file</code> conditional path to the file containing the OAuth2 client ID. Required if you have not set <code>-oauth2-client-id</code>. Example: <code>-oauth2-client-id-file=/path/to/client_id</code> <code>-oauth2-client-secret-file</code> conditional path to the file containing the OAuth2 client secret. Required if you have not set <code>-oauth2-client-secret</code>. Example: <code>-oauth2-client-secret-file=/path/to/client_secret</code> <code>-oauth2-client-id</code> conditional OAuth2 client ID for authenticating with your OAuth2 provider. Required if you have not set <code>-oauth2-client-id-file</code> or <code>OAUTH2_CLIENT_ID</code> env variable. Example: <code>-oauth2-client-id=myclientid</code> <code>-oauth2-client-secret</code> conditional OAuth2 client secret for authenticating with your OAuth2 provider. Required if you have not set <code>-oauth2-client-secret-file</code> or <code>OAUTH2_CLIENT_SECRET</code> env variable. Example: <code>-oauth2-client-secret=myclientsecret</code> <code>-credentials-update-interval</code> no the time interval for updating client id and client secret from files. Example: <code>-credentials-update-interval=30s</code> <code>-oauth2-access-token-header-name</code> no the name of the request header where the user\u2019s bearer token should be set. Example: <code>-oauth2-access-token-header-name=X-Grant-Authorization</code> <code>-oauth2-grant-tokeninfo-keys</code> no comma separated list of keys to preserve in OAuth2 Grant Flow tokeninfo. Default: empty, preserves all tokeninfo keys. Example: <code>-oauth2-grant-tokeninfo-keys=scope,realm,expires_in</code> <code>-oauth2-auth-url-parameters</code> no any additional URL query parameters to set for the OAuth2 provider\u2019s authorize and token endpoint calls. Example: <code>-oauth2-auth-url-parameters=key1=foo,key2=bar</code> <code>-oauth2-callback-path</code> no path of the Skipper route containing the <code>grantCallback()</code> filter for accepting an authorization code and using it to get an access token. Example: <code>-oauth2-callback-path=/oauth/callback</code> <code>-oauth2-token-cookie-name</code> no the name of the cookie where the access tokens should be stored in encrypted form. Default: <code>oauth-grant</code>. Example: <code>-oauth2-token-cookie-name=SESSION</code> <code>-oauth2-token-cookie-remove-subdomains</code> no the number of subdomains to remove from the callback request hostname to obtain token cookie domain. Default: <code>1</code>. Example: <code>-oauth2-token-cookie-remove-subdomains=0</code> <code>-oauth2-grant-insecure</code> no omits <code>Secure</code> attribute of the token cookie and uses <code>http</code> scheme for callback url. Default: <code>false</code>"},{"location":"reference/filters/#grantcallback","title":"grantCallback","text":"<p>The filter accepts authorization codes as a result of an OAuth2 authorization code grant flow triggered by oauthGrant. It uses the code to request access and refresh tokens from the OAuth2 provider\u2019s token endpoint.</p> <p>Examples:</p> <pre><code>// The callback route is automatically added when the `-enable-oauth2-grant-flow`\n// flag is passed. You do not need to register it yourself. This is the equivalent\n// of the route that Skipper adds for you:\ncallback:\n    Path(\"/.well-known/oauth2-callback\")\n    -&gt; grantCallback()\n    -&gt; &lt;shunt&gt;;\n</code></pre> <p>Skipper arguments:</p> Argument Required? Description <code>-oauth2-callback-path</code> no path of the Skipper route containing the <code>grantCallback()</code> filter. Example: <code>-oauth2-callback-path=/oauth/callback</code>"},{"location":"reference/filters/#grantlogout","title":"grantLogout","text":"<p>The filter revokes the refresh and access tokens in the cookie set by oauthGrant if <code>-oauth2-revoke-token-url</code> is configured. It also deletes the cookie by setting the <code>Set-Cookie</code> response header to an empty value after a successful token revocation.</p> <p>Examples:</p> <pre><code>grantLogout()\n</code></pre> <p>Skipper arguments:</p> Argument Required? Description <code>-oauth2-revoke-token-url</code> no URL of the OAuth2 provider\u2019s token revocation endpoint. Example: <code>-oauth2-revoke-token-url=https://identity.example.com/oauth2/revoke</code>"},{"location":"reference/filters/#grantclaimsquery","title":"grantClaimsQuery","text":"<p>The filter allows defining access control rules based on claims in a tokeninfo JSON payload.</p> <p>This filter is an alias for <code>oidcClaimsQuery</code> and functions identically to it. See oidcClaimsQuery for more information.</p> <p>Examples:</p> <pre><code>oauthGrant() -&gt; grantClaimsQuery(\"/path:@_:sub%\\\"userid\\\"\")\noauthGrant() -&gt; grantClaimsQuery(\"/path:scope.#[==\\\"email\\\"]\")\n</code></pre> <p>Skipper arguments:</p> Argument Required? Description <code>-oauth2-tokeninfo-subject-key</code> yes the key of the attribute containing the OAuth2 subject ID in the OAuth2 provider\u2019s tokeninfo JSON payload. Default: <code>uid</code>. Example: <code>-oauth2-tokeninfo-subject-key=sub</code>"},{"location":"reference/filters/#openid-connect","title":"OpenID Connect","text":"<p>To enable OpenID Connect filters use <code>-oidc-secrets-file</code> command line flag.</p>"},{"location":"reference/filters/#oauthoidcuserinfo","title":"oauthOidcUserInfo","text":"<pre><code>oauthOidcUserInfo(\"https://oidc-provider.example.com\", \"client_id\", \"client_secret\",\n    \"http://target.example.com/subpath/callback\", \"email profile\", \"name email picture\",\n    \"parameter=value\", \"X-Auth-Authorization:claims.email\", \"0\")\n</code></pre> <p>The filter needs the following parameters:</p> <ul> <li>OpenID Connect Provider URL For example Google OpenID Connect is available on <code>https://accounts.google.com</code></li> <li>Client ID This value is obtained from the provider upon registration of the application. Falls back to<code>OIDC_CLIENT_ID</code> env variable for empty value.</li> <li>Client Secret  Also obtained from the provider. Falls back to <code>OIDC_CLIENT_SECRET</code> env variable for empty value.</li> <li>Callback URL The entire path to the callback from the provider on which the token will be received.     It can be any value which is a subpath on which the filter is applied.</li> <li>Scopes The OpenID scopes separated by spaces which need to be specified when requesting the token from the provider.</li> <li>Claims The claims which should be present in the token returned by the provider.</li> <li>Auth Code Options (optional) Passes key/value parameters to a provider\u2019s authorization endpoint. The value can be dynamically set by a query parameter with the same key name if the placeholder <code>skipper-request-query</code> is used.</li> <li>Upstream Headers (optional) The upstream endpoint will receive these headers which values are parsed from the OIDC information. The header definition can be one or more header-query pairs, space delimited. The query syntax is GJSON.</li> <li>SubdomainsToRemove (optional, default \u201c1\u201d) Configures number of subdomains to remove from the request hostname to derive OIDC cookie domain. By default one subdomain is removed, e.g. for the www.example.com request hostname the OIDC cookie domain will be example.com (to support SSO for all subdomains of the example.com). Configure \u201c0\u201d to use the same hostname. Note that value is a string.</li> <li>Custom Cookie Name (optional) Defines a constant cookie name generated by the OIDC filter. By default the cookie name is SkipperOauthOidc{hash}, where {hash} is a generated value.</li> </ul> <p>Skipper arguments:</p> Argument Required? Description <code>-oidc-cookie-remove-subdomains</code> no Default number of subdomains to remove from the request hostname to derive OIDC cookie domain. The filter parameter overwrites the default when provided. Default: <code>1</code>. Example: <code>-oidc-cookie-remove-subdomains=\"0\"</code>"},{"location":"reference/filters/#oauthoidcanyclaims","title":"oauthOidcAnyClaims","text":"<pre><code>oauthOidcAnyClaims(\"https://oidc-provider.example.com\", \"client_id\", \"client_secret\",\n    \"http://target.example.com/subpath/callback\", \"email profile\", \"name email picture\",\n    \"parameter=value\", \"X-Auth-Authorization:claims.email\")\n</code></pre> <p>The filter needs the following parameters:</p> <ul> <li>OpenID Connect Provider URL For example Google OpenID Connect is available on <code>https://accounts.google.com</code></li> <li>Client ID This value is obtained from the provider upon registration of the application.</li> <li>Client Secret  Also obtained from the provider</li> <li>Callback URL The entire path to the callback from the provider on which the token will be received.     It can be any value which is a subpath on which the filter is applied.</li> <li>Scopes The OpenID scopes separated by spaces which need to be specified when requesting the token from the provider.</li> <li>Claims Several claims can be specified and the request is allowed as long as at least one of them is present.</li> <li>Auth Code Options (optional) Passes key/value parameters to a provider\u2019s authorization endpoint. The value can be dynamically set by a query parameter with the same key name if the placeholder <code>skipper-request-query</code> is used.</li> <li>Upstream Headers (optional) The upstream endpoint will receive these headers which values are parsed from the OIDC information. The header definition can be one or more header-query pairs, space delimited. The query syntax is GJSON.</li> <li>SubdomainsToRemove (optional, default \u201c1\u201d) Configures number of subdomains to remove from the request hostname to derive OIDC cookie domain. By default one subdomain is removed, e.g. for the www.example.com request hostname the OIDC cookie domain will be example.com (to support SSO for all subdomains of the example.com). Configure \u201c0\u201d to use the same hostname. Note that value is a string.</li> </ul> <p>Skipper arguments:</p> Argument Required? Description <code>-oidc-cookie-remove-subdomains</code> no Default number of subdomains to remove from the request hostname to derive OIDC cookie domain. The filter parameter overwrites the default when provided. Default: <code>1</code>. Example: <code>-oidc-cookie-remove-subdomains=\"0\"</code>"},{"location":"reference/filters/#oauthoidcallclaims","title":"oauthOidcAllClaims","text":"<pre><code>oauthOidcAllClaims(\"https://oidc-provider.example.com\", \"client_id\", \"client_secret\",\n    \"http://target.example.com/subpath/callback\", \"email profile\", \"name email picture\",\n    \"parameter=value\", \"X-Auth-Authorization:claims.email\")\n</code></pre> <p>The filter needs the following parameters:</p> <ul> <li>OpenID Connect Provider URL For example Google OpenID Connect is available on <code>https://accounts.google.com</code></li> <li>Client ID This value is obtained from the provider upon registration of the application.</li> <li>Client Secret  Also obtained from the provider</li> <li>Callback URL The entire path to the callback from the provider on which the token will be received.     It can be any value which is a subpath on which the filter is applied.</li> <li>Scopes The OpenID scopes separated by spaces which need to be specified when requesting the token from the provider.</li> <li>Claims Several claims can be specified and the request is allowed only when all claims are present.</li> <li>Auth Code Options (optional) Passes key/value parameters to a provider\u2019s authorization endpoint. The value can be dynamically set by a query parameter with the same key name if the placeholder <code>skipper-request-query</code> is used.</li> <li>Upstream Headers (optional) The upstream endpoint will receive these headers which values are parsed from the OIDC information. The header definition can be one or more header-query pairs, space delimited. The query syntax is GJSON.</li> <li>SubdomainsToRemove (optional, default \u201c1\u201d) Configures number of subdomains to remove from the request hostname to derive OIDC cookie domain. By default one subdomain is removed, e.g. for the www.example.com request hostname the OIDC cookie domain will be example.com (to support SSO for all subdomains of the example.com). Configure \u201c0\u201d to use the same hostname. Note that value is a string.</li> </ul> <p>Skipper arguments:</p> Argument Required? Description <code>-oidc-cookie-remove-subdomains</code> no Default number of subdomains to remove from the request hostname to derive OIDC cookie domain. The filter parameter overwrites the default when provided. Default: <code>1</code>. Example: <code>-oidc-cookie-remove-subdomains=\"0\"</code>"},{"location":"reference/filters/#oidcclaimsquery","title":"oidcClaimsQuery","text":"<pre><code>oidcClaimsQuery(\"&lt;path&gt;:[&lt;query&gt;]\", ...)\n</code></pre> <p>The filter is chained after <code>oauthOidc*</code> authentication as it parses the ID token that has been saved in the internal <code>StateBag</code> for this request. It validates access control of the requested path against the defined query. It accepts one or more arguments, that is a path prefix which is granted access to when the query definition evaluates positive. It supports exact matches of keys, key-value pairs, introspecting of arrays or exact and wildcard matching of nested structures. The query definition can be one or more queries per path, space delimited. The query syntax is GJSON with a convenience modifier of <code>@_</code> which unfolds to <code>[@this].#(\"+arg+\")</code></p> <p>Given following example ID token:</p> <pre><code>{\n  \"email\": \"someone@example.org\",\n  \"groups\": [\n    \"CD-xyz\",\n    \"appX-Test-Users\",\n    \"Purchasing-Department\"\n  ],\n  \"name\": \"Some One\"\n}\n</code></pre> <p>Access to path <code>/</code> would be granted to everyone in <code>example.org</code>, however path <code>/login</code> only to those being member of <code>group \"appX-Tester\"</code>:</p> <pre><code>oauthOidcAnyClaims(...) -&gt; oidcClaimsQuery(\"/login:groups.#[==\\\"appX-Tester\\\"]\", \"/:@_:email%\\\"*@example.org\\\"\")\n</code></pre> <p>For above ID token following query definitions would also be positive:</p> <pre><code>oidcClaimsQuery(\"/:email\")\noidcClaimsQuery(\"/another/path:groups.#[%\\\"CD-*\\\"]\")\noidcClaimsQuery(\"/:name%\\\"*One\\\"\", \"/path:groups.#[%\\\"*-Test-Users\\\"] groups.#[==\\\"Purchasing-Department\\\"]\")\n</code></pre> <p>As of now there is no negative/deny rule possible. The first matching path is evaluated against the defined query/queries and if positive, permitted.</p>"},{"location":"reference/filters/#open-policy-agent","title":"Open Policy Agent","text":"<p>To get started with Open Policy Agent, also have a look at the tutorial. This section is only a reference for the implemented filters.</p>"},{"location":"reference/filters/#opaauthorizerequest","title":"opaAuthorizeRequest","text":"<p>The canonical use case that is also implemented with Envoy External Authorization: Use the http request to evaluate if Skipper should deny the request (with customizable response) or let the request pass to the downstream service</p> <p>Example:</p> <pre><code>opaAuthorizeRequest(\"my-app-id\")\n</code></pre> <p>Example (passing context): <pre><code>opaAuthorizeRequest(\"my-app-id\", \"com.mydomain.xxx.myprop: myvalue\")\n</code></pre></p> <p>Data Flows</p> <p>The data flow when the policy allows the request looks like this</p> <pre><code>             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n (1) Request \u2502     Skipper      \u2502 (4) Request   \u2502 Target Application \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                    \u2502\n             \u2502                  \u2502               \u2502                    \u2502\n (6) Response\u2502   (2)\u2502   \u25b2 (3)   \u2502 (5) Response  \u2502                    \u2502\n\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524Req -&gt;\u2502   \u2502 allow \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                    \u2502\n             \u2502Input \u2502   \u2502       \u2502               \u2502                    \u2502\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502Open Policy Agent \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u25bc   \u2502       \u2502\n             \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n             \u2502 \u2502   Policy     \u2502 \u2502\n             \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n             \u2502                  \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In Step (2) the http request is transformed into an input object following the Envoy structure that is also used by the OPA Envoy plugin. In (3) the decision of the policy is evaluated. If it is equivalent to an \u201callow\u201d, the remaining steps are executed as without the filter.</p> <p>The data flow when the policy disallows the request looks like this</p> <pre><code>             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n (1) Request \u2502     Skipper      \u2502               \u2502 Target Application \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                    \u2502\n             \u2502                  \u2502               \u2502                    \u2502\n (4) Response\u2502   (2)\u2502   \u25b2 (3)   \u2502               \u2502                    \u2502\n\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524Req -&gt;\u2502   \u2502 allow \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                    \u2502\n             \u2502Input \u2502   \u2502 =false\u2502               \u2502                    \u2502\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502Open Policy Agent \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u25bc   \u2502       \u2502\n             \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n             \u2502 \u2502   Policy     \u2502 \u2502\n             \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n             \u2502                  \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The difference is that if the decision in (3) is equivalent to false, the response is handled directly from the filter. If the decision contains response body, status or headers those are used to build the response in (6) otherwise a 403 Forbidden with a generic body is returned.</p> <p>Manipulating Request Headers</p> <p>Headers both to the upstream and the downstream service can be manipulated the same way this works for Envoy external authorization</p> <p>This allows both to add and remove unwanted headers in allow/deny cases.</p>"},{"location":"reference/filters/#opaauthorizerequestwithbody","title":"opaAuthorizeRequestWithBody","text":"<p>Requests can also be authorized based on the request body the same way that is supported with the Open Policy Agent Envoy plugin, look for the input attribute <code>parsed_body</code> in the upstream documentation.</p> <p>This filter has the same parameters that the <code>opaAuthorizeRequest</code> filter has.</p> <p>A request\u2019s body is parsed up to a maximum size with a default of 1MB that can be configured via the <code>-open-policy-agent-max-request-body-size</code> command line argument. To avoid OOM errors due to too many concurrent authorized body requests, another flag <code>-open-policy-agent-max-memory-body-parsing</code> controls how much memory can be used across all requests with a default of 100MB. If in-flight requests that use body authorization exceed that limit, incoming requests that use the body will be rejected with an internal server error. The number of concurrent requests is</p> \\[ n_{max-memory-body-parsing} \\over min(avg(n_{request-content-length}), n_{max-request-body-size}) \\] <p>so if requests on average have 100KB and the maximum memory is set to 100MB, on average 1024 authorized requests can be processed concurrently.</p> <p>The filter also honors the <code>skip-request-body-parse</code> of the corresponding configuration that the OPA plugin uses.</p>"},{"location":"reference/filters/#opaserveresponse","title":"opaServeResponse","text":"<p>Always serves the response even if the policy allows the request and can customize the response completely. Can be used to re-implement legacy authorization services by already using data in Open Policy Agent but implementing an old REST API. This can also be useful to support Single Page Applications to return the calling users\u2019 permissions.</p> <p>Hint: As there is no real allow/deny in this case and the policy computes the http response, you typically will want to drop all decision logs</p> <p>Example:</p> <pre><code>opaServeResponse(\"my-app-id\")\n</code></pre> <p>Example (passing context): <pre><code>opaServeResponse(\"my-app-id\", \"com.mydomain.xxx.myprop: myvalue\")\n</code></pre></p> <p>Data Flows</p> <p>For this filter, the data flow looks like this independent of an allow/deny decision</p> <pre><code>             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n (1) Request \u2502     Skipper      \u2502\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                  \u251c\n             \u2502                  \u2502\n (4) Response\u2502   (2)\u2502   \u25b2 (3)   \u2502\n\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524Req -&gt;\u2502   \u2502 resp  \u2502\n             \u2502Input \u2502   \u2502       \u2502\n             \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n             \u2502Open Policy Agent \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u2502   \u2502       \u2502\n             \u2502      \u25bc   \u2502       \u2502\n             \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n             \u2502 \u2502   Policy     \u2502 \u2502\n             \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n             \u2502                  \u2502\n             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/filters/#opaserveresponsewithreqbody","title":"opaServeResponseWithReqBody","text":"<p>If you want to serve requests directly from an Open Policy Agent policy that uses the request body, this can be done by using the <code>input.parsed_body</code> attribute the same way that is supported with the Open Policy Agent Envoy plugin.</p> <p>This filter has the same parameters that the <code>opaServeResponse</code> filter has.</p> <p>A request\u2019s body is parsed up to a maximum size with a default of 1MB that can be configured via the <code>-open-policy-agent-max-request-body-size</code> command line argument. To avoid OOM errors due to too many concurrent authorized body requests, another flag <code>-open-policy-agent-max-memory-body-parsing</code> controls how much memory can be used across all requests with a default of 100MB. If  in-flight requests that use body authorization exceed that limit, incoming requests that use the body will be rejected with an internal server error. The number of concurrent requests is</p> \\[ n_{max-memory-body-parsing} \\over min(avg(n_{request-content-length}), n_{max-request-body-size}) \\] <p>so if requests on average have 100KB and the maximum memory is set to 100MB, on average 1024 authorized requests can be processed concurrently.</p> <p>The filter also honors the <code>skip-request-body-parse</code> of the corresponding configuration that the OPA plugin uses.</p>"},{"location":"reference/filters/#awssigv4","title":"awsSigv4","text":"<p>This filter signs request using AWS Sig V4 algorithm. The requests must provide following headers in order for this filter to generate a valid signature.</p> <ul> <li><code>x-amz-accesskey</code>  header must contain a valid AWS access key</li> <li><code>x-amz-secret</code> header must contain a valid secret for AWS client being used.</li> <li><code>x-amz-time</code> header must contain the time in RFC3339 format which this filter can use to generate signature and <code>X-Amz-Date</code> header on signed request. This time stamp is considered as the time stamp of generated signature.</li> <li><code>x-amz-session</code> must contain valid AWS session token (see) to be set as <code>X-Amz-Security-Token</code> in signed request when <code>DisableSessionToken</code> parameter defined on route is set to false.</li> </ul> <p>Filter removes these headers after reading the values. Once the signature is generated, it is appended to existing Authorization header or if there is no Authorization header, added as new and forwarded to AWS service.</p> <p>awsSigv4 filter can be defined on a route as <code>awsSigv4(\"&lt;service&gt;, \"&lt;region&gt;\", &lt;DisableHeaderHoisting&gt;, &lt;DisableURIPathEscaping&gt;, &lt;DisableSessionToken&gt;)</code></p> <p>An example of route with awsSigv4 filter is     <code>editorRoute: * -&gt; awsSigv4(\"dynamodb\" , \"us-east-1\", \"false\", \"false\", \"false\") -&gt; \"https://dynamodb.us-east-1.amazonaws.com\";</code></p> <p>This filter expects:</p> <ul> <li> <p><code>Service</code> An aws service name. Please refer valid service names from service endpoint.         For example if service endpoint is https://dynamodb.us-east-1.amazonaws.com, then service is dynamodb</p> </li> <li> <p><code>Region</code> AWS region where service is located. Please refer valid service names from service endpoint.         For example if service endpoint is https://dynamodb.us-east-1.amazonaws.com, then region is us-east-1.</p> </li> <li> <p><code>DisableHeaderHoisting</code> Disables the Signer\u2019s moving HTTP header key/value pairs from the HTTP request header to the request\u2019s query string. This is most commonly used         with pre-signed requests preventing headers from being added to the request\u2019s query string.</p> </li> <li> <p><code>DisableURIPathEscaping</code> Disables the automatic escaping of the URI path of the request for the signature\u2019s canonical string\u2019s path. For services that do not need additional         escaping then use this to disable the signer escaping the path. S3 is an example of a service that does not need additional escaping.         http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html</p> </li> <li> <p><code>DisableSessionToken</code> Disables setting the session token on the request as part of signing through X-Amz-Security-Token. This is needed for variations of v4 that         present the token elsewhere.</p> </li> </ul>"},{"location":"reference/filters/#memory-consideration","title":"Memory consideration","text":"<p>This filter reads the body in memory. This is needed to generate signature as per Signature V4 specs. Special considerations need to be taken when operating the skipper with concurrent requests.</p>"},{"location":"reference/filters/#overwriting-ioreadcloser","title":"Overwriting io.ReadCloser","text":"<p>This filter resets <code>read</code> and <code>close</code> implementations of body to default. So when a filter before this filter has some custom implementations of these methods, they would be overwritten.</p>"},{"location":"reference/filters/#cookie-handling","title":"Cookie Handling","text":""},{"location":"reference/filters/#droprequestcookie","title":"dropRequestCookie","text":"<p>Deletes given cookie from the request header.</p> <p>Parameters:</p> <ul> <li>cookie name (string)</li> </ul> <p>Example:</p> <pre><code>dropRequestCookie(\"test-session\")\n</code></pre>"},{"location":"reference/filters/#dropresponsecookie","title":"dropResponseCookie","text":"<p>Deletes given cookie from the response header.</p> <p>Parameters:</p> <ul> <li>cookie name (string)</li> </ul> <p>Example:</p> <pre><code>dropResponseCookie(\"test-session\")\n</code></pre>"},{"location":"reference/filters/#requestcookie","title":"requestCookie","text":"<p>Append a cookie to the request header.</p> <p>Parameters:</p> <ul> <li>cookie name (string)</li> <li>cookie value (string)</li> </ul> <p>Example:</p> <pre><code>requestCookie(\"test-session\", \"abc\")\n</code></pre>"},{"location":"reference/filters/#responsecookie","title":"responseCookie","text":"<p>Appends a cookie to the response via \u201cSet-Cookie\u201d header. It derives cookie domain by removing one subdomain from the request hostname domain. The filter accepts an optional argument to set the <code>Max-Age</code> attribute of the cookie, of type <code>int</code>, in seconds. Use zero to expire the cookie immediately. An optional fourth argument, \u201cchange-only\u201d, controls if the cookie should be set on every response, or only if the request does not contain a cookie with the provided name and value.</p> <p>Example:</p> <pre><code>responseCookie(\"test-session\", \"abc\")\nresponseCookie(\"test-session\", \"abc\", 31536000),\nresponseCookie(\"test-session\", \"abc\", 31536000, \"change-only\")\nresponseCookie(\"test-session\", \"deleted\", 0),\n</code></pre>"},{"location":"reference/filters/#jscookie","title":"jsCookie","text":"<p>The JS cookie behaves exactly as the response cookie, but it does not set the <code>HttpOnly</code> directive, so these cookies will be accessible from JS code running in web browsers.</p> <p>Example:</p> <pre><code>jsCookie(\"test-session-info\", \"abc-debug\", 31536000, \"change-only\")\n</code></pre>"},{"location":"reference/filters/#circuit-breakers","title":"Circuit Breakers","text":""},{"location":"reference/filters/#consecutivebreaker","title":"consecutiveBreaker","text":"<p>This breaker opens when the proxy could not connect to a backend or received a &gt;=500 status code at least N times in a row. When open, the proxy returns 503 - Service Unavailable response during the breaker timeout. After this timeout, the breaker goes into half-open state, in which it expects that M number of requests succeed. The requests in the half-open state are accepted concurrently. If any of the requests during the half-open state fails, the breaker goes back to open state. If all succeed, it goes to closed state again.</p> <p>Parameters:</p> <ul> <li>number of consecutive failures to open (int)</li> <li>timeout (time string, parsable by time.Duration) - optional</li> <li>half-open requests (int) - optional</li> <li>idle-ttl (time string, parsable by time.Duration) - optional</li> </ul> <p>See also the circuit breaker docs.</p> <p>Can be used as egress feature.</p>"},{"location":"reference/filters/#ratebreaker","title":"rateBreaker","text":"<p>The \u201crate breaker\u201d works similar to the consecutiveBreaker, but instead of considering N consecutive failures for going open, it maintains a sliding window of the last M events, both successes and failures, and opens only when the number of failures reaches N within the window. This way the sliding window is not time based and allows the same breaker characteristics for high and low rate traffic.</p> <p>Parameters:</p> <ul> <li>number of consecutive failures to open (int)</li> <li>sliding window (int)</li> <li>timeout (time string, parsable by time.Duration) - optional</li> <li>half-open requests (int) - optional</li> <li>idle-ttl (time string, parsable by time.Duration) - optional</li> </ul> <p>See also the circuit breaker docs.</p> <p>Can be used as egress feature.</p>"},{"location":"reference/filters/#disablebreaker","title":"disableBreaker","text":"<p>Change (or set) the breaker configurations for an individual route and disable for another, in eskip:</p> <pre><code>updates: Method(\"POST\") &amp;&amp; Host(\"foo.example.org\")\n  -&gt; consecutiveBreaker(9)\n  -&gt; \"https://foo.backend.net\";\n\nbackendHealthcheck: Path(\"/healthcheck\")\n  -&gt; disableBreaker()\n  -&gt; \"https://foo.backend.net\";\n</code></pre> <p>See also the circuit breaker docs.</p> <p>Can be used as egress feature.</p>"},{"location":"reference/filters/#rate-limit","title":"Rate Limit","text":""},{"location":"reference/filters/#localratelimit","title":"localRatelimit","text":"<p>DEPRECATED use clientRatelimit with the same   settings instead.</p>"},{"location":"reference/filters/#clientratelimit","title":"clientRatelimit","text":"<p>Per skipper instance calculated ratelimit, that allows number of requests by client. The definition of the same client is based on data of the http header and can be changed with an optional third parameter. If the third parameter is set skipper will use the defined HTTP header to put the request in the same client bucket, else the X-Forwarded-For Header will be used. You need to run skipper with command line flag <code>-enable-ratelimits</code>.</p> <p>One filter consumes memory calculated by the following formula, where N is the number of individual clients put into the same bucket, M the maximum number of requests allowed:</p> <pre><code>memory = N * M * 15 byte\n</code></pre> <p>Memory usage examples:</p> <ul> <li>5MB   for M=3  and N=100000</li> <li>15MB  for M=10 and N=100000</li> <li>150MB for M=100 and N=100000</li> </ul> <p>Parameters:</p> <ul> <li>number of allowed requests per time period (int)</li> <li>time period for requests being counted (time.Duration)</li> <li>optional parameter to set the same client by header, if the provided string contains <code>,</code>, it will combine all these headers (string)</li> </ul> <pre><code>clientRatelimit(3, \"1m\")\nclientRatelimit(3, \"1m\", \"Authorization\")\nclientRatelimit(3, \"1m\", \"X-Foo,Authorization,X-Bar\")\n</code></pre> <p>See also the ratelimit docs.</p>"},{"location":"reference/filters/#ratelimit","title":"ratelimit","text":"<p>Per skipper instance calculated ratelimit, that allows forwarding a number of requests to the backend group. You need to run skipper with command line flag <code>-enable-ratelimits</code>.</p> <p>Parameters:</p> <ul> <li>number of allowed requests per time period (int)</li> <li>time period for requests being counted (time.Duration)</li> <li>response status code to use for a rate limited request - optional, default: 429</li> </ul> <pre><code>ratelimit(20, \"1m\")\nratelimit(300, \"1h\")\nratelimit(4000, \"1m\", 503)\n</code></pre> <p>See also the ratelimit docs.</p>"},{"location":"reference/filters/#clusterclientratelimit","title":"clusterClientRatelimit","text":"<p>This ratelimit is calculated across all skipper peers and the same rate limit group. The first parameter is a string to select the same ratelimit group across one or more routes. The rate limit group allows the given number of requests by client. The client identity is derived from the value of the <code>X-Forwarded-For</code> header or client IP address and can be changed with an optional fourth parameter. The optional fourth parameter may specify comma-separated list of header names. Skipper will join header values to obtain client identity. If identity value is empty (i.e. when all header values are empty or missing) then ratelimit does not apply.</p> <p>You need to run skipper with command line flags <code>-enable-swarm</code> and <code>-enable-ratelimits</code>. See also our cluster ratelimit tutorial</p> <p>Parameters:</p> <ul> <li>rate limit group (string)</li> <li>number of allowed requests per time period (int)</li> <li>time period for requests being counted (time.Duration)</li> <li>optional parameter to set the same client by header, if the provided string contains <code>,</code>, it will combine all these headers (string)</li> </ul> <pre><code>clusterClientRatelimit(\"groupA\", 10, \"1h\")\nclusterClientRatelimit(\"groupA\", 10, \"1h\", \"Authorization\")\nclusterClientRatelimit(\"groupA\", 10, \"1h\", \"X-Forwarded-For,Authorization,User-Agent\")\n</code></pre> <p>See also the ratelimit docs.</p>"},{"location":"reference/filters/#clusterratelimit","title":"clusterRatelimit","text":"<p>This ratelimit is calculated across all skipper peers and the same rate limit group. The first parameter is a string to select the same ratelimit group across one or more routes.  The rate limit group allows the given number of requests to a backend.</p> <p>You need to run skipper with command line flags <code>-enable-swarm</code> and <code>-enable-ratelimits</code>. See also our cluster ratelimit tutorial</p> <p>Parameters:</p> <ul> <li>rate limit group (string)</li> <li>number of allowed requests per time period (int)</li> <li>time period for requests being counted (time.Duration)</li> <li>response status code to use for a rate limited request - optional, default: 429</li> </ul> <pre><code>clusterRatelimit(\"groupA\", 20, \"1m\")\nclusterRatelimit(\"groupB\", 300, \"1h\")\nclusterRatelimit(\"groupC\", 4000, \"1m\", 503)\n</code></pre> <p>Multiple filter definitions using the same group must use the same number of allowed requests and timeframe values.</p> <p>See also the ratelimit docs.</p>"},{"location":"reference/filters/#backendratelimit","title":"backendRatelimit","text":"<p>The filter configures request rate limit for each backend endpoint within rate limit group across all Skipper peers. When limit is reached Skipper refuses to forward the request to the backend and responds with <code>503 Service Unavailable</code> status to the client, i.e. implements load shedding.</p> <p>It is similar to clusterClientRatelimit filter but counts request rate using backend endpoint address instead of incoming request IP address or a HTTP header. Requires command line flags <code>-enable-swarm</code> and <code>-enable-ratelimits</code>.</p> <p>Both rate limiting and load shedding can use the exact same mechanism to protect the backend but the key difference is the semantics:</p> <ul> <li>rate limiting should adopt 4XX and inform the client that they are exceeding some quota. It doesn\u2019t depend on the current capacity of the backend.</li> <li>load shedding should adopt 5XX and inform the client that the backend is not able to provide the service. It depends on the current capacity of the backend.</li> </ul> <p>Parameters:</p> <ul> <li>rate limit group (string)</li> <li>number of allowed requests per time period (int)</li> <li>timeframe for requests being counted (time.Duration)</li> <li>response status code to use for rejected requests - optional, default: 503</li> </ul> <p>Multiple filter definitions using the same group must use the same number of allowed requests and timeframe values.</p> <p>Examples:</p> <p><pre><code>foo: Path(\"/foo\")\n  -&gt; backendRatelimit(\"foobar\", 100, \"1s\")\n  -&gt; &lt;\"http://backend1\", \"http://backend2\"&gt;;\n\nbar: Path(\"/bar\")\n  -&gt; backendRatelimit(\"foobar\", 100, \"1s\")\n  -&gt; &lt;\"http://backend1\", \"http://backend2\"&gt;;\n</code></pre> Configures rate limit of 100 requests per second for each <code>backend1</code> and <code>backend2</code> regardless of the request path by using the same group name, number of request and timeframe parameters.</p> <p><pre><code>foo: Path(\"/foo\")\n  -&gt; backendRatelimit(\"foo\", 40, \"1s\")\n  -&gt; &lt;\"http://backend1\", \"http://backend2\"&gt;;\n\nbar: Path(\"/bar\")\n  -&gt; backendRatelimit(\"bar\", 80, \"1s\")\n  -&gt; &lt;\"http://backend1\", \"http://backend2\"&gt;;\n</code></pre> Configures rate limit of 40 requests per second for each <code>backend1</code> and <code>backend2</code> for the <code>/foo</code> requests and 80 requests per second for the <code>/bar</code> requests by using different group name per path. The total request rate each backend receives cannot exceed <code>40+80=120</code> requests per second.</p> <p><pre><code>foo: Path(\"/baz\")\n  -&gt; backendRatelimit(\"baz\", 100, \"1s\", 429)\n  -&gt; &lt;\"http://backend1\", \"http://backend2\"&gt;;\n</code></pre> Configures rate limit of 100 requests per second for each <code>backend1</code> and <code>backend2</code> and responds with <code>429 Too Many Requests</code> when limit is reached.</p>"},{"location":"reference/filters/#clusterleakybucketratelimit","title":"clusterLeakyBucketRatelimit","text":"<p>Implements leaky bucket rate limit algorithm that uses Redis as a storage. Requires command line flags <code>-enable-ratelimits</code>, <code>-enable-swarm</code> and <code>-swarm-redis-urls</code> to be set.</p> <p>The leaky bucket is an algorithm based on an analogy of how a bucket with a constant leak will overflow if either the average rate at which water is poured in exceeds the rate at which the bucket leaks or if more water than the capacity of the bucket is poured in all at once, see https://en.wikipedia.org/wiki/Leaky_bucket</p> <p>Parameters:</p> <ul> <li>label (string)</li> <li>leak rate volume (int)</li> <li>leak rate period (time.Duration)</li> <li>capacity (int)</li> <li>increment (int)</li> </ul> <p>The bucket label, leak rate (volume/period) and capacity uniquely identify the bucket.</p> <p>Label supports template placeholders. If a template placeholder can\u2019t be resolved then request is allowed and does not add to any bucket.</p> <p>Leak rate (divided by increment) defines a maximum average allowed request rate. The rate is configured by two parameters for convenience and consistency with other filters but is actually a single number, e.g. the rate of 2 per second equals the rate of 20 per 10 seconds or 120 per minute.</p> <p>Capacity defines the maximum request burst size or an allowed jitter.</p> <p>Each passing request adds increment amount to the bucket, different routes may add different amounts to the same bucket.</p> <p>Configuration with equal capacity and increment allows no jitter: first request fills up the bucket full and subsequent request will be rejected if it arrives earlier than <code>emission interval = 1/leak rate</code>.</p> <p>Real requests always have a jitter which can be demonstrated by the configuration having capacity and increment of one: <pre><code>r1: * -&gt; clusterLeakyBucketRatelimit(\"1rps\", 1, \"1s\", 1, 1) -&gt; status(200) -&gt; &lt;shunt&gt;;\n</code></pre> it does not allow jitter and therefore rejects ~half of the requests coming at rate of 1 rps: <pre><code>$ echo \"GET http://localhost:9090\" | vegeta attack -rate=1/s -duration=1m | vegeta report\nRequests      [total, rate, throughput]  60, 1.02, 0.58\nDuration      [total, attack, wait]      59.001991855s, 59.000310522s, 1.681333ms\nLatencies     [mean, 50, 95, 99, max]    1.721207ms, 1.555227ms, 1.943115ms, 10.689486ms, 11.538278ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              0, 0.00\nSuccess       [ratio]                    56.67%\nStatus Codes  [code:count]               200:34  429:26\nError Set:\n429 Too Many Requests\n</code></pre></p> <p>On the other hand the configuration with capacity greater than increment: <pre><code>r1: * -&gt; clusterLeakyBucketRatelimit(\"1rps2\", 1, \"1s\", 2, 1) -&gt; status(200) -&gt; &lt;shunt&gt;;\n</code></pre> allows all requests: <pre><code>~$ echo \"GET http://localhost:9090\" | vegeta attack -rate=1/s -duration=1m | vegeta report\nRequests      [total, rate, throughput]  60, 1.02, 1.02\nDuration      [total, attack, wait]      59.00023518s, 58.999779118s, 456.062\u00b5s\nLatencies     [mean, 50, 95, 99, max]    1.410641ms, 1.585908ms, 1.859727ms, 8.285963ms, 8.997149ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              0, 0.00\nSuccess       [ratio]                    100.00%\nStatus Codes  [code:count]               200:60\nError Set:\n</code></pre> and even if rate is greater than 1 rps the average allowed request rate is still equal to the leak rate of 1 rps: <pre><code>$ echo \"GET http://localhost:9090\" | vegeta attack -rate=11/10s -duration=1m | vegeta report\nRequests      [total, rate, throughput]  66, 1.12, 1.03\nDuration      [total, attack, wait]      59.091880389s, 59.089985762s, 1.894627ms\nLatencies     [mean, 50, 95, 99, max]    1.709568ms, 1.60613ms, 1.925731ms, 10.601822ms, 12.10052ms\nBytes In      [total, mean]              0, 0.00\nBytes Out     [total, mean]              0, 0.00\nSuccess       [ratio]                    92.42%\nStatus Codes  [code:count]               200:61  429:5\nError Set:\n429 Too Many Requests\n</code></pre></p> <p>Therefore the capacity should be configured greater than increment unless strict request interval needs to be enforced. Configuration having capacity below increment rejects all requests.</p> <p>Examples: <pre><code>// allow each unique Authorization header once in five seconds\nclusterLeakyBucketRatelimit(\"auth-${request.header.Authorization}\", 1, \"5s\", 2, 1)\n\n// allow 60 requests per hour (each subsequent request allowed not earlier than after 1h/60 = 1m) for all clients\nclusterLeakyBucketRatelimit(\"hourly\", 60, \"1h\", 1, 1)\n\n// allow 10 requests per minute for each unique PHPSESSID cookie with bursts of up to 5 requests\nclusterLeakyBucketRatelimit(\"session-${request.cookie.PHPSESSID}\", 10, \"1m\", 5, 1)\n\n// use the same bucket but add different amount (i.e. one /expensive request counts as two /cheap)\nPath(\"/cheap\")     -&gt; clusterLeakyBucketRatelimit(\"user-${request.cookie.Authorization}\", 1, \"1s\", 5, 1) -&gt; ...\nPath(\"/expensive\") -&gt; clusterLeakyBucketRatelimit(\"user-${request.cookie.Authorization}\", 1, \"1s\", 5, 2) -&gt; ...\n</code></pre></p>"},{"location":"reference/filters/#ratelimitfailclosed","title":"ratelimitFailClosed","text":"<p>This filter changes the failure mode for all rate limit filters of the route. By default rate limit filters fail open on infrastructure errors (e.g. when redis is down) and allow requests. When this filter is present on the route, rate limit filters will fail closed in case of infrastructure errors and deny requests.</p> <p>Examples: <pre><code>fail_open: * -&gt; clusterRatelimit(\"g\",10, \"1s\")\nfail_closed: * -&gt; ratelimitFailClosed() -&gt; clusterRatelimit(\"g\", 10, \"1s\")\n</code></pre></p> <p>In case <code>clusterRatelimit</code> could not reach the swarm (e.g. redis):</p> <ul> <li>Route <code>fail_open</code> will allow the request</li> <li>Route <code>fail_closed</code> will deny the request</li> </ul>"},{"location":"reference/filters/#load-shedding","title":"Load Shedding","text":"<p>The basic idea of load shedding is to reduce errors by early stopping some of the ingress requests that create too much load and serving the maximum throughput the system can process at a point in time.</p> <p>There is a great talk by Acacio Cruz from Google that explains the basic principles.</p>"},{"location":"reference/filters/#admissioncontrol","title":"admissionControl","text":"<p>Implements an admission control filter, that rejects traffic by observed error rate and probability. If it rejects a request skipper will respond with status code 503.</p> <p>The probability of rejection is calculated by the following equation:</p> \\[ P_{reject} = ( { n_{total} - { n_{success} \\over threshold } \\over n_{total} + 1} )^{ exponent } \\] <p>Examples:</p> <pre><code>admissionControl(metricSuffix, mode, d, windowSize, minRPS, successThreshold, maxRejectProbability, exponent)\nadmissionControl(\"myapp\", \"active\", \"1s\", 5, 10, 0.95, 0.9, 0.5)\n</code></pre> <p>Parameters:</p> <ul> <li>metric suffix (string)</li> <li>mode (enum)</li> <li>d (time.Duration)</li> <li>window size (int)</li> <li>minRps (int)</li> <li>success threshold (float64)</li> <li>max reject probability (float64)</li> <li>exponent (float64)</li> </ul> <p>Metric suffix is the chosen suffix key to expose reject counter, should be unique by filter instance</p> <p>Mode has 3 different possible values:</p> <ul> <li>\u201cactive\u201d will reject traffic</li> <li>\u201cinactive\u201d will never reject traffic</li> <li>\u201clogInactive\u201d will not reject traffic, but log to debug filter settings</li> </ul> <p>D the time duration of a single slot for required counters in our circular buffer of window size.</p> <p>Window size is the size of the circular buffer. It is used to snapshot counters to calculate total requests and number of success. It is within \\([1, 100]\\).</p> <p>MinRps is the minimum requests per second that have to pass this filter otherwise it will not reject traffic.</p> <p>Success threshold sets the lowest request success rate at which the filter will not reject requests. It is within \\((0,1]\\). A value of 0.95 means an error rate of lower than 5% will not trigger rejects.</p> <p>Max reject probability sets the upper bound of reject probability. It is within (0,1]. A value of 0.95 means if backend errors with 100% it will only reject up to 95%.</p> <p>exponent is used to dictate the rejection probability. The calculation is done by \\(p = p^{exponent}\\) The exponent value is within \\((0,\\infty]\\), to increase rejection probability you have to use values lower than 1:</p> <ul> <li>1: linear</li> <li>1/2: quadratic</li> <li>1/3: cubic</li> </ul>"},{"location":"reference/filters/#lua","title":"lua","text":"<p>See the scripts page</p>"},{"location":"reference/filters/#logs","title":"Logs","text":""},{"location":"reference/filters/#accesslogdisabled","title":"accessLogDisabled","text":"<p>Deprecated: use disableAccessLog or enableAccessLog</p> <p>The <code>accessLogDisabled</code> filter overrides global Skipper <code>AccessLogDisabled</code> setting for a specific route, which allows to either turn-off the access log for specific route while access log, in general, is enabled or vice versa.</p> <p>Example:</p> <pre><code>accessLogDisabled(\"false\")\n</code></pre>"},{"location":"reference/filters/#disableaccesslog","title":"disableAccessLog","text":"<p>Filter overrides global Skipper <code>AccessLogDisabled</code> setting and allows to turn-off the access log for specific route while access log, in general, is enabled. It is also possible to disable access logs only for a subset of response codes from backend by providing an optional list of response code prefixes.</p> <p>Parameters:</p> <ul> <li>response code prefixes (variadic int) - optional</li> </ul> <p>Example:</p> <pre><code>disableAccessLog()\ndisableAccessLog(1, 301, 40)\n</code></pre> <p>This disables logs of all requests with status codes <code>1xxs</code>, <code>301</code> and all <code>40xs</code>.</p>"},{"location":"reference/filters/#enableaccesslog","title":"enableAccessLog","text":"<p>Filter overrides global Skipper <code>AccessLogDisabled</code> setting and allows to turn-on the access log for specific route while access log, in general, is disabled. It is also possible to enable access logs only for a subset of response codes from backend by providing an optional list of response code prefixes.</p> <p>Parameters:</p> <ul> <li>response code prefixes (variadic int) - optional</li> </ul> <p>Example:</p> <pre><code>enableAccessLog()\nenableAccessLog(1, 301, 20)\n</code></pre> <p>This enables logs of all requests with status codes <code>1xxs</code>, <code>301</code> and all <code>20xs</code>.</p>"},{"location":"reference/filters/#auditlog","title":"auditLog","text":"<p>Filter <code>auditLog()</code> logs the request and N bytes of the body into the log file. N defaults to 1024 and can be overridden with <code>-max-audit-body=&lt;int&gt;</code>. <code>N=0</code> omits logging the body.</p> <p>Example:</p> <pre><code>auditLog()\n</code></pre>"},{"location":"reference/filters/#unverifiedauditlog","title":"unverifiedAuditLog","text":"<p>Filter <code>unverifiedAuditLog()</code> adds a Header, <code>X-Unverified-Audit</code>, to the request, the content of which, will also be written to the log file. By default, the value of the audit header will be equal to the value of the <code>sub</code> key, from the Authorization token. This can be changed by providing a <code>string</code> input to the filter which matches another key from the token.</p> <p>N.B. It is important to note that, if the content of the <code>X-Unverified-Audit</code> header does not match the following regex, then a default value of <code>invalid-sub</code> will be populated in the header instead:     <code>^[a-zA-Z0-9_/:?=&amp;%@.#-]*$</code></p> <p>Examples:</p> <pre><code>unverifiedAuditLog()\n</code></pre> <pre><code>unverifiedAuditLog(\"azp\")\n</code></pre>"},{"location":"reference/filters/#maskaccesslogquery","title":"maskAccessLogQuery","text":"<p>Filter <code>maskAccessLogQuery</code> masks values of the provided query parameters in access logs by replacing them with hashes. It accepts query parameter keys as arguments.</p> <p>Examples:</p> <pre><code>maskAccessLogQuery(\"key_1\")\n</code></pre> <pre><code>maskAccessLogQuery(\"key_1\", \"key_2\")\n</code></pre>"},{"location":"reference/filters/#backend","title":"Backend","text":""},{"location":"reference/filters/#backendisproxy","title":"backendIsProxy","text":"<p>Notifies the proxy that the backend handling this request is also a proxy. The proxy type is based in the URL scheme which can be either <code>http</code>, <code>https</code> or <code>socks5</code>.</p> <p>Keep in mind that Skipper currently cannot handle <code>CONNECT</code> requests by tunneling the traffic to the target destination, however, the <code>CONNECT</code> requests can be forwarded to a different proxy using this filter.</p> <p>Example:</p> <pre><code>foo1:\n  *\n  -&gt; backendIsProxy()\n  -&gt; \"http://proxy.example.com\";\n\nfoo2:\n  *\n  -&gt; backendIsProxy()\n  -&gt; &lt;roundRobin, \"http://proxy1.example.com\", \"http://proxy2.example.com\"&gt;;\n\nfoo3:\n  *\n  -&gt; setDynamicBackendUrl(\"http://proxy.example.com\")\n  -&gt; backendIsProxy()\n  -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#setdynamicbackendhostfromheader","title":"setDynamicBackendHostFromHeader","text":"<p>Filter sets the backend host for a route, value is taken from the provided header. Can be used only with <code>&lt;dynamic&gt;</code> backend. Meant to be used together with setDynamicBackendSchemeFromHeader or setDynamicBackendScheme. If this filter chained together with setDynamicBackendUrlFromHeader or setDynamicBackendUrl filters, the latter ones would have priority.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; setDynamicBackendHostFromHeader(\"X-Forwarded-Host\") -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#setdynamicbackendschemefromheader","title":"setDynamicBackendSchemeFromHeader","text":"<p>Filter sets the backend scheme for a route, value is taken from the provided header. Can be used only with <code>&lt;dynamic&gt;</code> backend. Meant to be used together with setDynamicBackendHostFromHeader or setDynamicBackendHost. If this filter chained together with setDynamicBackendUrlFromHeader or setDynamicBackendUrl, the latter ones would have priority.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; setDynamicBackendSchemeFromHeader(\"X-Forwarded-Proto\") -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#setdynamicbackendurlfromheader","title":"setDynamicBackendUrlFromHeader","text":"<p>Filter sets the backend url for a route, value is taken from the provided header. Can be used only with <code>&lt;dynamic&gt;</code> backend.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; setDynamicBackendUrlFromHeader(\"X-Custom-Url\") -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#setdynamicbackendhost","title":"setDynamicBackendHost","text":"<p>Filter sets the backend host for a route. Can be used only with <code>&lt;dynamic&gt;</code> backend. Meant to be used together with setDynamicBackendSchemeFromHeader or setDynamicBackendScheme. If this filter chained together with setDynamicBackendUrlFromHeader or setDynamicBackendUrl, the latter ones would have priority.</p> <p>Parameters:</p> <ul> <li>host (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; setDynamicBackendHost(\"example.com\") -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#setdynamicbackendscheme","title":"setDynamicBackendScheme","text":"<p>Filter sets the backend scheme for a route. Can be used only with <code>&lt;dynamic&gt;</code> backend. Meant to be used together with setDynamicBackendHostFromHeader or setDynamicBackendHost. If this filter chained together with setDynamicBackendUrlFromHeader or setDynamicBackendUrl, the latter ones would have priority.</p> <p>Parameters:</p> <ul> <li>scheme (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; setDynamicBackendScheme(\"https\") -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#setdynamicbackendurl","title":"setDynamicBackendUrl","text":"<p>Filter sets the backend url for a route. Can be used only with <code>&lt;dynamic&gt;</code> backend.</p> <p>Parameters:</p> <ul> <li>url (string)</li> </ul> <p>Example:</p> <pre><code>foo: * -&gt; setDynamicBackendUrl(\"https://example.com\") -&gt; &lt;dynamic&gt;;\n</code></pre>"},{"location":"reference/filters/#apiusagemonitoring","title":"apiUsageMonitoring","text":"<p>The <code>apiUsageMonitoring</code> filter adds API related metrics to the Skipper monitoring. It is by default not activated. Activate it by providing the <code>-enable-api-usage-monitoring</code> flag at Skipper startup. In its deactivated state, it is still registered as a valid filter (allowing route configurations to specify it), but will perform no operation. That allows, per instance, production environments to use it and testing environments not to while keeping the same route configuration for all environments.</p> <p>For the client based metrics, additional flags need to be specified.</p> Flag Description <code>api-usage-monitoring-realm-keys</code> Name of the property in the JWT JSON body that contains the name of the realm. <code>api-usage-monitoring-client-keys</code> Name of the property in the JWT JSON body that contains the name of the client. <code>api-usage-monitoring-realms-tracking-pattern</code> RegEx of realms to be monitored. Defaults to \u2018services\u2019. <p>NOTE: Make sure to activate the metrics flavour proper to your environment using the <code>metrics-flavour</code> flag in order to get those metrics.</p> <p>Example:</p> <pre><code>skipper -metrics-flavour prometheus -enable-api-usage-monitoring -api-usage-monitoring-realm-keys=\"realm\" -api-usage-monitoring-client-keys=\"managed-id\" api-usage-monitoring-realms-tracking-pattern=\"services,users\"\n</code></pre> <p>The structure of the metrics is all of those elements, separated by <code>.</code> dots:</p> Part Description <code>apiUsageMonitoring.custom</code> Every filter metrics starts with the name of the filter followed by <code>custom</code>. This part is constant. Application ID Identifier of the application, configured in the filter under <code>app_id</code>. Tag Tag of the application (e.g. staging), configured in the filter under <code>tag</code>. API ID Identifier of the API, configured in the filter under <code>api_id</code>. Method The request\u2019s method (verb), capitalized (ex: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>). Path The request\u2019s path, in the form of the path template configured in the filter under <code>path_templates</code>. Realm The realm in which the client is authenticated. Client Identifier under which the client is authenticated. Metric Name Name (or key) of the metric being tracked."},{"location":"reference/filters/#available-metrics","title":"Available Metrics","text":""},{"location":"reference/filters/#endpoint-related-metrics","title":"Endpoint Related Metrics","text":"<p>Those metrics are not identifying the realm and client. They always have <code>*</code> in their place.</p> <p>Example:</p> <pre><code>                                                                                      + Realm\n                                                                                      |\napiUsageMonitoring.custom.orders-backend.staging.orders-api.GET.foo/orders/{order-id}.*.*.http_count\n                                                                                        | |\n                                                                                        | + Metric Name\n                                                                                        + Client\n</code></pre> <p>The available metrics are:</p> Type Metric Name Description Counter <code>http_count</code> number of HTTP exchanges Counter <code>http1xx_count</code> number of HTTP exchanges resulting in information (HTTP status in the 100s) Counter <code>http2xx_count</code> number of HTTP exchanges resulting in success (HTTP status in the 200s) Counter <code>http3xx_count</code> number of HTTP exchanges resulting in a redirect (HTTP status in the 300s) Counter <code>http4xx_count</code> number of HTTP exchanges resulting in a client error (HTTP status in the 400s) Counter <code>http5xx_count</code> number of HTTP exchanges resulting in a server error (HTTP status in the 500s) Histogram <code>latency</code> time between the first observable moment (a call to the filter\u2019s <code>Request</code>) until the last (a call to the filter\u2019s <code>Response</code>)"},{"location":"reference/filters/#client-related-metrics","title":"Client Related Metrics","text":"<p>Those metrics are not identifying endpoint (path) and HTTP verb. They always have <code>*</code> as their place.</p> <p>Example:</p> <pre><code>                                                            + HTTP Verb\n                                                            | + Path Template     + Metric Name\n                                                            | |                   |\napiUsageMonitoring.custom.orders-backend.staging.orders-api.*.*.users.mmustermann.http_count\n                                                                |     |\n                                                                |     + Client\n                                                                + Realm\n</code></pre> <p>The available metrics are:</p> Type Metric Name Description Counter <code>http_count</code> number of HTTP exchanges Counter <code>http1xx_count</code> number of HTTP exchanges resulting in information (HTTP status in the 100s) Counter <code>http2xx_count</code> number of HTTP exchanges resulting in success (HTTP status in the 200s) Counter <code>http3xx_count</code> number of HTTP exchanges resulting in a redirect (HTTP status in the 300s) Counter <code>http4xx_count</code> number of HTTP exchanges resulting in a client error (HTTP status in the 400s) Counter <code>http5xx_count</code> number of HTTP exchanges resulting in a server error (HTTP status in the 500s) Counter <code>latency_sum</code> sum of seconds (in decimal form) between the first observable moment (a call to the filter\u2019s <code>Request</code>) until the last (a call to the filter\u2019s <code>Response</code>)"},{"location":"reference/filters/#filter-configuration","title":"Filter Configuration","text":"<p>Endpoints can be monitored using the <code>apiUsageMonitoring</code> filter in the route. It accepts JSON objects (as strings) of the format mentioned below. In case any of the required parameters is missing, <code>no-op</code> filter is created, i.e. no metrics are captured, but the creation of the route does not fail.</p> <pre><code>api-usage-monitoring-configuration:\n  type: object\n  required:\n    - application_id\n    - api_id\n    - path_templates\n  properties:\n    application_id:\n      type: string\n      description: ID of the application\n      example: order-service\n    tag:\n      type: string\n      description: tag of the application\n      example: staging\n    api_id:\n      type: string\n      description: ID of the API\n      example: orders-api\n    path_templates:\n      description: Endpoints to be monitored.\n      type: array\n      minLength: 1\n      items:\n        type: string\n        description: &gt;\n          Path template in /articles/{article-id} (OpenAPI 3) or in /articles/:article-id format.\n          NOTE: They will be normalized to the :this format for metrics naming.\n        example: /orders/{order-id}\n    client_tracking_pattern:\n        description: &gt;\n            The pattern that matches client id in form of a regular expression.\n\n            By default (if undefined), it is set to `.*`.\n\n            An empty string disables the client metrics completely.\n        type: string\n        examples:\n            all_services:\n                summary: All services are tracked (for all activated realms).\n                value: \".*\"\n            just_some_services:\n                summary: Only services `orders-service` and `shipment-service` are tracked.\n                value: \"(orders\\-service|shipment\\-service)\"\n</code></pre> <p>Configuration Example:</p> <pre><code>apiUsageMonitoring(`\n    {\n        \"application_id\": \"my-app\",\n        \"tag\": \"staging\",\n        \"api_id\": \"orders-api\",\n        \"path_templates\": [\n            \"foo/orders\",\n            \"foo/orders/:order-id\",\n            \"foo/orders/:order-id/order_item/{order-item-id}\"\n        ],\n        \"client_tracking_pattern\": \"(shipping\\-service|payment\\-service)\"\n    }`,`{\n        \"application_id\": \"my-app\",\n        \"api_id\": \"customers-api\",\n        \"path_templates\": [\n            \"/foo/customers/\",\n            \"/foo/customers/{customer-id}/\"\n        ]\n    }\n`)\n</code></pre> <p>Based on the previous configuration, here is an example of a counter metric.</p> <pre><code>apiUsageMonitoring.custom.my-app.staging.orders-api.GET.foo/orders/{order-id}.*.*.http_count\n</code></pre> <p>Note that a missing <code>tag</code> in the configuration will be replaced by <code>{no-tag}</code> in the metric:</p> <pre><code>apiUsageMonitoring.custom.my-app.{no-tag}.customers-api.GET.foo/customers.*.*.http_count\n</code></pre> <p>Here is the Prometheus query to obtain it.</p> <pre><code>sum(rate(skipper_custom_total{key=\"apiUsageMonitoring.custom.my-app.staging.orders-api.GET.foo/orders/{order-id}.*.*.http_count\"}[60s])) by (key)\n</code></pre> <p>Here is an example of a histogram metric.</p> <pre><code>apiUsageMonitoring.custom.my_app.staging.orders-api.POST.foo/orders.latency\n</code></pre> <p>Here is the Prometheus query to obtain it.</p> <pre><code>histogram_quantile(0.5, sum(rate(skipper_custom_duration_seconds_bucket{key=\"apiUsageMonitoring.custom.my-app.staging.orders-api.POST.foo/orders.*.*.latency\"}[60s])) by (le, key))\n</code></pre> <p>NOTE: Non configured paths will be tracked with <code>{unknown}</code> Application ID, Tag, API ID and path template.</p> <p>However, if all <code>application_id</code>s of your configuration refer to the same application, the filter assume that also non configured paths will be directed to this application. E.g.:</p> <pre><code>apiUsageMonitoring.custom.my-app.{unknown}.{unknown}.GET.{no-match}.*.*.http_count\n</code></pre>"},{"location":"reference/filters/#originmarker","title":"originMarker","text":"<p>This filter is used to measure the time it took to create a route. Other than that, it\u2019s a no-op. You can include the same origin marker when you re-create the route. As long as the <code>origin</code> and <code>id</code> are the same, the route creation time will not be measured again. If there are multiple origin markers with the same origin, the earliest timestamp will be used.</p> <p>Parameters:</p> <ul> <li>the name of the origin</li> <li>the ID of the object that is the logical source for the route</li> <li>the creation timestamp (rfc3339)</li> </ul> <p>Example:</p> <pre><code>originMarker(\"apiUsageMonitoring\", \"deployment1\", \"2019-08-30T09:55:51Z\")\n</code></pre>"},{"location":"reference/filters/#scheduler","title":"Scheduler","text":""},{"location":"reference/filters/#fifo","title":"fifo","text":"<p>This Filter is similar to the lifo filter in regards to parameters and status codes.</p> <p>It turned out that <code>lifo()</code> filter can hurt performance at high load. On AWS instance c6g.8xlarge lifo filter had a limit of 21000 requests per second on a single instance. The <code>fifo()</code> filter had not hit a limit at 30000 requests per second. If you use TCP-LIFO, then request processing is already in LIFO style.</p> <p>Parameters:</p> <ul> <li>MaxConcurrency specifies how many goroutines are allowed to work on this queue (int)</li> <li>MaxQueueSize sets the queue size (int)</li> <li>Timeout sets the timeout to get request scheduled (time)</li> </ul> <p>Example:</p> <pre><code>fifo(100, 150, \"10s\")\n</code></pre>"},{"location":"reference/filters/#fifowithbody","title":"fifoWithBody","text":"<p>This Filter is similar to the lifo filter in regards to parameters and status codes. Performance considerations are similar to fifo.</p> <p>The difference between fifo and fifoWithBody is that fifo will decrement the concurrency as soon as the backend sent response headers and fifoWithBody will decrement the concurrency if the response body was served. Normally both are very similar, but if you have a fully async component that serves multiple website fragments, this would decrement concurrency too early.</p> <p>Parameters:</p> <ul> <li>MaxConcurrency specifies how many goroutines are allowed to work on this queue (int)</li> <li>MaxQueueSize sets the queue size (int)</li> <li>Timeout sets the timeout to get request scheduled (time)</li> </ul> <p>Example:</p> <pre><code>fifoWithBody(100, 150, \"10s\")\n</code></pre>"},{"location":"reference/filters/#lifo","title":"lifo","text":"<p>This Filter changes skipper to handle the route with a bounded last in first out queue (LIFO), instead of an unbounded first in first out queue (FIFO). The default skipper scheduler is based on Go net/http package, which provides an unbounded FIFO request handling. If you enable this filter the request scheduling will change to a LIFO.  The idea of a LIFO queue is based on Dropbox bandaid proxy, which is not opensource. Dropbox shared their idea in a public blogpost. All bounded scheduler filters will respond requests with server status error codes in case of overrun.</p> <p>All scheduler filters return HTTP status code:</p> <ul> <li>502, if the specified timeout is reached, because a request could not be scheduled fast enough</li> <li>503, if the queue is full</li> </ul> <p>Parameters:</p> <ul> <li>MaxConcurrency specifies how many goroutines are allowed to work on this queue(int)</li> <li>MaxQueueSize sets the queue size (int)</li> <li>Timeout sets the timeout to get request scheduled (time)</li> </ul> <p>Example:</p> <pre><code>lifo(100, 150, \"10s\")\n</code></pre> <p>The above configuration will set MaxConcurrency to 100, MaxQueueSize to 150 and Timeout to 10 seconds.</p> <p>When there are multiple lifo filters on the route, only the last one will be applied.</p>"},{"location":"reference/filters/#lifogroup","title":"lifoGroup","text":"<p>This filter is similar to the lifo filter.</p> <p>Parameters:</p> <ul> <li>GroupName to group multiple one or many routes to the same queue, which have to have the same settings (string)</li> <li>MaxConcurrency specifies how many goroutines are allowed to work on this queue(int)</li> <li>MaxQueueSize sets the queue size (int)</li> <li>Timeout sets the timeout to get request scheduled (time)</li> </ul> <p>Example:</p> <pre><code>lifoGroup(\"mygroup\", 100, 150, \"10s\")\n</code></pre> <p>The above configuration will set MaxConcurrency to 100, MaxQueueSize to 150 and Timeout to 10 seconds for the lifoGroup \u201cmygroup\u201d, that can be shared between multiple routes.</p> <p>It is enough to set the concurrency, queue size and timeout parameters for one instance of the filter in the group, and only the group name for the rest. Setting these values for multiple instances is fine, too. While only one of them will be used as the source for the applied settings, if there is accidentally a difference between the settings in the same group, a warning will be logged.</p> <p>It is possible to use the lifoGroup filter together with the single lifo filter, e.g. if a route belongs to a group, but needs to have additional stricter settings then the whole group.</p>"},{"location":"reference/filters/#rfc-compliance","title":"RFC Compliance","text":""},{"location":"reference/filters/#rfchost","title":"rfcHost","text":"<p>This filter removes the optional trailing dot in the outgoing host header.</p> <p>Example:</p> <pre><code>rfcHost()\n</code></pre>"},{"location":"reference/filters/#rfcpath","title":"rfcPath","text":"<p>This filter forces an alternative interpretation of the RFC 2616 and RFC 3986 standards, where paths containing reserved characters will have these characters unescaped when the incoming request also has them unescaped.</p> <p>Example:</p> <pre><code>Path(\"/api/*id) -&gt; rfcPath() -&gt; \"http://api-backend\"\n</code></pre> <p>In the above case, if the incoming request has something like foo%2Fbar in the id position, the api-backend service will also receive it in the format foo%2Fbar, while without the rfcPath() filter the outgoing request path will become /api/foo/bar.</p> <p>In case we want to use the id while routing the request, we can use the  backend. Example: <pre><code>api: Path(\"/api/:id\") -&gt; setPath(\"/api/${id}/summary\") -&gt; \"http://api-backend\";\npatch: Path(\"/api/*id\") -&gt; rfcPath() -&gt; &lt;loopback&gt;;\n</code></pre> <p>In the above case, if the incoming request path is /api/foo%2Fbar, it will match the \u2018patch\u2019 route, and then the patched request will match the api route, and the api-backend service will receive a request with the path /api/foo%2Fbar/summary.</p> <p>It is also possible to enable this behavior centrally for a Skipper instance with the -rfc-patch-path flag. See URI standards interpretation.</p>"},{"location":"reference/filters/#egress","title":"Egress","text":""},{"location":"reference/filters/#setrequestheaderfromsecret","title":"setRequestHeaderFromSecret","text":"<p>This filter sets request header to the secret value with optional prefix and suffix. This is only for use cases using skipper as sidecar to inject tokens for the application on the egress path, if it\u2019s used in the ingress path you likely create a security issue for your application.</p> <p>This filter should be used as an egress only feature.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>secret name (string)</li> <li>value prefix (string) - optional</li> <li>value suffix (string) - optional</li> </ul> <p>Example:</p> <pre><code>egress1: Method(\"GET\") -&gt; setRequestHeaderFromSecret(\"Authorization\", \"/tmp/secrets/get-token\") -&gt; \"https://api.example.com\";\negress2: Method(\"POST\") -&gt; setRequestHeaderFromSecret(\"Authorization\", \"/tmp/secrets/post-token\", \"foo-\") -&gt; \"https://api.example.com\";\negress3: Method(\"PUT\") -&gt; setRequestHeaderFromSecret(\"X-Secret\", \"/tmp/secrets/put-token\", \"bar-\", \"-baz\") -&gt; \"https://api.example.com\";\n</code></pre> <p>To use <code>setRequestHeaderFromSecret</code> filter you need to run skipper with <code>-credentials-paths=/tmp/secrets</code> and specify an update interval <code>-credentials-update-interval=10s</code>. Files in the credentials path can be a directory, which will be able to find all files within this directory, but it won\u2019t walk subtrees. For the example case, there have to be <code>get-token</code>, <code>post-token</code> and <code>put-token</code> files within the specified credential paths <code>/tmp/secrets/</code>, resulting in <code>/tmp/secrets/get-token</code>, <code>/tmp/secrets/post-token</code> and <code>/tmp/secrets/put-token</code>.</p>"},{"location":"reference/filters/#bearerinjector","title":"bearerinjector","text":"<p>This filter injects <code>Bearer</code> tokens into <code>Authorization</code> headers read from file providing the token as content.</p> <p>It is a special form of <code>setRequestHeaderFromSecret</code> with <code>\"Authorization\"</code> header name, <code>\"Bearer \"</code> prefix and empty suffix.</p> <p>Example:</p> <pre><code>egress: * -&gt; bearerinjector(\"/tmp/secrets/my-token\") -&gt; \"https://api.example.com\";\n\n// equivalent to setRequestHeaderFromSecret(\"Authorization\", \"/tmp/secrets/my-token\", \"Bearer \")\n</code></pre>"},{"location":"reference/filters/#open-tracing","title":"Open Tracing","text":""},{"location":"reference/filters/#tracingbaggagetotag","title":"tracingBaggageToTag","text":"<p>This filter adds an opentracing tag for a given baggage item in the trace.</p> <p>Syntax: <pre><code>tracingBaggageToTag(\"&lt;baggage_item_name&gt;\", \"&lt;tag_name&gt;\")\n</code></pre></p> <p>Example:</p> <p>If a trace consists of a baggage item named <code>foo</code> with a value of <code>bar</code>, then adding the filter below will add a tag named <code>baz</code> with the value <code>bar</code>: <pre><code>tracingBaggageToTag(\"foo\", \"baz\")\n</code></pre></p> <p>A single-argument variant uses the baggage item name as the tag name, i.e., it will add a tag named <code>foo</code> with the value <code>bar</code>: <pre><code>tracingBaggageToTag(\"foo\")\n</code></pre></p>"},{"location":"reference/filters/#statebagtotag","title":"stateBagToTag","text":"<p>This filter sets an opentracing tag from the filter context (state bag). If the provided key (first parameter) cannot be found in the state bag, then it doesn\u2019t set the tag.</p> <p>Parameters:</p> <ul> <li>key in the state bag (string)</li> <li>tag name (string)</li> </ul> <p>The route in the following example checks whether the request is authorized with the oauthTokeninfoAllScope() filter. This filter stores the authenticated user with \u201cauth-user\u201d key in the context, and the stateBagToTag() filter in the next step stores it in the opentracing tag \u201cclient_id\u201d:</p> <pre><code>foo: * -&gt; oauthTokeninfoAllScope(\"address_service.all\") -&gt; stateBagToTag(\"auth-user\", \"client_id\") -&gt; \"https://backend.example.org\";\n</code></pre>"},{"location":"reference/filters/#tracingtag","title":"tracingTag","text":"<p>This filter adds an opentracing tag.</p> <p>Syntax: <pre><code>tracingTag(\"&lt;tag_name&gt;\", \"&lt;tag_value&gt;\")\n</code></pre></p> <p>Tag value may contain template placeholders. If a template placeholder can\u2019t be resolved then filter does not set the tag.</p> <p>Example: Adding the below filter will add a tag named <code>foo</code> with the value <code>bar</code>. <pre><code>tracingTag(\"foo\", \"bar\")\n</code></pre></p> <p>Example: Set tag from request header <pre><code>tracingTag(\"http.flow_id\", \"${request.header.X-Flow-Id}\")\n</code></pre></p>"},{"location":"reference/filters/#tracingtagfromresponse","title":"tracingTagFromResponse","text":"<p>This filter works just like tracingTag, but is applied after the request was processed. In particular, template placeholders referencing the response can be used in the tag value.</p>"},{"location":"reference/filters/#tracingtagfromresponseifstatus","title":"tracingTagFromResponseIfStatus","text":"<p>This filter works like tracingTagFromResponse but only for responses having status code from the specified range.</p> <p>Example: set error tag to true when response status code is <code>&gt;= 500</code> and <code>&lt;= 599</code>:</p> <pre><code>tracingTagFromResponseIfStatus(\"error\", \"true\", 500, 599)\n</code></pre> <p>Example: set user id tag for ratelimited requests:</p> <pre><code>tracingTagFromResponseIfStatus(\"user.id\", \"${request.header.X-User-Id}\", 429, 429) -&gt; clusterClientRatelimit(\"user-id\", 10, \"1m\", \"X-User-Id\")\n</code></pre>"},{"location":"reference/filters/#tracingspanname","title":"tracingSpanName","text":"<p>This filter sets the name of the outgoing (client span) in opentracing. The default name is \u201cproxy\u201d. Example:</p> <pre><code>tracingSpanName(\"api-operation\")\n</code></pre>"},{"location":"reference/filters/#load-balancing","title":"Load Balancing","text":"<p>Some filters influence how load balancing will be done</p>"},{"location":"reference/filters/#fadein","title":"fadeIn","text":"<p>When this filter is set, then the newly added endpoints will receive the traffic in a gradually increasing way, starting from their detection for the specified duration, after which they receive equal amount traffic as the previously existing routes. The detection time of a load balanced backend endpoint is preserved over multiple generations of the route configuration (over route changes). This filter can be used to saturate the load of autoscaling applications that require a warm-up time and therefore a smooth ramp-up. The fade-in feature can be used together with all the available LB algorithms.</p> <p>While the default fade-in curve is linear, the optional exponent parameter can be used to adjust the shape of the fade-in curve, based on the following equation:</p> <p>current_rate = proportional_rate * min((now - detected) / duration, 1) ^ exponent</p> <p>Parameters:</p> <ul> <li>duration: duration of the fade-in in milliseconds or as a duration string</li> <li>fade-in curve exponent - optional: a floating point number, default: 1</li> </ul> <p>Examples:</p> <pre><code>fadeIn(\"3m\")\nfadeIn(\"3m\", 1.5)\n</code></pre>"},{"location":"reference/filters/#warning-on-fadein-and-rolling-restarts","title":"Warning on fadeIn and Rolling Restarts","text":"<p>Traffic fade-in has the potential to skew the traffic to your backend pods in case of a rolling restart (<code>kubectl rollout restart</code>), because it is very likely that the rolling restart is going faster than the fade-in duration. The image below shows an example of a rolling restart for a four-pod deployment (A, B, C, D) into (E, F, G, H), and the traffic share of each pod over time. While the ramp-up of the new pods is ongoing, the remaining old pods will receive a largely increased traffic share (especially the last one, D in this example), as well as an over-proportional traffic share for the first pod in the rollout (E).</p> <p>To make rolling restarts safe, you need to slow them down by setting <code>spec.minReadySeconds</code> on the pod spec of your deployment or stackset, according to your fadeIn duration.</p> <p></p>"},{"location":"reference/filters/#endpointcreated","title":"endpointCreated","text":"<p>This filter marks the creation time of a load balanced endpoint. When used together with the fadeIn filter, it prevents missing the detection of a new backend instance with the same hostname. This filter is typically automatically appended, and it\u2019s parameters are based on external sources, e.g. the Kubernetes API.</p> <p>Parameters:</p> <ul> <li>the address of the endpoint</li> <li>timestamp, either as a number of seconds since the unix epocs, or a string in RFC3339 format</li> </ul> <p>Example:</p> <pre><code>endpointCreated(\"http://10.0.0.1:8080\", \"2020-12-18T15:30:00Z01:00\")\n</code></pre>"},{"location":"reference/filters/#consistenthashkey","title":"consistentHashKey","text":"<p>This filter sets the request key used by the <code>consistentHash</code> algorithm to select the backend endpoint.</p> <p>Parameters:</p> <ul> <li>key (string)</li> </ul> <p>The key should contain template placeholders, without placeholders the key is constant and therefore all requests would be made to the same endpoint. The algorithm will use the default key if any of the template placeholders can\u2019t be resolved.</p> <p>Examples:</p> <p><pre><code>pr: Path(\"/products/:productId\")\n    -&gt; consistentHashKey(\"${productId}\")\n    -&gt; &lt;consistentHash, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;\n</code></pre> <pre><code>consistentHashKey(\"${request.header.Authorization}\")\nconsistentHashKey(\"${request.source}\") // same as the default key\n</code></pre></p>"},{"location":"reference/filters/#consistenthashbalancefactor","title":"consistentHashBalanceFactor","text":"<p>This filter sets the balance factor used by the <code>consistentHash</code> algorithm to prevent a single backend endpoint from being overloaded. The number of in-flight requests for an endpoint cannot exceed <code>(average-in-flight-requests * balanceFactor) + 1</code>. This is helpful in the case where certain keys are very popular and threaten to overload the endpoint they are mapped to. Further Details.</p> <p>Parameters:</p> <ul> <li>balanceFactor: A float or int, must be &gt;= 1</li> </ul> <p>Examples:</p> <p><pre><code>pr: Path(\"/products/:productId\")\n    -&gt; consistentHashKey(\"${productId}\")\n    -&gt; consistentHashBalanceFactor(1.25)\n    -&gt; &lt;consistentHash, \"http://127.0.0.1:9998\", \"http://127.0.0.1:9997\"&gt;;\n</code></pre> <pre><code>consistentHashBalanceFactor(3)\n</code></pre></p>"},{"location":"reference/plugins/","title":"Skipper plugins","text":"<p>Skipper may be extended with functionality not present in the core. These additions can be built as go plugin, so they do not have to be present in the main skipper repository.</p> <p>Note the warning from Go\u2019s plugin.go:</p> <pre><code>// The plugin support is currently incomplete, only supports Linux,\n// and has known bugs. Please report any issues.\n</code></pre> <p>Note the known problem of using plugins together with vendoring, best described here:</p> <p>https://github.com/golang/go/issues/20481</p>"},{"location":"reference/plugins/#plugin-directories","title":"Plugin directories","text":"<p>Plugins are loaded from sub directories of the plugin directories. By default the plugin directory is set to <code>./plugins</code> (i.e. relative to skipper\u2019s working directory). An additional directory may be given with the <code>-plugindir=/path/to/dir</code> option to skipper.</p> <p>Any file with the suffix <code>.so</code> found below the plugin directories (also in sub directories) is attempted to load without any arguments. When a plugin needs an argument, this must be explicitly loaded and the arguments passed, e.g. with <code>-filter-plugin geoip,db=/path/to/db</code>.</p>"},{"location":"reference/plugins/#building-a-plugin","title":"Building a plugin","text":"<p>Each plugin should be built with Go version &gt;= 1.11, enabled Go modules support similar to the following build command line:</p> <pre><code>go build -buildmode=plugin -o example.so example.go\n</code></pre> <p>There are some pitfalls:</p> <ul> <li>packages which are shared between skipper and the plugin must not be in   a <code>vendor/</code> directory; otherwise, the plugin will fail to load or in some   cases give wrong results (e.g. an opentracing span cannot be found in the   context even if it is present). This also means:   Do not vendor skipper in a plugin repo\u2026</li> <li>plugins must be rebuilt when skipper is rebuilt</li> <li>do not attempt to rebuild a module and copy it over a loaded plugin, that   will crash skipper immediately\u2026</li> </ul>"},{"location":"reference/plugins/#use-a-plugin","title":"Use a plugin","text":"<p>In this example we use a geoip database, that you need to find and download. We expect that you did a <code>git clone git@github.com:zalando/skipper.git</code> and entered the directory.</p> <p>Build skipper:</p> <pre><code>% make skipper\n</code></pre> <p>Install filter plugins:</p> <pre><code>% mkdir plugins\n% git clone git@github.com:skipper-plugins/filters.git plugins/filters\n% ls plugins/filters\ngeoip/  glide.lock  glide.yaml  ldapauth/  Makefile  noop/  plugin_test.go\n% cd plugins/filters/geoip\n% go build -buildmode=plugin -o geoip.so geoip.go\n% cd -\n~/go/src/github.com/zalando/skipper\n</code></pre> <p>Start a pseudo backend that shows all headers in plain:</p> <pre><code>% nc -l 9000\n</code></pre> <p>Run the proxy with geoip database:</p> <pre><code>% ./bin/skipper -filter-plugin geoip,db=$HOME/Downloads/GeoLite2-City_20181127/GeoLite2-City.mmdb -inline-routes '* -&gt; geoip() -&gt; \"http://127.0.0.1:9000\"'\n[APP]INFO[0000] found plugin geoip at plugins/filters/geoip/geoip.so\n[APP]INFO[0000] loaded plugin geoip (geoip) from plugins/filters/geoip/geoip.so\n[APP]INFO[0000] attempting to load plugin from plugins/filters/geoip/geoip.so\n[APP]INFO[0000] plugin geoip already loaded with InitFilter\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] route settings, reset, route: : * -&gt; geoip() -&gt; \"http://127.0.0.1:9000\"\n[APP]INFO[0000] certPathTLS or keyPathTLS not found, defaulting to HTTP\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n</code></pre> <p>Or passing a yaml file via <code>config-file</code> flag:</p> <pre><code>inline-routes: '* -&gt; geoip() -&gt; \"http://127.0.0.1:9000\"'\nfilter-plugin:\n  geoip:\n    - db=$HOME/Downloads/GeoLite2-City_20181127/GeoLite2-City.mmdb\n</code></pre> <p>Use a client to lookup geoip:</p> <pre><code>% curl -H\"X-Forwarded-For: 107.12.53.5\" localhost:9090/\n^C\n</code></pre> <p>pseudo backend should show X-Geoip-Country header:</p> <pre><code># nc -l 9000\nGET / HTTP/1.1\nHost: 127.0.0.1:9000\nUser-Agent: curl/7.49.0\nAccept: */*\nX-Forwarded-For: 107.12.53.5\nX-Geoip-Country: US\nAccept-Encoding: gzip\n^C\n</code></pre> <p>skipper should show additional log lines, because of the CTRL-C:</p> <pre><code>[APP]ERRO[0082] error while proxying, route  with backend http://127.0.0.1:9000, status code 500: dialing failed false: EOF\n107.12.53.5 - - [28/Nov/2018:14:39:40 +0100] \"GET / HTTP/1.1\" 500 22 \"-\" \"curl/7.49.0\" 2753 localhost:9090 - -\n</code></pre>"},{"location":"reference/plugins/#filter-plugins","title":"Filter plugins","text":"<p>All plugins must have a function named <code>InitFilter</code> with the following signature</p> <pre><code>func([]string) (filters.Spec, error)\n</code></pre> <p>The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper\u2019s <code>-filter-plugin</code> parameter. E.g. when the <code>-filter-plugin</code> parameter is</p> <pre><code>myfilter,datafile=/path/to/file,foo=bar\n</code></pre> <p>the <code>myfilter</code> plugin will receive</p> <pre><code>[]string{\"datafile=/path/to/file\", \"foo=bar\"}\n</code></pre> <p>as arguments.</p> <p>The filter plugin implementation is responsible to parse the received arguments.</p> <p>Filter plugins can be found in the filter repo</p>"},{"location":"reference/plugins/#example-filter-plugin","title":"Example filter plugin","text":"<p>An example <code>noop</code> plugin looks like</p> <pre><code>package main\n\nimport (\n    \"github.com/zalando/skipper/filters\"\n)\n\ntype noopSpec struct{}\n\nfunc InitFilter(opts []string) (filters.Spec, error) {\n    return noopSpec{}, nil\n}\n\nfunc (s noopSpec) Name() string {\n    return \"noop\"\n}\nfunc (s noopSpec) CreateFilter(config []interface{}) (filters.Filter, error) {\n    return noopFilter{}, nil\n}\n\ntype noopFilter struct{}\n\nfunc (f noopFilter) Request(filters.FilterContext)  {}\nfunc (f noopFilter) Response(filters.FilterContext) {}\n</code></pre>"},{"location":"reference/plugins/#predicate-plugins","title":"Predicate plugins","text":"<p>All plugins must have a function named <code>InitPredicate</code> with the following signature</p> <pre><code>func([]string) (routing.PredicateSpec, error)\n</code></pre> <p>The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper\u2019s <code>-predicate-plugin</code> parameter. E.g. when the <code>-predicate-plugin</code> parameter is</p> <pre><code>mypred,datafile=/path/to/file,foo=bar\n</code></pre> <p>the <code>mypred</code> plugin will receive</p> <pre><code>[]string{\"datafile=/path/to/file\", \"foo=bar\"}\n</code></pre> <p>as arguments.</p> <p>The predicate plugin implementation is responsible to parse the received arguments.</p> <p>Predicate plugins can be found in the predicate repo</p>"},{"location":"reference/plugins/#example-predicate-plugin","title":"Example predicate plugin","text":"<p>An example <code>MatchAll</code> plugin looks like</p> <pre><code>package main\n\nimport (\n    \"github.com/zalando/skipper/routing\"\n    \"net/http\"\n)\n\ntype noopSpec struct{}\n\nfunc InitPredicate(opts []string) (routing.PredicateSpec, error) {\n    return noopSpec{}, nil\n}\n\nfunc (s noopSpec) Name() string {\n    return \"MatchAll\"\n}\nfunc (s noopSpec) Create(config []interface{}) (routing.Predicate, error) {\n    return noopPredicate{}, nil\n}\n\ntype noopPredicate struct{}\n\nfunc (p noopPredicate) Match(*http.Request) bool {\n    return true\n}\n</code></pre>"},{"location":"reference/plugins/#dataclient-plugins","title":"DataClient plugins","text":"<p>Similar to the above predicate and filter plugins. The command line option for data client plugins is <code>-dataclient-plugin</code>. The module must have a <code>InitDataClient</code> function with the signature</p> <pre><code>func([]string) (routing.DataClient, error)\n</code></pre> <p>A <code>noop</code> data client looks like</p> <pre><code>package main\n\nimport (\n    \"github.com/zalando/skipper/eskip\"\n    \"github.com/zalando/skipper/routing\"\n)\n\nfunc InitDataClient([]string) (routing.DataClient, error) {\n    var dc DataClient = \"\"\n    return dc, nil\n}\n\ntype DataClient string\n\nfunc (dc DataClient) LoadAll() ([]*eskip.Route, error) {\n    return eskip.Parse(string(dc))\n}\n\nfunc (dc DataClient) LoadUpdate() ([]*eskip.Route, []string, error) {\n    return nil, nil, nil\n}\n</code></pre>"},{"location":"reference/plugins/#multitype-plugins","title":"MultiType plugins","text":"<p>Sometimes it is necessary to combine multiple plugin types into one module. This can be done with this kind of plugin. Note that these modules are not auto loaded, these need an explicit <code>-multi-plugin name,arg1,arg2</code> command line switch for skipper.</p> <p>The module must have a <code>InitPlugin</code> function with the signature</p> <pre><code>func([]string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error)\n</code></pre> <p>Any of the returned types may be nil, so you can have e.g. a combined filter / data client plugin or share a filter and a predicate, e.g. like</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"net/http\"\n    \"strconv\"\n    \"strings\"\n\n    ot \"github.com/opentracing/opentracing-go\"\n    maxminddb \"github.com/oschwald/maxminddb-golang\"\n\n    \"github.com/zalando/skipper/filters\"\n    snet \"github.com/zalando/skipper/net\"\n    \"github.com/zalando/skipper/predicates\"\n    \"github.com/zalando/skipper/routing\"\n)\n\ntype geoipSpec struct {\n    db   *maxminddb.Reader\n    name string\n}\n\nfunc InitPlugin(opts []string) ([]filters.Spec, []routing.PredicateSpec, []routing.DataClient, error) {\n    var db string\n    for _, o := range opts {\n        switch {\n        case strings.HasPrefix(o, \"db=\"):\n            db = o[3:]\n        }\n    }\n    if db == \"\" {\n        return nil, nil, nil, fmt.Errorf(\"missing db= parameter for geoip plugin\")\n    }\n    reader, err := maxminddb.Open(db)\n    if err != nil {\n        return nil, nil, nil, fmt.Errorf(\"failed to open db %s: %s\", db, err)\n    }\n\n    return []filters.Spec{&amp;geoipSpec{db: reader, name: \"geoip\"}},\n        []routing.PredicateSpec{&amp;geoipSpec{db: reader, name: \"GeoIP\"}},\n        nil,\n        nil\n}\n\nfunc (s *geoipSpec) Name() string {\n    return s.name\n}\n\nfunc (s *geoipSpec) CreateFilter(config []interface{}) (filters.Filter, error) {\n    var fromLast bool\n    header := \"X-GeoIP-Country\"\n    var err error\n    for _, c := range config {\n        if s, ok := c.(string); ok {\n            switch {\n            case strings.HasPrefix(s, \"from_last=\"):\n                fromLast, err = strconv.ParseBool(s[10:])\n                if err != nil {\n                    return nil, filters.ErrInvalidFilterParameters\n                }\n            case strings.HasPrefix(s, \"header=\"):\n                header = s[7:]\n            }\n        }\n    }\n    return &amp;geoip{db: s.db, fromLast: fromLast, header: header}, nil\n}\n\nfunc (s *geoipSpec) Create(config []interface{}) (routing.Predicate, error) {\n    var fromLast bool\n    var err error\n    countries := make(map[string]struct{})\n    for _, c := range config {\n        if s, ok := c.(string); ok {\n            switch {\n            case strings.HasPrefix(s, \"from_last=\"):\n                fromLast, err = strconv.ParseBool(s[10:])\n                if err != nil {\n                    return nil, predicates.ErrInvalidPredicateParameters\n                }\n            default:\n                countries[strings.ToUpper(s)] = struct{}{}\n            }\n        }\n    }\n    return &amp;geoip{db: s.db, fromLast: fromLast, countries: countries}, nil\n}\n\ntype geoip struct {\n    db        *maxminddb.Reader\n    fromLast  bool\n    header    string\n    countries map[string]struct{}\n}\n\ntype countryRecord struct {\n    Country struct {\n        ISOCode string `maxminddb:\"iso_code\"`\n    } `maxminddb:\"country\"`\n}\n\nfunc (g *geoip) lookup(r *http.Request) string {\n    var src net.IP\n    if g.fromLast {\n        src = snet.RemoteHostFromLast(r)\n    } else {\n        src = snet.RemoteHost(r)\n    }\n\n    record := countryRecord{}\n    err := g.db.Lookup(src, &amp;record)\n    if err != nil {\n        fmt.Printf(\"geoip(): failed to lookup %s: %s\", src, err)\n    }\n    if record.Country.ISOCode == \"\" {\n        return \"UNKNOWN\"\n    }\n    return record.Country.ISOCode\n}\n\nfunc (g *geoip) Request(c filters.FilterContext) {\n    c.Request().Header.Set(g.header, g.lookup(c.Request()))\n}\n\nfunc (g *geoip) Response(c filters.FilterContext) {}\n\nfunc (g *geoip) Match(r *http.Request) bool {\n    span := ot.SpanFromContext(r.Context())\n    if span != nil {\n        span.LogKV(\"GeoIP\", \"start\")\n    }\n\n    code := g.lookup(r)\n    _, ok := g.countries[code]\n\n    if span != nil {\n        span.LogKV(\"GeoIP\", code)\n    }\n    return ok\n}\n</code></pre>"},{"location":"reference/plugins/#opentracing-plugins","title":"OpenTracing plugins","text":"<p>The tracers, except for <code>noop</code>, are built as Go Plugins. A tracing plugin can be loaded with <code>-opentracing NAME</code> as parameter to skipper.</p> <p>Implementations of OpenTracing API can be found in the https://github.com/skipper-plugins/opentracing repository.</p> <p>All plugins must have a function named <code>InitTracer</code> with the following signature</p> <pre><code>func([]string) (opentracing.Tracer, error)\n</code></pre> <p>The parameters passed are all arguments for the plugin, i.e. everything after the first word from skipper\u2019s -opentracing parameter. E.g. when the -opentracing parameter is <code>mytracer foo=bar token=xxx somename=bla:3</code> the \u201cmytracer\u201d plugin will receive</p> <pre><code>[]string{\"foo=bar\", \"token=xxx\", \"somename=bla:3\"}\n</code></pre> <p>as arguments.</p> <p>The tracer plugin implementation is responsible to parse the received arguments.</p> <p>An example plugin looks like <pre><code>package main\n\nimport (\n     basic \"github.com/opentracing/basictracer-go\"\n     opentracing \"github.com/opentracing/opentracing-go\"\n)\n\nfunc InitTracer(opts []string) (opentracing.Tracer, error) {\n     return basic.NewTracerWithOptions(basic.Options{\n         Recorder:       basic.NewInMemoryRecorder(),\n         ShouldSample:   func(traceID uint64) bool { return traceID%64 == 0 },\n         MaxLogsPerSpan: 25,\n     }), nil\n}\n</code></pre></p>"},{"location":"reference/predicates/","title":"Skipper Predicates","text":"<p>Predicates are used to decide which route will handle an incoming request. Routes can contain multiple predicates. A request will match a route only if all the predicates of the route match. See the description of the route matching mechanism here: Route matching.</p> <p>Example route with a Host, Method and Path match predicates and a backend:</p> <pre><code>all: Host(/^my-host-header\\.example\\.org$/) &amp;&amp; Method(\"GET\") &amp;&amp; Path(\"/hello\") -&gt; \"http://127.0.0.1:1234/\";\n</code></pre>"},{"location":"reference/predicates/#predicate-arguments","title":"Predicate arguments","text":"<p>The predicate arguments can be strings, regular expressions or numbers (float64, int). In the eskip syntax representation:</p> <ul> <li>strings are surrounded by double quotes (<code>\"</code>). When necessary, characters can be escaped by <code>\\</code>, e.g. <code>\\\\</code> or <code>\\\"</code>.</li> <li>regular expressions are a re2 regular expression, surrounded by</li> <li><code>/</code>, e.g. <code>/^www\\.example\\.org(:\\d+)?$/</code>. When a predicate expects a regular expression as an argument, the string representation with double quotes can be used, as well.</li> <li>numbers are regular (decimal) numbers like <code>401</code> or <code>1.23456</code>. The eskip syntax doesn\u2019t define a limitation on the size of the numbers, but the underlying implementation currently relies on the float64 values of the Go runtime.</li> </ul> <p>Other higher level argument types must be represented as one of the above types. E.g. it is a convention to represent time duration values as strings, parseable by time.Duration).</p>"},{"location":"reference/predicates/#the-path-tree","title":"The path tree","text":"<p>There is an important difference between the evaluation of the Path or PathSubtree predicates, and the evaluation of all the other predicates (PathRegexp belonging to the second group). Find an explanation in the Route matching section explanation section.</p>"},{"location":"reference/predicates/#path","title":"Path","text":"<p>The path predicate is used to match the path in HTTP request line. It accepts a single argument, that can be a fixed path like \u201c/some/path\u201d, or it can contain wildcards. There can be only zero or one path predicate in a route.</p> <p>Wildcards:</p> <p>Wildcards can be put in place of one or more path segments in the path, e.g. \u201c/some/:dir/:name\u201d, or the path can end with a free wildcard like <code>\"/some/path/*param\"</code>, where the free wildcard can match against a sub-path with multiple segments. Note, that this solution implicitly supports the glob standard, e.g. <code>\"/some/path/**\"</code> will work as expected. The wildcards must follow a <code>/</code>.</p> <p>The arguments are available to the filters while processing the matched requests, but currently only a few built-in filters utilize them, and they can be used rather only from custom filter extensions.</p> <p>Known bug:</p> <p>There is a known bug with how predicates of the form <code>Path(\"/foo/*\")</code> are currently handled. Note the wildcard defined with <code>*</code> doesn\u2019t have a name here. Wildcards must have a name, but Skipper currently does not reject these routes, resulting in undefined behavior.</p> <p>Invalid patterns:</p> <p>Free wildcards (<code>*</code> or <code>**</code>) must be at the end of the path. Using a free wildcard in the middle of the path is invalid and will result in the error <code>free wildcard param should be last</code>. If you need to match a path segment in the middle, use a named parameter (<code>:param</code>) instead.</p> <p>Trailing slash:</p> <p>By default, <code>Path(\"/foo\")</code> and <code>Path(\"/foo/\")</code> are not equivalent. Ignoring the trailing slash can be toggled with the <code>-ignore-trailing-slash</code> command line flag.</p> <p>Examples:</p> <pre><code>Path(\"/foo/bar\")     //   /foo/bar\nPath(\"/foo/bar/\")    //   /foo/bar/, unless started with -ignore-trailing-slash\nPath(\"/foo/:id\")     //   /foo/_anything\nPath(\"/foo/:id/baz\") //   /foo/_anything/baz\nPath(\"/foo/*rest\")   //   /foo/bar/baz\nPath(\"/foo/**\")      //   /foo/bar/baz\n</code></pre>"},{"location":"reference/predicates/#pathsubtree","title":"PathSubtree","text":"<p>The path subtree predicate behaves similar to the path predicate, but it matches the exact path in the definition and any sub path below it. The subpath is automatically provided among the path parameters with the name <code>*</code>. If a free wildcard is appended to the definition, e.g. <code>PathSubtree(\"/some/path/*rest\")</code>, the free wildcard name is used instead of <code>*</code>. The simple wildcards behave similar to the Path predicate. The main difference between <code>PathSubtree(\"/foo\")</code> and <code>Path(\"/foo/**\")</code> is that the PathSubtree predicate always ignores the trailing slashes.</p> <p>Examples:</p> <pre><code>PathSubtree(\"/foo/bar\")\nPathSubtree(\"/\")\nPathSubtree(\"/foo/*rest\")\n</code></pre>"},{"location":"reference/predicates/#pathregexp","title":"PathRegexp","text":"<p>Regular expressions to match the path. It uses Go\u2019s standard library regexp package to match, which is based on re2 regular expression syntax.</p> <p>Parameters:</p> <ul> <li>PathRegexp (regex)</li> </ul> <p>A route can contain more than one PathRegexp predicates. It can be also used in combination with the Path predicate.</p> <pre><code>Path(\"/colors/:name/rgb-value\") &amp;&amp; PathRegexp(\"^/colors/(red|green|blue|cyan|magenta|pink|yellow)/\")\n-&gt; returnRGB()\n-&gt; &lt;shunt&gt;\n</code></pre> <p>Further examples:</p> <pre><code>PathRegexp(\"^/foo/bar\")\nPathRegexp(\"/foo/bar$\")\nPathRegexp(\"/foo/bar/\")\nPathRegexp(\"^/foo/(bar|qux)\")\n</code></pre>"},{"location":"reference/predicates/#host","title":"Host","text":"<p>Regular expressions that the host header in the request must match.</p> <p>Parameters:</p> <ul> <li>Host (regex)</li> </ul> <p>Examples:</p> <pre><code>Host(/^my-host-header\\.example\\.org$/)\nHost(/header\\.example\\.org$/)\n</code></pre>"},{"location":"reference/predicates/#hostany","title":"HostAny","text":"<p>Evaluates to true if request host exactly equals any of the configured hostnames.</p> <p>Parameters:</p> <ul> <li>hostnames (string)</li> </ul> <p>Examples:</p> <pre><code>HostAny(\"www.example.org\", \"www.example.com\")\nHostAny(\"localhost:9090\")\n</code></pre>"},{"location":"reference/predicates/#forwarded-header-predicates","title":"Forwarded header predicates","text":"<p>Uses standardized Forwarded header (RFC 7239)</p> <p>More info about the header: MDN</p> <p>If multiple proxies chain values in the header, as a comma separated list, the predicates below will only match the last value in the chain for each part of the header.</p> <p>Example: Forwarded: host=example.com;proto=https, host=example.org</p> <ul> <li><code>ForwardedHost(/^example\\.com$/)</code> - does not match</li> <li><code>ForwardedHost(/^example\\.org$/)</code> - matches</li> <li><code>ForwardedHost(/^example\\.org$/) &amp;&amp; ForwardedProto(\"https\")</code> - matches</li> <li><code>ForwardedHost(/^example\\.com$/) &amp;&amp; ForwardedProto(\"https\")</code> - does not match</li> </ul>"},{"location":"reference/predicates/#forwardedhost","title":"ForwardedHost","text":"<p>Regular expressions that the forwarded host header in the request must match.</p> <p>Parameters:</p> <ul> <li>Host (regex)</li> </ul> <p>Examples:</p> <pre><code>ForwardedHost(/^my-host-header\\.example\\.org$/)\nForwardedHost(/header\\.example\\.org$/)\n</code></pre>"},{"location":"reference/predicates/#forwardedprotocol","title":"ForwardedProtocol","text":"<p>Protocol the forwarded header in the request must match.</p> <p>Parameters:</p> <ul> <li>Protocol (string)</li> </ul> <p>Only \u201chttp\u201d and \u201chttps\u201d values are allowed</p> <p>Examples:</p> <pre><code>ForwardedProtocol(\"http\")\nForwardedProtocol(\"https\")\n</code></pre>"},{"location":"reference/predicates/#weight","title":"Weight","text":"<p>By default, the weight (priority) of a route is determined by the number of defined predicates.</p> <p>If you want to give a route more priority, you can give it more weight.</p> <p>Parameters:</p> <ul> <li>Weight (int)</li> </ul> <p>Example where <code>route2</code> has more priority because it has more predicates:</p> <pre><code>route1: Path(\"/test\") -&gt; \"http://www.zalando.de\";\nroute2: Path(\"/test\") &amp;&amp; True() -&gt; \"http://www.zalando.de\";\n</code></pre> <p>Example where <code>route1</code> has more priority because it has more weight:</p> <pre><code>route1: Path(\"/test\") &amp;&amp; Weight(100) -&gt; \"http://www.zalando.de\";\nroute2: Path(\"/test\") &amp;&amp; True() &amp;&amp; True() -&gt; \"http://www.zalando.de\";\n</code></pre>"},{"location":"reference/predicates/#true","title":"True","text":"<p>Does always match. Before <code>Weight</code> predicate existed this was used to give a route more weight.</p> <p>Example where <code>route2</code> has more weight.</p> <pre><code>route1: Path(\"/test\") -&gt; \"http://www.zalando.de\";\nroute2: Path(\"/test\") &amp;&amp; True() -&gt; \"http://www.github.com\";\n</code></pre>"},{"location":"reference/predicates/#false","title":"False","text":"<p>Does not match. Can be used to disable certain routes.</p> <p>Example where <code>route2</code> is disabled.</p> <pre><code>route1: Path(\"/test\") -&gt; \"http://www.zalando.de\";\nroute2: Path(\"/test\") &amp;&amp; False() -&gt; \"http://www.github.com\";\n</code></pre>"},{"location":"reference/predicates/#shutdown","title":"Shutdown","text":"<p>Evaluates to true if Skipper is shutting down. Can be used to create customized healthcheck.</p> <pre><code>health_up: Path(\"/health\") -&gt; inlineContent(\"OK\") -&gt; &lt;shunt&gt;;\nhealth_down: Path(\"/health\") &amp;&amp; Shutdown() -&gt; status(503) -&gt; inlineContent(\"shutdown\") -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/predicates/#method","title":"Method","text":"<p>The HTTP method that the request must match. HTTP methods are one of GET, HEAD, PATCH, POST, PUT, DELETE, OPTIONS, CONNECT, TRACE.</p> <p>Parameters:</p> <ul> <li>Method (string)</li> </ul> <p>Examples:</p> <pre><code>Method(\"GET\")\nMethod(\"OPTIONS\")\n</code></pre>"},{"location":"reference/predicates/#methods","title":"Methods","text":"<p>The HTTP method that the request must match. HTTP methods are one of GET, HEAD, PATCH, POST, PUT, DELETE, OPTIONS, CONNECT, TRACE.</p> <p>Parameters:</p> <ul> <li>Method (\u2026string) methods names</li> </ul> <p>Examples:</p> <pre><code>Methods(\"GET\")\nMethods(\"OPTIONS\", \"POST\")\nMethods(\"OPTIONS\", \"POST\", \"patch\")\n</code></pre>"},{"location":"reference/predicates/#header","title":"Header","text":"<p>A header key and exact value that must be present in the request. Note that Header(\u201cKey\u201d, \u201cValue\u201d) is equivalent to HeaderRegexp(\u201cKey\u201d, \u201c^Value$\u201d).</p> <p>Parameters:</p> <ul> <li>Header (string, string)</li> </ul> <p>Examples:</p> <pre><code>Header(\"X-Forwarded-For\", \"192.168.0.2\")\nHeader(\"Accept\", \"application/json\")\n</code></pre>"},{"location":"reference/predicates/#headerregexp","title":"HeaderRegexp","text":"<p>A header key and a regular expression, where the key must be present in the request and one of the associated values must match the expression.</p> <p>Parameters:</p> <ul> <li>HeaderRegexp (string, regex)</li> </ul> <p>Examples:</p> <pre><code>HeaderRegexp(\"X-Forwarded-For\", \"^192\\.168\\.0\\.[0-2]?[0-9]?[0-9]\")\nHeaderRegexp(\"Accept\", \"application/(json|xml)\")\n</code></pre>"},{"location":"reference/predicates/#cookie","title":"Cookie","text":"<p>Matches if the specified cookie is set in the request.</p> <p>Parameters:</p> <ul> <li>Cookie (string, regex) name and value match</li> </ul> <p>Examples:</p> <pre><code>Cookie(\"alpha\", /^enabled$/)\n</code></pre>"},{"location":"reference/predicates/#auth","title":"Auth","text":"<p>Authorization header based match.</p>"},{"location":"reference/predicates/#jwtpayloadanykv","title":"JWTPayloadAnyKV","text":"<p>Match the route if at least one of the base64 decoded JWT content matches the key value configuration.</p> <p>Parameters:</p> <ul> <li>Key-Value pairs (\u2026string), odd index is the key of the JWT   content and even index is the value of the JWT content</li> </ul> <p>Examples:</p> <pre><code>JWTPayloadAnyKV(\"iss\", \"https://accounts.google.com\")\nJWTPayloadAnyKV(\"iss\", \"https://accounts.google.com\", \"email\", \"skipper-router@googlegroups.com\")\n</code></pre>"},{"location":"reference/predicates/#jwtpayloadallkv","title":"JWTPayloadAllKV","text":"<p>Match the route if all of the base64 decoded JWT content matches the key value configuration.</p> <p>Parameters:</p> <ul> <li>Key-Value pairs (\u2026string), odd index is the key of the JWT   content and even index is the value of the JWT content</li> </ul> <p>Examples:</p> <pre><code>JWTPayloadAllKV(\"iss\", \"https://accounts.google.com\")\nJWTPayloadAllKV(\"iss\", \"https://accounts.google.com\", \"email\", \"skipper-router@googlegroups.com\")\n</code></pre>"},{"location":"reference/predicates/#jwtpayloadanykvregexp-jwtpayloadallkvregexp","title":"JWTPayloadAnyKVRegexp, JWTPayloadAllKVRegexp","text":"<p>Behaves exactly the same as <code>JWTPayloadAnyKV</code>, <code>JWTPayloadAllKV</code>, but the expected values are regular expressions that will be matched against the JWT value.</p> <p>Examples:</p> <pre><code>JWTPayloadAllKVRegexp(\"iss\", \"^https://\")\nJWTPayloadAnyKVRegexp(\"iss\", \"^https://\")\n</code></pre>"},{"location":"reference/predicates/#headersha256","title":"HeaderSHA256","text":"<p>Matches if SHA-256 hash of the header value (known as pre-shared key or secret) equals any of the configured hash values. Several hash values could be used to match multiple secrets e.g. during secret rotation.</p> <p>Hash values only hide secrets from parties that have access to the source of Skipper routes. Authentication strength depends on the strength of the secret value so e.g. <code>HeaderSHA256(\"X-Secret\", \"2bb80d537b1da3e38bd30361aa855686bde0eacd7162fef6a25fe97bf527a25b\")</code> is not stronger than just <code>Header(\"X-Secret\", \"secret\")</code>.</p> <p>The secret value must be kept secret, must be used by a single client and must be rotated periodically. See below how to generate random secret value using OpenSSL.</p> <p>Parameters:</p> <ul> <li>header name (string)</li> <li>one or more hex-encoded SHA-256 hashes of the matching header values (string)</li> </ul> <p>Secure secret value example: <pre><code>#\n# 1. Generate cryptographically secure pseudo random secret header value:\n# - length of at least 32 bytes (the size of the SHA-256 output)\n# - encode as -base64 or -hex to get ASCII text value\n#\nSECRET=$(openssl rand -base64 32)\necho $SECRET\n3YchPsliGjBXvyl/ncLWEI8/loKGrj/VNM4garxWEmA=\n\n#\n# 2. Get SHA-256 hash of the secret header value to use as HeaderSHA256 argument:\n# - use echo -n to not output the trailing newline\n#\necho -n $SECRET | sha256sum\na6131ba920df753c8109500cc11818f7192336d06532f6fa13009c2e4f6e1841  -\n</code></pre> <pre><code>// 3. Configure route to match hash of the secret value\nHeaderSHA256(\n    \"X-Secret\",\n    \"a6131ba920df753c8109500cc11818f7192336d06532f6fa13009c2e4f6e1841\"\n) -&gt; inlineContent(\"ok\\n\") -&gt; &lt;shunt&gt;\n</code></pre> <pre><code># 4. Test secret value\ncurl -H \"X-Secret: $SECRET\" http://localhost:9090\n</code></pre></p> <p>Secret rotation example: <pre><code>// To rotate secret:\n// * add new secret - both old and new secrets match during rotation\n// * update client to use new secret\n// * remove old secret\nHeaderSHA256(\n    \"X-Secret\",\n    \"cba06b5736faf67e54b07b561eae94395e774c517a7d910a54369e1263ccfbd4\", // SHA256(\"old\")\n    \"11507a0e2f5e69d5dfa40a62a1bd7b6ee57e6bcd85c67c9b8431b36fff21c437\"  // SHA256(\"new\")\n) -&gt; inlineContent(\"ok\\n\") -&gt; &lt;shunt&gt;\n</code></pre></p> <p>Basic access authentication example: <pre><code>anon: * -&gt; setResponseHeader(\"WWW-Authenticate\", `Basic realm=\"foo\", charset=\"UTF-8\"`) -&gt; status(401) -&gt; &lt;shunt&gt;;\nauth: HeaderSHA256(\n    \"Authorization\",\n    \"caae07e42ed8d231a58edcde95782b0feb67186172c18c89894ce4c2174df137\", // SHA256(\"Basic \" + BASE64(\"test:123\u00a3\"))\n    \"157da8472590f0ce0a7c651bd79aecb5cc582944fcf76cbabada915d333deee8\"  // SHA256(\"Basic \" + BASE64(\"Aladdin:open sesame\"))\n) -&gt; inlineContent(\"ok\\n\") -&gt; &lt;shunt&gt;;\n</code></pre></p>"},{"location":"reference/predicates/#interval","title":"Interval","text":"<p>An interval implements custom predicates to match routes only during some period of time.</p> <p>There are three predicates: Between, Before and After. All predicates can be created using the date represented as: * a string in RFC3339 format (see https://golang.org/pkg/time/#pkg-constants) * a string in RFC3339 format without numeric timezone offset and a location name corresponding to a file in the IANA Time Zone database * an <code>int64</code> or <code>float64</code> number corresponding to the given Unix time in seconds since January 1, 1970 UTC. <code>float64</code> number will be converted into <code>int64</code> number</p>"},{"location":"reference/predicates/#after","title":"After","text":"<p>Matches if the request is after the specified time</p> <p>Parameters:</p> <ul> <li>After (string) RFC3339 datetime string</li> <li>After (string, string) RFC3339 datetime string without timezone offset, location name</li> <li>After (int) unixtime in seconds</li> </ul> <p>Examples:</p> <pre><code>After(\"2016-01-01T12:00:00+02:00\")\nAfter(\"2021-02-18T00:00:00\", \"Europe/Berlin\")\nAfter(1451642400)\n</code></pre>"},{"location":"reference/predicates/#before","title":"Before","text":"<p>Matches if the request is before the specified time</p> <p>Parameters:</p> <ul> <li>Before (string) RFC3339 datetime string</li> <li>Before (string, string) RFC3339 datetime string without timezone offset, location name</li> <li>Before (int) unixtime in seconds</li> </ul> <p>Examples:</p> <pre><code>Before(\"2016-01-01T12:00:00+02:00\")\nBefore(\"2021-02-18T00:00:00\", \"Europe/Berlin\")\nBefore(1451642400)\n</code></pre>"},{"location":"reference/predicates/#between","title":"Between","text":"<p>Matches if the request is between the specified timeframe</p> <p>Parameters:</p> <ul> <li>Between (string, string) RFC3339 datetime string, from - till</li> <li>Between (string, string, string) RFC3339 datetime string without timezone offset, from - till and a location name</li> <li>Between (int, int) unixtime in seconds, from - till</li> </ul> <p>Examples:</p> <pre><code>Between(\"2016-01-01T12:00:00+02:00\", \"2016-02-01T12:00:00+02:00\")\nBetween(\"2021-02-18T00:00:00\", \"2021-02-18T01:00:00\", \"Europe/Berlin\")\nBetween(1451642400, 1454320800)\n</code></pre>"},{"location":"reference/predicates/#cron","title":"Cron","text":"<p>Matches routes when the given cron-like expression matches the system time.</p> <p>Parameters:</p> <ul> <li>Cron-like expression. See the package documentation for supported &amp; unsupported features. Expressions are expected to be in the same time zone as the system that generates the <code>time.Time</code> instances.</li> </ul> <p>Examples:</p> <pre><code>// match everything\nCron(\"* * * * *\")\n// match only when the hour is between 5-7 (inclusive)\nCron(\"* 5-7, * * *\")\n// match only when the hour is between 5-7, equal to 8, or between 12-15\nCron(\"* 5-7,8,12-15 * * *\")\n// match only when it is weekdays\nCron(\"* * * * 1-5\")\n// match only when it is weekdays &amp; working hours\nCron(\"* 7-18 * * 1-5\")\n</code></pre>"},{"location":"reference/predicates/#queryparam","title":"QueryParam","text":"<p>Match request based on the Query Params in URL</p> <p>Parameters:</p> <ul> <li>QueryParam (string) name</li> <li>QueryParam (string, regex) name and value match</li> </ul> <p>Examples:</p> <pre><code>// matches http://example.org?bb=a&amp;query=withvalue\nQueryParam(\"query\")\n\n// Even a query param without a value\n// matches http://example.org?bb=a&amp;query=\nQueryParam(\"query\")\n\n// matches with regexp\n// matches http://example.org?bb=a&amp;query=example\nQueryParam(\"query\", \"^example$\")\n\n// matches with regexp and multiple values of query param\n// matches http://example.org?bb=a&amp;query=testing&amp;query=example\nQueryParam(\"query\", \"^example$\")\n</code></pre>"},{"location":"reference/predicates/#source","title":"Source","text":"<p>Source implements a custom predicate to match routes based on the source IP or X-Forwarded-For header of a request.</p> <p>Parameters:</p> <ul> <li>Source (string, ..) varargs with IPs or CIDR</li> </ul> <p>Examples:</p> <pre><code>// only match requests from 1.2.3.4\nSource(\"1.2.3.4\")\n\n// only match requests from 1.2.3.0 - 1.2.3.255\nSource(\"1.2.3.0/24\")\n\n// only match requests from 1.2.3.4 and the 2.2.2.0/24 network\nSource(\"1.2.3.4\", \"2.2.2.0/24\")\n</code></pre>"},{"location":"reference/predicates/#sourcefromlast","title":"SourceFromLast","text":"<p>The same as Source, but use the last part of the X-Forwarded-For header to match the network. This seems to be only used in the popular loadbalancers from AWS, ELB and ALB, because they put the client-IP as last part of the X-Forwarded-For headers.</p> <p>Parameters:</p> <ul> <li>SourceFromLast (string, ..) varargs with IPs or CIDR</li> </ul> <p>Examples:</p> <pre><code>SourceFromLast(\"1.2.3.4\", \"2.2.2.0/24\")\n</code></pre>"},{"location":"reference/predicates/#clientip","title":"ClientIP","text":"<p>ClientIP implements a custom predicate to match routes based on the client IP of a request.</p> <p>Parameters:</p> <ul> <li>ClientIP (string, ..) varargs with IPs or CIDR</li> </ul> <p>Examples:</p> <pre><code>// only match requests from 1.2.3.4\nClientIP(\"1.2.3.4\")\n\n// only match requests from 1.2.3.0 - 1.2.3.255\nClientIP(\"1.2.3.0/24\")\n\n// only match requests from 1.2.3.4 and the 2.2.2.0/24 network\nClientIP(\"1.2.3.4\", \"2.2.2.0/24\")\n</code></pre>"},{"location":"reference/predicates/#tee","title":"Tee","text":"<p>The Tee predicate matches a route when a request is spawn from the teeLoopback filter as a tee request, using the same provided label.</p> <p>Parameters:</p> <ul> <li>tee label (string): the predicate will match only those requests that   were spawn from a teeLoopback filter using the same label.</li> </ul> <p>See also:</p> <ul> <li>teeLoopback filter</li> <li>Shadow Traffic Tutorial</li> </ul>"},{"location":"reference/predicates/#traffic","title":"Traffic","text":"<p>Traffic implements a predicate to control the matching probability for a given route by setting its weight.</p> <p>The probability for matching a route is defined by the mandatory first parameter, that must be a decimal number between 0.0 and 1.0 (both inclusive).</p> <p>The optional second argument is used to specify the cookie name for the traffic group, in case you want to use stickiness. Stickiness allows all subsequent requests from the same client to match the same route. Stickiness of traffic is supported by the optional third parameter, indicating whether the request being matched belongs to the traffic group of the current route. If yes, the predicate matches ignoring the chance argument.</p> <p>Parameters:</p> <ul> <li>Traffic (decimal) valid values [0.0, 1.0]</li> <li>Traffic (decimal, string, string) session stickiness</li> </ul> <p>Examples:</p> <p>non-sticky:</p> <pre><code>// hit by 10% percent chance\nv2:\n    Traffic(.1) -&gt;\n    \"https://api-test-green\";\n\n// hit by remaining chance\nv1:\n    * -&gt;\n    \"https://api-test-blue\";\n</code></pre> <p>stickiness:</p> <pre><code>// hit by 5% percent chance\ncartTest:\n    Traffic(.05, \"cart-test\", \"test\") &amp;&amp; Path(\"/cart\") -&gt;\n    responseCookie(\"cart-test\", \"test\") -&gt;\n    \"https://cart-test\";\n\n// hit by remaining chance\ncart:\n    Path(\"/cart\") -&gt;\n    responseCookie(\"cart-test\", \"default\") -&gt;\n    \"https://cart\";\n\n// hit by 15% percent chance\ncatalogTestA:\n    Traffic(.15, \"catalog-test\", \"A\") -&gt;\n    responseCookie(\"catalog-test\", \"A\") -&gt;\n    \"https://catalog-test-a\";\n\n// hit by 30% percent chance\ncatalogTestB:\n    Traffic(.3, \"catalog-test\", \"B\") -&gt;\n    responseCookie(\"catalog-test\", \"B\") -&gt;\n    \"https://catalog-test-b\";\n\n// hit by remaining chance\ncatalog:\n    * -&gt;\n    responseCookie(\"catalog-test\", \"default\") -&gt;\n    \"https://catalog\";\n</code></pre>"},{"location":"reference/predicates/#trafficsegment","title":"TrafficSegment","text":"<p>TrafficSegment predicate requires two number arguments \\(min\\) and \\(max\\) from an interval \\([0, 1]\\) (from zero included to one included) and \\(min &lt;= max\\).</p> <p>Let \\(r\\) be one-per-request uniform random number value from \\([0, 1)\\). TrafficSegment matches if \\(r\\) belongs to an interval from \\([min, max)\\). Upper interval boundary \\(max\\) is excluded to simplify definition of adjacent intervals - the upper boundary of the first interval then equals lower boundary of the next and so on, e.g. \\([0, 0.25)\\) and \\([0.25, 1)\\).</p> <p>This predicate has weight of -1 and therefore does not affect route weight.</p> <p>Parameters:</p> <ul> <li>min (decimal) from an interval [0, 1]</li> <li>max (decimal) from an interval [0, 1], min &lt;= max</li> </ul> <p>Example of routes splitting traffic in 50%+30%+20% proportion:</p> <pre><code>r50: Path(\"/test\") &amp;&amp; TrafficSegment(0.0, 0.5) -&gt; &lt;shunt&gt;;\nr30: Path(\"/test\") &amp;&amp; TrafficSegment(0.5, 0.8) -&gt; &lt;shunt&gt;;\nr20: Path(\"/test\") &amp;&amp; TrafficSegment(0.8, 1.0) -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"reference/predicates/#contentlengthbetween","title":"ContentLengthBetween","text":"<p>The ContentLengthBetween predicate matches a route when a request content length header value is between min and max provided values. In case the client does not specify the content length value then the predicate will not match.</p> <p>Parameters:</p> <ul> <li>min (int): the lower bound (inclusive) for the content length check. The value must be greater than or equal to 0.</li> <li>max (int): the upper bound (exclusive) for the content length check. The value must be greater than <code>min</code>.</li> </ul> <p>Examples:</p> <pre><code>// matches the range from 0 to 999\nContentLengthBetween(0, 1000)\n\n// matches the range from 1000 to 9999\nContentLengthBetween(1000, 10000)\n</code></pre>"},{"location":"reference/predicates/#opentelemetry-otel","title":"OpenTelemetry - OTel","text":"<p>OpenTelemetry (short OTel) based predicates are able to match based on OTel data.</p>"},{"location":"reference/predicates/#otelbaggage","title":"OTelBaggage","text":"<p>OpenTelemetry defined Baggage as W3C spec. OTelBaggage predicate is able to match the Baggage item by key.</p> <p>The example matches the key of a baggage item key <code>foo</code> whatever the baggage item value or property is:</p> <pre><code>OTelBaggage(\"foo\")\n</code></pre>"},{"location":"reference/routing/","title":"Routing","text":"<p>In Skipper (the HTTP router and reverse proxy), routing refers to the process of matching incoming HTTP requests to routes  and applying the associated filters and backend configurations. It provides multiple extension points to customize how routes are processed and how HTTP requests are handled.  These extension points allow us to modify route behavior at different stages of the routing lifecycle.</p> <p></p>"},{"location":"reference/routing/#extension-points-overview","title":"Extension Points Overview","text":"<p>Skipper offers three main extension points to customizing routing behavior:</p> <ol> <li>PreProcessors - Modify or inspect routes before they are instantiated (work with route definitions)</li> <li>Filters - Process individual HTTP requests and responses during runtime (work with traffic)</li> <li>PostProcessors - Modify or inspect routes after instantiation but before applied in active routing table (work with constructed routes)</li> </ol> <p>Each extension point operates at a different stage and serves different purposes. PreProcessors and PostProcessors are for route-level customization during routing table updates (i.e. in the control plane), while Filters are  for request-level processing during runtime traffic handling (i.e. in the data plane).</p>"},{"location":"reference/routing/#route-processors-preprocessors-postprocessors","title":"Route Processors (PreProcessors &amp; PostProcessors)","text":"<p>They allow us to transform, validate, or prepare routes before they become active in the routing table of the proxy.</p>"},{"location":"reference/routing/#processing-order","title":"Processing Order","text":"<p>When routes are loaded, they go through the following flow:</p> <ol> <li>DataClient loads raw route data from a source (file, database, etc.)</li> <li>PreProcessors run (can modify or inspect <code>eskip.Route</code> definitions)</li> <li>Routes are instantiated into <code>routing.Route</code> objects and Filters are created as defined by each route</li> <li>PostProcessors run (can modify or inspect instantiated routes)</li> <li>Routes become active in the routing table of the proxy</li> <li>Filters process HTTP requests/responses that match these routes</li> </ol> <p>This pipeline allows PreProcessors to work with lightweight route definitions, while PostProcessors can access fully  constructed route objects with filter instances and endpoint configurations. Filters operate later, during actual request processing.</p>"},{"location":"reference/routing/#preprocessors","title":"PreProcessors","text":"<p>PreProcessors are interfaces that process routes before they are instantiated from their <code>eskip.Route</code> representation. This allows modification or preparing prerequisites for the route definitions before they become part of the routing table.</p>"},{"location":"reference/routing/#interface","title":"Interface","text":"<p>Implements the following interface:</p> <pre><code>type PreProcessor interface {\n    Do([]*eskip.Route) []*eskip.Route\n}\n</code></pre>"},{"location":"reference/routing/#built-in-preprocessors","title":"Built-in PreProcessors","text":"<p>Skipper includes several built-in PreProcessors. Here are two examples.</p>"},{"location":"reference/routing/#defaultfilters-preprocessor","title":"DefaultFilters PreProcessor","text":"<p>Prepends and/or appends filters to all routes.</p> <p>Use case: Add common filters like logging, metrics, or authentication to all routes without manually adding them to each route definition.</p>"},{"location":"reference/routing/#opa-preprocessor","title":"OPA PreProcessor","text":"<p>Starts Open Policy Agent instances based on route definitions that include OPA related filters. Since OPA instances may take time to start, it handles initialization here rather than blocking route instantiation.</p> <p>Use case: Ensure OPA instances are created and started before OPA filter creation, to avoid delays during route instantiation.</p>"},{"location":"reference/routing/#postprocessors","title":"PostProcessors","text":"<p>PostProcessors are interfaces that process routes after they are instantiated from their data representation, and before they are passed to be effective in the routing table.</p>"},{"location":"reference/routing/#interface_1","title":"Interface","text":"<p>Implements this interface:</p> <pre><code>type PostProcessor interface {\n    Do([]*routing.Route) []*routing.Route\n}\n</code></pre>"},{"location":"reference/routing/#built-in-postprocessors","title":"Built-in PostProcessors","text":"<p>Skipper includes several built-in PostProcessors. Here is an example.</p>"},{"location":"reference/routing/#loadbalancer-algorithm-provider-postprocessor","title":"LoadBalancer Algorithm Provider PostProcessor","text":"<p>Initializes the load balancing algorithm for routes with LB backends.</p> <p>Implementation: <code>loadbalancer.NewAlgorithmProvider()</code> in <code>loadbalancer/algorithm.go</code></p> <p>Use case: Assigns appropriate load balancing algorithms (roundRobin, random, consistentHash, powerOfRandomNChoices, etc.) to routes with LB backends based on their configuration.</p>"},{"location":"reference/scripts/","title":"Lua filter scripts","text":"<p>LUA scripts can be used as filters in skipper. The current implementation supports Lua 5.1.</p>"},{"location":"reference/scripts/#route-filters","title":"Route filters","text":"<p>The lua scripts can be added to a route description with the <code>lua()</code> filter, the first parameter for the filter is the script. This can be either a file name (ending with <code>.lua</code>) or inline code, e.g. as</p> <ul> <li>file <code>lua(\"/path/to/file.lua\")</code> - if a file path is not absolute, the path  is relative to skipper\u2019s working directory.</li> <li>inline <code>lua(\"function request(c, p); print(c.request.url); end\")</code></li> </ul> <p>Any other additional parameters for the filter will be passed as a second table parameter to the called functions.</p> <p>Any parameter starting with \u201clua-\u201d should not be used to pass values for the script - those will be used for configuring the filter.</p>"},{"location":"reference/scripts/#script-requirements","title":"Script requirements","text":"<p>A filter script needs at least one global function: <code>request</code> or <code>response</code>. If present, they are called with a skipper filter context and the params passed in the route as table like <pre><code>-- route looks like\n--\n-- any: * -&gt; lua(\"./test.lua\", \"myparam=foo\", \"other=bar\", \"justkey\") -&gt; &lt;shunt&gt;\n--\nfunction request(ctx, params)\n    print(params[1])      -- myparam=foo\n    print(params[2])      -- other=bar\n    print(params[3])      -- justkey\n    print(params[4])      -- nil\n    print(params.myparam) -- foo\n    print(params.other)   -- bar\n    print(params.justkey) -- (empty string)\n    print(params.x)       -- nil\nend\n</code></pre></p> <p>Parameter table allows index access as well as key-value access</p>"},{"location":"reference/scripts/#print-builtin","title":"print builtin","text":"<p>Lua <code>print</code> builtin function writes skipper info log messages.</p>"},{"location":"reference/scripts/#sleep","title":"sleep","text":"<p><code>sleep(number)</code> function pauses execution for at least <code>number</code> milliseconds. A negative or zero duration causes <code>sleep</code> to return immediately.</p>"},{"location":"reference/scripts/#enable-and-disable-lua-sources","title":"Enable and Disable lua sources","text":"<p>The flag <code>-lua-sources</code> allows to set 5 different values:</p> <ul> <li>\u201cfile\u201d: Allows to use reference to file for scripts</li> <li>\u201cinline\u201d: Allows to use inline scripts</li> <li>\u201cinline\u201d, \u201cfile\u201d: Allows to use reference to file and inline scripts</li> <li>\u201cnone\u201d: Disable Lua filters</li> <li>\u201d\u201c: the same as \u201cinline\u201d, \u201cfile\u201d, the default value for binary and   library users</li> </ul>"},{"location":"reference/scripts/#available-lua-modules","title":"Available lua modules","text":"<p>Besides the standard modules - except for <code>debug</code> - the following additional modules have been preloaded and can be used with e.g. <code>local http = require(\"http\")</code>, see also the examples below</p> <ul> <li><code>http</code> gluahttp - TODO: configurable  with something different than <code>&amp;http.Client{}</code></li> <li><code>url</code> gluaurl</li> <li><code>json</code> gopher-json</li> <li><code>base64</code> lua base64</li> </ul> <p>For differences between the standard modules and the gopher-lua implementation check the gopher-lua documentation.</p> <p>Any other module can be loaded in non-byte code form from the lua path (by default for <code>require(\"mod\")</code> this is <code>./mod.lua</code>, <code>/usr/local/share/lua/5.1/mod.lua</code> and <code>/usr/local/share/lua/5.1/mod/init.lua</code>).</p> <p>You may selectively enable standard and additional Lua modules using <code>-lua-modules</code> flag: <pre><code>-lua-modules=package,base,json\n</code></pre> Note that preloaded additional modules require <code>package</code> module.</p> <p>For standard modules you may enable only a subset of module symbols: <pre><code>-lua-modules=base.print,base.assert\n</code></pre></p> <p>Use <code>none</code> to disable all modules: <pre><code>-lua-modules=none\n</code></pre></p> <p>See also http://lua-users.org/wiki/SandBoxes</p>"},{"location":"reference/scripts/#lua-states","title":"Lua states","text":"<p>There is no guarantee that the <code>request()</code> and <code>response()</code> functions of a lua script run in the same lua state during one request. Setting a variable in the request and accessing it in the response will most likely fail and lead to hard debuggable errors. Use the <code>ctx.state_bag</code> to propagate values from <code>request</code> to <code>response</code> - and any other filter in the chain.</p>"},{"location":"reference/scripts/#request-and-response","title":"Request and response","text":"<p>The <code>request()</code> function is run for an incoming request and <code>response()</code> for backend response.</p>"},{"location":"reference/scripts/#headers","title":"Headers","text":"<p>Request headers can be accessed via <code>ctx.request.header</code> table like <pre><code>ua = ctx.request.header[\"user-agent\"]\n</code></pre> and iterated like <pre><code>for k, v in ctx.request.header() do\n    print(k, \"=\", v);\nend\n</code></pre></p> <p>Header table is a functable that returns iterator</p> <p>Header names are normalized by the <code>net/http</code> go module like usual. Setting a header is done by assigning to the header table. Setting a header to <code>nil</code> or an empty string deletes the header - setting to <code>nil</code> is preferred.</p> <pre><code>ctx.request.header[\"user-agent\"] = \"skipper.lua/0.0.1\"\nctx.request.header[\"Authorization\"] = nil -- delete authorization header\n</code></pre> <p><code>header</code> table returns empty string for missing keys</p> <p>Response headers <code>ctx.response.header</code> work the same way - this is of course only valid in the <code>response()</code> phase.</p>"},{"location":"reference/scripts/#multiple-header-values","title":"Multiple header values","text":"<p>Request and response header tables provide access to a first value of a header.</p> <p>To access multiple values use <code>add</code> and <code>values</code> methods:</p> <pre><code>function request(ctx, params)\n    ctx.request.header.add(\"X-Foo\", \"Bar\")\n    ctx.request.header.add(\"X-Foo\", \"Baz\")\n\n    -- all X-Foo values\n    for _, v in pairs(ctx.request.header.values(\"X-Foo\")) do\n        print(v)\n    end\n\n    -- all values\n    for k, _ in ctx.request.header() do\n        for _, v in pairs(ctx.request.header.values(k)) do\n            print(k, \"=\", v)\n        end\n    end\nend\n</code></pre>"},{"location":"reference/scripts/#other-request-fields","title":"Other request fields","text":"<ul> <li><code>backend_url</code> - (read only) returns the backend url specified in the route   or an empty value if it\u2019s a shunt or loopback</li> <li><code>host</code> - (read only) the \u2018Host\u2019 header that was in the incoming   request to the proxy</li> <li><code>outgoing_host</code> - (read/write) the host that will be set for the outgoing   proxy request as the \u2018Host\u2019 header.</li> <li><code>remote_addr</code> - (read only) the remote host, usually IP:port</li> <li><code>content_length</code> - (read only) content length</li> <li><code>proto</code> - (read only) something like \u201cHTTP/1.1\u201d</li> <li><code>method</code> - (read only) request method, e.g. \u201cGET\u201d or \u201cPOST\u201d</li> <li><code>url</code> - (read/write) request URL as string</li> <li><code>url_path</code> - (read/write) request URL path as string</li> <li><code>url_query</code> - (read/write) request URL query parameter table, similar to header table but returns <code>nil</code> for missing keys</li> <li><code>url_raw_query</code> - (read/write) encoded request URL query values, without \u2018?\u2019 as string</li> <li><code>cookie</code> - (read only) request cookie table, similar to header table but returns <code>nil</code> for missing keys</li> </ul>"},{"location":"reference/scripts/#other-response-fields","title":"Other response fields","text":"<ul> <li><code>status_code</code> - (read/write) response status code as number, e.g. 200</li> </ul>"},{"location":"reference/scripts/#serving-requests-from-lua","title":"Serving requests from lua","text":"<p>Requests can be served with <code>ctx.serve(table)</code>, you must return after this call. Possible keys for the table:</p> <ul> <li><code>status_code</code> (number) - required (but currently not enforced)</li> <li><code>header</code> (table)</li> <li><code>body</code> (string)</li> </ul> <p>See also redirect and internal server error examples below</p>"},{"location":"reference/scripts/#path-parameters","title":"Path parameters","text":"<p>Path parameters (if any) can be read via <code>ctx.path_param</code> table <pre><code>Path(\"/api/:id\") -&gt; lua(\"function request(ctx, params); print(ctx.path_param.id); end\") -&gt; &lt;shunt&gt;\n</code></pre></p> <p><code>path_param</code> table returns <code>nil</code> for missing keys</p>"},{"location":"reference/scripts/#statebag","title":"StateBag","text":"<p>The state bag can be used to pass string, number and table values from one filter to another in the same chain. It is shared by all filters in one request (lua table values are only available to lua filters). <pre><code>function request(ctx, params)\n    -- the value of \"mykey\" will be available to all filters in the chain now:\n    ctx.state_bag[\"mykey\"] = \"foo\"\nend\n\nfunction response(ctx, params)\n    print(ctx.state_bag[\"mykey\"])\nend\n</code></pre></p> <p><code>state_bag</code> table returns <code>nil</code> for missing keys</p>"},{"location":"reference/scripts/#examples","title":"Examples","text":"<p>The examples serve as examples. If there is a go based plugin available, use that instead. For overhead estimate see benchmark.</p>"},{"location":"reference/scripts/#oauth2-token-as-basic-auth-password","title":"OAuth2 token as basic auth password","text":"<pre><code>local base64 = require(\"base64\")\n\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[\"Authorization\"], \"^%s*[Bb]earer%s+\", \"\", 1)\n    user = ctx.request.header[\"x-username\"]\n    if user == \"\" then\n        user = params.username\n    end\n    ctx.request.header[\"Authorization\"] = \"Basic \" .. base64.encode(user .. \":\"  .. token)\n    -- print(ctx.request.header[\"Authorization\"])\nend\n</code></pre>"},{"location":"reference/scripts/#validate-token","title":"validate token","text":"<pre><code>local http = require(\"http\")\nfunction request(ctx, params)\n    token = string.gsub(ctx.request.header[\"Authorization\"], \"^%s*[Bb]earer%s+\", \"\", 1)\n    if token == \"\" then\n        ctx.serve({status_code=401, body=\"Missing Token\"})\n        return\n    end\n\n    res, err = http.get(\"https://auth.example.com/oauth2/tokeninfo?access_token=\"..token)\n    if err ~= nil then\n        print(\"Failed to get tokeninfo: \" .. err)\n        ctx.serve({status_code=401, body=\"Failed to validate token: \"..err})\n        return\n    end\n    if res.status_code ~= 200 then\n        ctx.serve({status_code=401, body=\"Invalid token\"})\n        return\n    end\nend\n</code></pre>"},{"location":"reference/scripts/#strip-query","title":"strip query","text":"<pre><code>function request(ctx, params)\n    ctx.request.url = string.gsub(ctx.request.url, \"%?.*$\", \"\")\n    -- print(\"URL=\"..ctx.request.url)\nend\n</code></pre>"},{"location":"reference/scripts/#redirect","title":"redirect","text":"<pre><code>function request(ctx, params)\n    ctx.serve({\n        status_code=302,\n        header={\n            location=\"http://www.example.org/\",\n        },\n    })\nend\n</code></pre>"},{"location":"reference/scripts/#internal-server-error","title":"internal server error","text":"<pre><code>function request(ctx, params)\n    -- let 10% of all requests fail with 500\n    if math.random() &lt; 0.1 then\n        ctx.serve({\n            status_code=500,\n            body=\"Internal Server Error.\\n\",\n        })\n    end\nend\n</code></pre>"},{"location":"reference/scripts/#set-request-header-from-params","title":"set request header from params","text":"<pre><code>function request(ctx, params)\n    ctx.request.header[params[1]] = params[2]\n    if params[1]:lower() == \"host\" then\n        ctx.request.outgoing_host = params[2]\n    end\nend\n</code></pre>"},{"location":"reference/scripts/#benchmark","title":"Benchmark","text":""},{"location":"reference/scripts/#redirectto-vs-lua-redirect","title":"redirectTo vs lua redirect","text":"<p>See skptesting/benchmark-lua.sh</p> <p>Route for \u201cskipper\u201d is <code>* -&gt; redirectTo(302, \"http://localhost:9980\") -&gt; &lt;shunt&gt;</code>, route for \u201clua\u201d is <code>* -&gt; lua(\"function request(c,p); c.serve({status_code=302, header={location='http://localhost:9980'}});end\") -&gt; &lt;shunt&gt;</code></p> <p>Benchmark results <pre><code>[benchmarking skipper-redirectTo]\nRunning 12s test @ http://127.0.0.1:9990/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.19ms    5.38ms  69.50ms   85.10%\n    Req/Sec    26.16k     2.63k   33.22k    64.58%\n  Latency Distribution\n     50%    1.85ms\n     75%    6.38ms\n     90%   11.66ms\n     99%   23.34ms\n  626122 requests in 12.04s, 91.36MB read\nRequests/sec:  51996.22\nTransfer/sec:      7.59MB\n[benchmarking skipper-redirectTo done]\n\n[benchmarking redirect-lua]\nRunning 12s test @ http://127.0.0.1:9991/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     6.81ms    9.69ms 122.19ms   85.95%\n    Req/Sec    21.17k     2.83k   30.63k    73.75%\n  Latency Distribution\n     50%    2.21ms\n     75%   10.22ms\n     90%   19.88ms\n     99%   42.54ms\n  507434 requests in 12.06s, 68.72MB read\nRequests/sec:  42064.69\nTransfer/sec:      5.70MB\n[benchmarking redirect-lua done]\n</code></pre> show lua performance is ~80% of native.</p> <p>The benchmark was run with the default pool size of <code>script.InitialPoolSize = 3; script.MaxPoolSize = 10</code>. With <code>script.InitialPoolSize = 128; script.MaxPoolSize = 128</code> (tweaked for this benchmark) you get &gt;95% of native performance in lua: <pre><code>[benchmarking skipper-redirectTo]\nRunning 12s test @ http://127.0.0.1:9990/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.15ms    5.24ms  62.27ms   84.88%\n    Req/Sec    25.81k     2.64k   32.74k    70.00%\n  Latency Distribution\n     50%    1.88ms\n     75%    6.49ms\n     90%   11.43ms\n     99%   22.49ms\n  617499 requests in 12.03s, 90.10MB read\nRequests/sec:  51336.87\nTransfer/sec:      7.49MB\n[benchmarking skipper-redirectTo done]\n\n[benchmarking redirect-lua]\nRunning 12s test @ http://127.0.0.1:9991/lorem.html\n  2 threads and 128 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.79ms    4.98ms  91.19ms   87.15%\n    Req/Sec    25.14k     4.71k   51.45k    72.38%\n  Latency Distribution\n     50%    1.61ms\n     75%    5.17ms\n     90%   10.05ms\n     99%   21.83ms\n  602630 requests in 12.10s, 81.61MB read\nRequests/sec:  49811.24\nTransfer/sec:      6.75MB\n[benchmarking redirect-lua done]\n</code></pre></p> <p>Similar results are achieved when testing <code>stripQuery()</code> vs the lua version from above.</p>"},{"location":"tutorials/auth/","title":"Authentication and Authorization","text":""},{"location":"tutorials/auth/#basic-auth","title":"Basic auth","text":"<p>Basic Auth is defined in RFC7617.</p> <p>Install htpasswd command line tool, we assume Debian based system. Please refer the documentation of your Operating System or package management vendor how to install <code>htpasswd</code>:</p> <pre><code>apt-get install apache2-utils\n</code></pre> <p>Create a htpasswd file <code>foo.passwd</code> and use <code>captain</code> with password <code>apassword</code>:</p> <pre><code>htpasswd -bcB foo.passwd captain apassword\n</code></pre> <p>Start skipper with a <code>basicAuth</code> filter referencing the just created htpasswd file:</p> <pre><code>./bin/skipper -address :8080 -inline-routes 'r: * -&gt; basicAuth(\"foo.passwd\") -&gt; status(200) -&gt; &lt;shunt&gt;'\n</code></pre> <p>A client request without login credentials or wrong credentials:</p> <pre><code>% curl localhost:8080/ -v\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 401 Unauthorized\n&lt; Server: Skipper\n&lt; Www-Authenticate: Basic realm=\"Basic Realm\"\n&lt; Date: Thu, 01 Nov 2018 21:27:18 GMT\n&lt; Content-Length: 0\n&lt;\n* Connection #0 to host localhost left intact\n</code></pre> <p>A client request with the correct credentials:</p> <pre><code>% curl captain:apassword@localhost:8080/ -v\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n* Server auth using Basic with user 'captain'\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:8080\n&gt; Authorization: Basic Y2FwdGFpbjphcGFzc3dvcmQ=\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Server: Skipper\n&lt; Date: Thu, 01 Nov 2018 21:29:21 GMT\n&lt; Content-Length: 0\n&lt;\n* Connection #0 to host localhost left intact\n</code></pre>"},{"location":"tutorials/auth/#token-service-to-service","title":"Token service-to-service","text":"<p>Service to service authentication and authorization is often done by using the HTTP Authorization header with the content prefix \u201cBearer \u201c, for example \u201cAuthorization: Bearer mytoken\u201d.</p> <p>Supported token formats</p> <ul> <li>OAuth2 access tokens</li> <li>JWT</li> </ul>"},{"location":"tutorials/auth/#tokeninfo","title":"Tokeninfo","text":"<p>Tokeninfo is a common, but not specified protocol, only supporting Bearer tokens in the Authorization header.</p> <p>In most cases you would have to have your own OAuth2 token infrastructure, that can return JWT or OAuth2 access tokens to authenticated parties and validate tokens with their custom tokeninfo endpoint. In case of JWT the access token is signed and can be validated without a central tokeninfo endpoint.</p> <p>Example route:</p> <pre><code>all: Path(\"/\")\n     -&gt; oauthTokeninfoAnyScope(\"read-X\", \"readwrite-X\")\n     -&gt; \"http://localhost:9090/\"\n</code></pre> <p>The access token should be passed from the client as Bearer token in the Authorization header. Skipper will send this token unchanged as Bearer token in the Authorization header to the Tokeninfo endpoint. The request flow with a Tokeninfo setup is shown in the following picture:</p> <p></p>"},{"location":"tutorials/auth/#tokenintrospection-rfc7662","title":"Tokenintrospection RFC7662","text":"<p>Tokenintrospection service to service authentication and authorization is specified by RFC7662. Skipper uses RFC Draft for discovering token infrastructure configuration, to find the <code>introspection_endpoint</code>.</p> <p>Example route:</p> <pre><code>all: *\n        -&gt; oauthTokenintrospectionAnyKV(\"https://identity.example.com/managed-id\", \"jdoe\")\n        -&gt; \"http://localhost:9090/\";\n</code></pre> <p>The access token should be passed from the client as Bearer token in the Authorization header. Skipper will send this token as defined in RFC7662 in a POST request \u201capplication/x-www-form-urlencoded\u201d as value for key <code>token</code> to the Tokenintrospection endpoint. The request flow with Tokenintrospection setup is shown in the following picture:</p> <p></p>"},{"location":"tutorials/auth/#openid-connect","title":"OpenID Connect","text":"<p>OpenID Connect is an OAuth2.0 based authentication and authorization mechanism supported by several providers. Skipper can act as a proxy for backend server which requires authenticated clients. Skipper handles the authentication with the provider and upon successful completion of authentication passes subsequent requests to the backend server.</p> <p>Skipper\u2019s implementation of OpenID Connect Client works as follows:</p> <ol> <li>Filter is initialized with the following parameters:<ol> <li>Secrets file with keys used for encrypting the token in a cookie and also for generating shared secret.</li> <li>OpenID Connect Provider URL</li> <li>The Client ID</li> <li>The Client Secret</li> <li>The Callback URL for the client when a user successfully authenticates and is     returned.</li> <li>The Scopes to be requested along with the <code>openid</code> scope</li> <li>The claims that should be present in the token or the fields need in the user     information.</li> </ol> </li> <li>The user makes a request to a backend which is covered by an OpenID filter.</li> <li>Skipper checks if a cookie is set with any previous successfully completed OpenID authentication.</li> <li>If the cookie is valid then Skipper passes the request to the backend.</li> <li>If the cookie is not valid then Skipper redirects the user to the OpenID provider with its Client ID and a callback URL.</li> <li>When the user successfully completes authentication the provider redirects the user to the callback URL with a token.</li> <li>Skipper receives this token and makes a backend channel call to get an ID token     and other required information.</li> <li>If all the user information/claims are present then it encrypts this and sets a cookie     which is encrypted and redirects the user to the originally requested URL.</li> </ol> <p>To use OpenID define a filter for a backend which needs to be covered by OpenID Connection authentication.</p> <pre><code>oauthOidcAllClaims(\"https://accounts.identity-provider.com\", \"some-client-id\",\n    \"some-client-secret\", \"http://callback.com/auth/provider/callback\", \"scope1 scope2\",\n    \"claim1 claim2\") -&gt; \"https://internal.example.org\";\n</code></pre> <p>Here <code>scope1 scope2</code> are the scopes that should be included which requesting authentication from the OpenID provider. Any number of scopes can be specified here. The <code>openid</code> scope is added automatically by the filter. The other fields which need to be specified are the URL of the provider which in the above example is <code>https://accounts.identity-provider.com</code>. The client ID and the client secret. The callback URL which is specified while generating the client id and client secret. Then the scopes and finally the claims which should be present along with the return id token.</p> <pre><code>oauthOidcUserInfo(\"https://oidc-provider.example.com\", \"client_id\", \"client_secret\",\n    \"http://target.example.com/subpath/callback\", \"email profile\",\n    \"name email picture\") -&gt; \"https://internal.example.org\";\n</code></pre> <p>This filter is similar but it verifies that the token has certain user information information fields accessible with the token return by the provider. The fields can be specified at the end like in the example above where the fields <code>name</code>, <code>email</code> and <code>picture</code> are requested.</p> <p>Upon successful authentication Skipper will start allowing the user requests through to the backend. Along with the original request to the backend Skipper will include information which it obtained from the provider. The information is in <code>JSON</code> format with the header name <code>Skipper-Oidc-Info</code>. In the case of the claims container the header value is in the format.</p> <pre><code>{\n    \"oauth2token\": \"xxx\",\n    \"claims\": {\n        \"claim1\": \"val1\",\n        \"claim2\": \"val2\"\n    },\n    \"subject\": \"subj\"\n}\n</code></pre> <p>In the case of a user info filter the payload is in the format:</p> <pre><code>{\n    \"oauth2token\": \"xxx\",\n    \"userInfo\": {\n        \"sub\": \"sub\",\n        \"profile\": \"prof\",\n        \"email\": \"abc@example.com\",\n        \"email_verified\": \"abc@example.com\"\n    },\n    \"subject\": \"subj\"\n}\n</code></pre> <p>Skipper encrypts the cookies and also generates a nonce during the OAuth2.0 flow for which it needs a secret key. This key is in a file which can be rotated periodically because it is reread by Skipper. The path to this file must be passed with the flag <code>-oidc-secrets-file</code> when Skipper is started.</p>"},{"location":"tutorials/auth/#authz-and-access-control","title":"AuthZ and access control","text":"<p>Authorization validation and access control is available by means of a subsequent filter oidcClaimsQuery. It inspects the ID token, which exists after a successful <code>oauthOidc*</code> filter step, and validates the defined query with the request path.</p> <p>Given following example ID token:</p> <pre><code>{\n  \"email\": \"someone@example.org\",\n  \"groups\": [\n    \"CD-xyz\",\n    \"appX-Tester\"\n  ],\n  \"name\": \"Some One\"\n}\n</code></pre> <p>Access to path <code>/</code> would be granted to everyone in <code>example.org</code>, however path <code>/login</code> only to those being member of <code>group \"appX-Tester\"</code>:</p> <pre><code>oauthOidcAnyClaims(...) -&gt; oidcClaimsQuery(\"/login:groups.#[==\\\"appX-Tester\\\"]\", \"/:@_:email%\\\"*@example.org\\\"\")\n</code></pre>"},{"location":"tutorials/auth/#oauth2-authorization-grant-flow","title":"OAuth2 authorization grant flow","text":"<p>Authorization grant flow is a mechanism to coordinate between a user-agent, a client, and an authorization server to obtain an OAuth2 access token for a user. Skipper supports the flow with the <code>oauthGrant()</code> filter. It works as follows:</p> <ol> <li>A user makes a request to a route with <code>oauthGrant()</code>.</li> <li>The filter checks whether the request has a cookie called <code>oauth-grant</code><sup>1</sup>. If it does not, or    if the cookie and its tokens are invalid, it redirects the user to the OAuth2 provider\u2019s    authorization endpoint<sup>2</sup>.</li> <li>The user logs into the external OAuth2 provider, e.g. by providing a username and password.</li> <li>The provider redirects the user back to Skipper with an authorization code, using the    <code>redirect_uri</code> URL parameter which was part of the previous redirect<sup>2</sup>. The callback route must    have a <code>grantCallback()</code> filter defined. Skipper automatically adds this callback route for you    when the OAuth2 authorization grant flow feature is enabled. Note that the automatically added      callback route does not apply default filters.      If you need default filters to be applied to the callback route as well, please register      the route manually in your routes files.</li> <li>Skipper calls the provider\u2019s token URL with the authorization code, and receives a response    with the access and refresh tokens.</li> <li>Skipper stores the tokens in an <code>oauth-grant</code><sup>1</sup> cookie which is stored in the user\u2019s browser.</li> <li>Subsequent calls to any route with an <code>oauthGrant()</code> filter will now pass as long as the    access token is valid.</li> </ol> <p><sup>1</sup> The name of this cookie can be changed by providing the <code>-oauth2-token-cookie-name</code> parameter.</p> <p><sup>2</sup> The value of <code>redirect_uri</code> parameter of the authorization flow could be set by providing <code>-oauth2-auth-url-parameters=redirect_uri=https://example.org/oauth-callback</code>.    If not set Skipper will automatically determine it based on the initial request hostname and <code>-oauth2-callback-path</code> flag value.</p> <p>Please note that it is not currently possible to use multiple OAuth2 providers with Skipper.</p>"},{"location":"tutorials/auth/#encrypted-cookie-tokens","title":"Encrypted cookie tokens","text":"<p>The cookie set by the <code>oauthGrant()</code> filter contains the OAuth2 access and refresh tokens in encrypted form. This means Skipper does not need to persist any session information about users, while also not exposing the tokens to users.</p>"},{"location":"tutorials/auth/#token-refresh","title":"Token refresh","text":"<p>The <code>oauthGrant()</code> filter also supports token refreshing. Once the access token expires and the user makes another request, the filter automatically refreshes the token and sets the updated cookie in the response.</p>"},{"location":"tutorials/auth/#instructions","title":"Instructions","text":"<p>To use authorization grant flow, you need to:</p> <ol> <li>Configure OAuth2 credentials.</li> <li>Configure the grant filters with OAuth2 URLs.</li> <li>Add the OAuth2 grant filters to routes.</li> </ol>"},{"location":"tutorials/auth/#configure-oauth2-credentials","title":"Configure OAuth2 credentials","text":"<p>Before you start, you need to register your application with the OAuth2 provider. If your provider asks you for the callback URL, provide the URL that you set as the <code>-oauth2-callback-path</code> parameter. If you did not provide a value, use the default route : <code>/.well-known/oauth2-callback</code>.</p> <p>Skipper must be configured with the following credentials and secrets:</p> <ol> <li>OAuth2 client ID for authenticating with the OAuth2 provider.</li> <li>OAuth2 client secret for authenticating with the OAuth2 provider.</li> <li>Cookie encryption secret for encrypting and decrypting token cookies.</li> </ol> <p>You can load all of these secrets from separate files, in which case they get automatically reloaded to support secret rotation. You can provide the paths to the files containing each secret as follows:</p> <pre><code>skipper -oauth2-client-id-file=/path/to/client_id \\\n    -oauth2-client-secret-file=/path/to/client_secret \\\n    -oauth2-secret-file=/path/to/cookie_encryption_secret \\\n    -credentials-update-interval=30s\n</code></pre> <p>Paths may contain <code>{host}</code> placeholder which will be replaced by the request host. This is used to define separate credentials for different hosts.</p> <p>Care must be taken when used in conjunction with <code>-credentials-paths</code> option because files from <code>-credentials-paths</code> are available to <code>bearerinjector</code> filter. That is <code>-credentials-paths=/path/to</code> in above example will expose grant files to <code>bearerinjector</code> filter.</p> <p>You can modify the secret update interval using the <code>-credentials-update-interval</code> argument. In example above, the interval is configured to reload the secrets from the files every 30 seconds.</p> <p>If you prefer, you can provide the client ID and secret values directly as arguments to Skipper instead of loading them from files. In that case, call Skipper with:</p> <pre><code>skipper -oauth2-client-id=&lt;CLIENT_ID&gt; -oauth2-client-secret=&lt;CLIENT_SECRET&gt;\n</code></pre>"},{"location":"tutorials/auth/#configure-the-grant-filters","title":"Configure the grant filters","text":"<p>The grant filters need to be enabled and configured with your OAuth2 provider\u2019s authorization, token, and tokeninfo endpoints. This can be achieved by providing Skipper with the following arguments:</p> <pre><code>skipper -enable-oauth2-grant-flow \\\n    -oauth2-auth-url=&lt;OAUTH2_AUTHORIZE_ENDPOINT&gt; \\\n    -oauth2-token-url=&lt;OAUTH2_TOKEN_ENDPOINT&gt; \\\n    -oauth2-revoke-token-url=&lt;OAUTH2_REVOKE_TOKEN_ENDPOINT&gt; \\\n    -oauth2-tokeninfo-url=&lt;OAUTH2_TOKENINFO_ENDPOINT&gt; \\\n    -oauth2-callback-path=/oauth/callback\n</code></pre> <p>The <code>-oauth2-revoke-token-url</code> is optional, and should be supplied if you plan to use the grantLogout filter to revoke tokens.</p> <p>You can configure the <code>oauthGrant()</code> filter further for your needs. See the oauthGrant filter reference for more details.</p>"},{"location":"tutorials/auth/#add-filters-to-your-routes","title":"Add filters to your routes","text":"<p>You can protect any number of routes with the <code>oauthGrant()</code> filter. Unauthenticated users will be refused access and redirected to log in.</p> <p>Skipper will automatically add a callback route for you with the <code>grantCallback</code> filter registered on it. The path for this route can be configured with the <code>-oauth2-callback-path</code> parameter. If the parameter is not given, it will be <code>/.well-known/oauth2-callback</code></p> <p>You can optionally add a <code>grantLogout()</code> filter to delete token cookie. If <code>-oauth2-revoke-token-url</code> is set it will revoke access and refresh tokens:</p> <pre><code>foo:\n    Path(\"/foo\")\n    -&gt; oauthGrant()\n    -&gt; \"http://localhost:9090\";\n\nlogout:\n    Path(\"/logout)\n    -&gt; grantLogout()\n    -&gt; redirectTo(302)\n    -&gt; &lt;shunt&gt;;\n</code></pre>"},{"location":"tutorials/auth/#optional-authz-and-access-control","title":"(Optional) AuthZ and access control","text":"<p>You can add a grantClaimsQuery filter after a oauthGrant to control access based on any OAuth2 claim. A claim is any property returned by the tokeninfo endpoint. The filter works exactly like the oidcClaimsQuery filter (it is actually just an alias for it).</p> <p>For example, if your tokeninfo endpoint returns the following JSON:</p> <pre><code>{\n    \"scope\": [\"email\"],\n    \"username\": \"foo\"\n}\n</code></pre> <p>you could limit the access to a given route only to users that have the <code>email</code> scope by doing the following:</p> <ol> <li>Append a <code>grantClaimsQuery</code> filter to the <code>oauthGrant</code> filter with the following    query:     <pre><code>-&gt; oauthGrant() -&gt; grantClaimsQuery(\"/path:scope.#[==\\\"email\\\"]\")\n</code></pre></li> <li>Provide the name of the claim that corresponds to the OAuth2 subject in the    tokeninfo payload as an argument to Skipper:    <pre><code>skipper -oauth2-tokeninfo-subject-key=username\n</code></pre></li> </ol> <p>The subject is the field that identifies the user and is often called <code>sub</code>, especially in the context of OpenID Connect. In the example above, it is <code>username</code>.</p>"},{"location":"tutorials/auth/#open-policy-agent","title":"Open Policy Agent","text":"<p>To enable Open Policy Agent filter, use the <code>-enable-open-policy-agent</code> command line flag.</p> <p>Open Policy Agent is integrated as a Go library so no extra setup is needed to run. Every filter creates a virtual OPA instance in memory that is configured using a configuration file in the same configuration format that a standalone OPA would use. To allow for configurability, the configuration file is interpolated using Go Templates to allow every virtual instance to pull different bundles. This template file is passed using the <code>-open-policy-agent-config-template</code> flag.</p>"},{"location":"tutorials/auth/#configuration-file","title":"Configuration File","text":"<p>As an example, the following initial config can be used</p> <pre><code>services:\n  - name: bundle-service\n    url: https://my-example-opa-bucket.s3.eu-central-1.amazonaws.com\n    credentials:\n      s3_signing:\n        environment_credentials: {}\nlabels:\n  environment: production\ndiscovery:\n  name: discovery\n  prefix: \"/applications/{{ .bundlename }}\"\n</code></pre> <p>The variable <code>.bundlename</code> is the first argument in the following filters and can be in any format that OPA can understand, so for example application IDs from a registry, uuids, \u2026</p>"},{"location":"tutorials/auth/#input-structures","title":"Input Structures","text":"<p>Input structures to policies follow those that are used by the opa-envoy-plugin, the existing examples and documentation apply also to Skipper. Please note that the filters in Skipper always generate v3 input structures.</p>"},{"location":"tutorials/auth/#passing-context-to-the-policy","title":"Passing context to the policy","text":"<p>Generally there are two ways to pass context to a policy:</p> <ol> <li>as part of the labels in Open Policy Agent (configured in the configuration file, see below) that should be used for deployment level taxonomy,</li> <li>as part of so called context extensions that are part of the Envoy external auth specification.</li> </ol> <p>This context can be passed as second argument to filters:</p> <p><code>opaAuthorizeRequest(\"my-app-id\", \"com.mycompany.myprop: myvalue\")</code> or <code>opaAuthorizeRequest(\"my-app-id\", \"{'com.mycompany.myprop': 'my value'}\")</code></p> <p>The second argument is parsed as YAML, cannot be nested and values need to be strings.</p> <p>In Rego this can be used like this <code>input.attributes.contextExtensions[\"com.mycompany.myprop\"] == \"my value\"</code></p>"},{"location":"tutorials/auth/#decision-id-in-policies","title":"Decision ID in Policies","text":"<p>Each evaluation yields a distinct decision, identifiable by its unique decision ID. This decision ID can be located within the input at: <code>input.attributes.metadataContext.filterMetadata.open_policy_agent.decision_id</code> Typical use cases are either propagation of the decision ID to downstream systems or returning it as part of the response. As an example this can allow to trouble shoot deny requests by looking up details using the full decision in a control plane.</p>"},{"location":"tutorials/auth/#quick-start","title":"Quick Start","text":"<p>Create a directory called <code>bundles/my-application/</code>. </p> <p>Paste the following content into a file called <code>bundles/my-application/policy.rego</code>:</p> <pre><code># For more information see:\n#\n#   * Rego Rules: https://www.openpolicyagent.org/docs/latest/#rules\n\npackage envoy.http.public\n\n# If neither of the rules below match, `allow` is `false`.\ndefault allow := false\n\nallow if {\n    input.attributes.request.http.method == \"GET\"\n    input.attributes.request.http.path == \"/\"\n}\n\nallow if input.attributes.request.http.headers.authorization == \"Basic charlie\"\n</code></pre> <p>Build the bundle with <code>opa build -b ./bundles/my-application/ -o bundles/my-application.tar.gz</code>.</p> <p>Run an https server to serve the bundle: <code>python3 -m http.server 8000 --directory bundles/</code></p> <p>Place the following file in your local directory with the name <code>opaconfig.yaml</code></p> <pre><code>bundles:\n  play:\n    resource: \"{{ .bundlename }}.tar.gz\"\n    polling:\n      long_polling_timeout_seconds: 45\nservices:\n  - name: play\n    url: http://localhost:8000/\nplugins:\n  envoy_ext_authz_grpc:\n    # This needs to match the package, defaulting to envoy/authz/allow\n    path: envoy/http/public/allow\n    dry-run: false\ndecision_logs:\n  console: true\nstatus:\n  console: true\n</code></pre> <p>Start Skipper with</p> <pre><code>skipper -enable-open-policy-agent -open-policy-agent-config-template opaconfig.yaml --metrics-flavour=prometheus \\\n  -inline-routes 'notfound: * -&gt; opaAuthorizeRequest(\"my-application\") -&gt; inlineContent(\"&lt;h1&gt;Authorized Hello&lt;/h1&gt;\") -&gt; &lt;shunt&gt;'\n</code></pre> <p>You can test the policy with</p> <ul> <li>Authorized: <code>curl http://localhost:9090/ -i</code></li> <li>Authorized: <code>curl http://localhost:9090/foobar -H \"Authorization: Basic charlie\" -i</code></li> <li>Forbidden: <code>curl http://localhost:9090/foobar -i</code></li> </ul>"},{"location":"tutorials/basics/","title":"Basics","text":""},{"location":"tutorials/basics/#architecture","title":"Architecture","text":"<p>The core business of skipper is routing based on HTTP. It performs and scales well, for example it handles more than 800000 routes in production with 60000 requests per second.</p> <p>Skipper is written as a library and is also a multi binary project with 2 binaries, named <code>skipper</code> and <code>eskip</code>. <code>Skipper</code> is the HTTP proxy and <code>eskip</code> is a CLI application to verify, print, update or delete Skipper routes.</p> <p>Skipper\u2019s internal architecture is split into different packages. The <code>skipper</code> package has connections to multiple <code>dataclient</code>, that pull information from different sources, for example local routes from an eskip file or dynamic routes from Kubernetes ingress objects.</p> <p>The <code>proxy</code> package gets the routes populated by skipper and has always a current routing table which will be replaced on change.</p> <p>A route is one entry in the routing table. A route consists of one or more <code>predicate</code>, that are used to find a route for a given HTTP request. A route can also have one or more <code>filter</code>, that can modify the content of the request or response.  A route can point to a backend, it can be a <code>&lt;shunt&gt;</code>, meaning that skipper serves the requests for the route, a <code>&lt;loopback&gt;</code>, meaning that the requests will be matched against the routing table again after filters have modified them, or a <code>&lt;dynamic&gt;</code>, meaning that the target backend must be set in a filter.</p> <p>Opentracing API is supported via <code>tracers</code> and you can find all of them in <code>./tracing/tracers/</code>. For example Jaeger is supported.</p> <p>Skipper has a rich set of metrics that are exposed as json, but can also be exported in Prometheus format.</p> <p></p>"},{"location":"tutorials/basics/#concepts","title":"Concepts","text":""},{"location":"tutorials/basics/#route-definition","title":"Route definition","text":"<p>A route consists of an ID, predicates, filters and a backend and is most often written in eskip syntax.</p> <p>Syntax:</p> <pre><code>ID:\n        Predicate1() &amp;&amp; .. &amp;&amp; PredicateN()\n        -&gt; filter1()\n        ...\n        -&gt; filterN()\n        -&gt; BACKEND\n</code></pre> <p>An example routing configuration:</p> <pre><code>baidu:\n        Path(\"/baidu\")\n        -&gt; setRequestHeader(\"Host\", \"www.baidu.com\")\n        -&gt; setPath(\"/s\")\n        -&gt; setQuery(\"wd\", \"godoc skipper\")\n        -&gt; \"http://www.baidu.com\";\ngoogle:\n        *\n        -&gt; setPath(\"/search\")\n        -&gt; setQuery(\"q\", \"godoc skipper\")\n        -&gt; \"https://www.google.com\";\nyandex:\n        * &amp;&amp; Cookie(\"yandex\", \"true\")\n        -&gt; setPath(\"/search/\")\n        -&gt; setQuery(\"text\", \"godoc skipper\")\n        -&gt; tee(\"http://127.0.0.1:12345/\")\n        -&gt; \"https://yandex.ru\";\n</code></pre>"},{"location":"tutorials/basics/#predicate","title":"Predicate","text":"<p>A Predicate adds a matching rule to a route. For example the Cookie predicate, <code>Cookie(\"yandex\", \"true\")</code>, matched if there is a cookie in the request with name \u201cyandex\u201d and the value is \u201ctrue\u201d, else the route processing will go on and try to find another matching route for the given request. Multiple predicates can be combined by <code>&amp;&amp;</code> which means a logical AND. If you need a logical OR, you have to create another route.</p> <p>Special Predicates:</p> <ul> <li><code>*</code> catch all is always true</li> <li><code>Path()</code> reduces the number of routes in O(log n) time to scan afterwards a subset in linear time</li> <li><code>PathSubtree()</code> reduces the number of routes O(log n) time to scan afterwards a subset in linear time</li> </ul>"},{"location":"tutorials/basics/#predicate-and-routing-table","title":"Predicate and routing table","text":"<p>A routing table consists of a number of routes.  A route has a list of predicates and filters.  Predicates match an incoming request to a specific, best matching, route.  Each route has a set of filters.</p> <p></p>"},{"location":"tutorials/basics/#filter","title":"Filter","text":"<p>A filter changes a HTTP request or response or both. Multiple filters can be concatenated by <code>-&gt;</code>.</p> <p>Some special filters are:</p> <ul> <li><code>inlineContent()</code> sets the HTTP response body, should be used with status() filter and   backend <li><code>static()</code> serves static files and should be used with  backend <li><code>status()</code> sets HTTP status code to a given value, should be used with  backend <li><code>tee()</code> clones request to given target</li>"},{"location":"tutorials/basics/#filter-in-context-of-an-http-request","title":"Filter in context of an HTTP request","text":"<p>The picture shows the transformation of the requests and responses</p> <p></p>"},{"location":"tutorials/basics/#backend","title":"Backend","text":"<p>The last entry of a route is the backend definition, that will be called with the result request after filter processing. Normally this is an URL string.</p> <p>Special backends:</p> <ul> <li><code>&lt;loopback&gt;</code> restart route processing with the possibly changed request</li> <li><code>&lt;shunt&gt;</code> stops processing, used for fast returns</li> <li><code>&lt;dynamic&gt;</code> target is set dynamically in a filter</li> <li><code>&lt;$algorithm, \"be1\", \"be2\", ..., \"beN\"&gt;</code> load balanced backend with N backends</li> </ul> <p>See more about backends in backend references.</p>"},{"location":"tutorials/basics/#dataclient","title":"Dataclient","text":"<p>Dataclients are used to pull route information from a data source. The data will be used to create routes according to the dataclient. As a special case, for example kubernetes dataclient automatically adds HTTP-&gt;HTTPS redirects if skipper is started with <code>-kubernetes-https-redirect</code>.</p> <p>Dataclients:</p> <ul> <li>eskip file</li> <li>remote eskip</li> <li>route string</li> <li>kubernetes</li> <li>etcd</li> </ul>"},{"location":"tutorials/basics/#route-processing","title":"Route processing","text":"<p>Package <code>skipper</code> has a Go <code>http.Server</code> and does the <code>ListenAndServe</code> call with the <code>loggingHandler</code> wrapped <code>proxy</code>.  The <code>loggingHandler</code> is basically a middleware for the <code>proxy</code> providing access logs and both implement the plain Go http.Handler interface.</p> <p>For each incoming <code>http.Request</code> the <code>proxy</code> will create a request context and enhance it with an Opentracing API Span. It will check proxy global ratelimits first and after that lookup the route in the routing table. After that skipper will apply all request filters, that can modify the <code>http.Request</code>. It will then check the route local ratelimits, the circuitbreakers and do the backend call. If the backend call got a TCP or TLS connection error in a loadbalanced route, skipper will do a retry to another backend of that loadbalanced group automatically. Just before the response to the caller, skipper will process the response filters, that can change the <code>http.Response</code>.</p> <p>In two special cases, skipper doesn\u2019t forward the request to the backend. When the route is shunted (<code>&lt;shunt&gt;</code>), skipper serves the request alone, by using only the filters. When the route is a <code>&lt;loopback&gt;</code>, the request is passed to the routing table for finding another route, based on the changes that the filters made to the request. In case it will always find a <code>&lt;loopback&gt;</code> route it will stop after maximum number of loopbacks is reached and logs an error.</p> <p></p>"},{"location":"tutorials/basics/#routing-mechanism","title":"Routing mechanism","text":"<p>The routing executes the following steps in the typical case:</p> <ol> <li> <p>Select the best fitting route by matching the request against the    predicates. When no route found, respond with 404 (unless the default    status code is configured to a different value).</p> </li> <li> <p>Execute the filters defined in the route in normal order on the    request. The filters may or may not alter the request.</p> </li> <li> <p>Forward the request to the backend defined by the route and receive    a response.</p> </li> <li> <p>Execute the filters defined in the route in reverse order on the    response. The filters may or may not alter the response.</p> </li> <li> <p>Respond to the incoming request with the resulting response.</p> </li> </ol>"},{"location":"tutorials/basics/#route-matching","title":"Route matching","text":"<p>Skipper can handle a relatively large number of routes with acceptable performance, while being able to use any attribute of the incoming HTTP requests to distinguish between them. In order to be able to do so, the path matching predicates (<code>Path()</code> and <code>PathSubtree()</code> but not <code>PathRegexp()</code>) have a special role during route matching, which is a tradeoff by design, and needs to be kept in mind to understand in some cases why a certain route was matched for a request instead of another.</p> <p>The route matching logic can be summed up as follows:</p> <ol> <li> <p>Lookup in the path tree based on the <code>Path()</code> and the <code>PathSubtree()</code>    predicates, using the path component of the incoming request\u2019s URI. Then    the remaining predicates of the found route(s) are evaluated.</p> <ul> <li> <p>the path lookup is a radix tree with O(log(n)) time complexity</p> </li> <li> <p>in case of intersecting paths, the more specific path is matched in  the tree</p> </li> <li> <p><code>PathRegexp()</code> is not used in the tree, but it is evaluated only after  <code>Path()</code> or <code>PathSubtree()</code>, just like e.g. <code>Method()</code> or <code>Host()</code>.</p> </li> </ul> </li> <li> <p>If step #1 matches multiple routes, which means there are multiple    routes in the same position of the path tree, and all other predicates    match the request, too, then the route with the highest    weight is matched.</p> <ul> <li> <p>this is an O(n) lookup, but only on the same leaf</p> </li> <li> <p>the root of the tree is considered a single leaf, so if not using the   <code>Path()</code> or <code>PathSubtree()</code> predicates, the entire lookup will become O(n)   over all the routes.</p> </li> </ul> </li> <li> <p>If #2 results in multiple matching routes, then one route will be    selected. It is unspecified which one.</p> </li> </ol> <p>See more details about the predicates here: Predicates.</p>"},{"location":"tutorials/basics/#route-creation","title":"Route creation","text":"<p>Skipper has two kind of routes:</p> <ol> <li>eskip.Route</li> <li>routing.Route</li> </ol> <p>An <code>eskip.Route</code> is the parsed representation of user input. This will be converted to a <code>routing.Route</code>, when the routing table is built. A tree of <code>routing.Route</code> will be used to match an incoming Request to a route.</p> <p>Route creation steps:</p> <ol> <li>Skipper\u2019s route creation starts with the Dataclient    to fetch routes (<code>[]*eskip.Route</code>).</li> <li>These will be first processed by    <code>[]routing.PreProcessor</code>. PreProcessors are able to add, remove,    modify all <code>[]*eskip.Route</code>.</li> <li>After that <code>[]*eskip.Route</code> are converted to <code>[]*routing.Route</code>.</li> <li><code>[]routing.PostProcessor</code> are executed. PostProcessors are able to    add, remove, modify all <code>[]*routing.Route</code>.</li> <li>Last the active routing table is swapped. Now all incoming requests    are handled by the new routing table</li> </ol>"},{"location":"tutorials/basics/#building-skipper","title":"Building skipper","text":""},{"location":"tutorials/basics/#local-build","title":"Local build","text":"<p>To get a local build of skipper for your CPU architecture, you can run <code>make skipper</code>. To cross compile to non Linux platforms you can use:</p> <ul> <li><code>make build.darwin</code> for Mac OS X (amd64)</li> <li><code>make build.windows</code> for Windows (amd64)</li> </ul> <p>The local build will write into <code>./bin/</code> directory.</p>"},{"location":"tutorials/basics/#ci-build","title":"CI build","text":"<p>The current used CI flow to build the official docker container, you can see in delivery.yaml. Official release versions you will find at <code>registry.opensource.zalan.do/teapot/skipper:${RELEASE_VERSION}</code>, where <code>${RELEASE_VERSION}</code> is the git tag got by <code>$(git describe --tags --always --dirty)</code>.</p> <p>Test versions are released at <code>registry.opensource.zalan.do/teapot/skipper-test:${CDP_BUILD_VERSION}</code> for every pull request, limited to only repository members, because of compliance and security reasons.</p>"},{"location":"tutorials/basics/#testing-routes","title":"Testing routes","text":"<p>To test routes you can use a local build of skipper and pass arguments <code>-inline-routes=&lt;route string&gt;</code> or for more complex ones use a local <code>eskip</code> file on disk and use <code>-routes-file=&lt;filepath&gt;</code>.</p> <p>Example:</p> <pre><code>./bin/skipper -address :9999 -inline-routes 'r: * -&gt; setQuery(\"lang\", \"pt\") -&gt; \"http://127.0.0.1:8080/\"'\n</code></pre> <p>Now you have a proxy running that will set a query to your request URL and call <code>http://127.0.0.1:8080/?lang=pt</code></p> <p>The simplest way of testing a proxy is using a local backend and a local browser.</p> <p>Local backend example:</p> <pre><code>./bin/skipper -address :8080 -inline-routes 'r: * -&gt; inlineContent(\"Hello world!\") -&gt; status(200) -&gt; &lt;shunt&gt;'\n</code></pre> <p>If you want to do the request and see the response in detail, you can use <code>curl</code> as a browser, which should be installed on most Linux and Mac OS X computers.</p> <p>Example client call to our defined proxy:</p> <pre><code>% curl localhost:8080 -v\n* Rebuilt URL to: localhost:8080/\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 200 OK\n&lt; Content-Length: 12\n&lt; Content-Type: text/plain; charset=utf-8\n&lt; Server: Skipper\n&lt; Date: Thu, 01 Nov 2018 15:54:13 GMT\n&lt;\n* Connection #0 to host localhost left intact\nHello world!\n</code></pre>"},{"location":"tutorials/basics/#yaml-configuration","title":"YAML Configuration","text":"<p>The usage of flags to configure the <code>skipper</code> binary can get quickly out of hand. You can use a <code>yaml</code> file instead to populate the flags presented in the <code>skipper -help</code> command.</p> <pre><code>kubernetes: true\nkubernetes-in-cluster: true\nkubernetes-https-redirect: true\nproxy-preserve-host: true\nserve-host-metrics: true\naddress: \":8080\"\nenable-ratelimits: true\nexperimental-upgrade: true\nmetrics-exp-decay-sample: true\nmetrics-flavour: [\"codahale\",\"prometheus\"]\nenable-connection-metrics: true\nwhitelisted-healthcheck-cidr: \"172.20.0.0/16\"\nignore-trailing-slash: true\ninline-routes: 'r: * -&gt; inlineContent(\"Hello world!\") -&gt; status(200) -&gt; &lt;shunt&gt;'\n</code></pre> <p>Considering that this file would be named <code>config.yaml</code> you can use it to populate the flags using the <code>config-file</code> flag:</p> <pre><code>./bin/skipper -config-file=config.yaml\n</code></pre> <p>Performing the same call to the address as exemplified in the previous section should yield the same results.</p>"},{"location":"tutorials/basics/#current-routing-table","title":"Current routing table","text":"<p>To investigate the current routing table skipper has loaded into its memory, you can use the <code>-support-listener</code>, which defaults to port 9911 and you have to do a GET request to the <code>/routes</code> endpoint.</p> <p>Example:</p> <pre><code>% curl localhost:9911/routes\nr: *\n  -&gt; setQuery(\"lang\", \"pt\")\n  -&gt; \"http://127.0.0.1:8000\";\n</code></pre> <p>If you do not see your route, then you have most probably a syntax error in your route definition, such that the route was not loaded into memory.</p> <p>To print the number of routes, <code>X-Count</code> header, and the last update timestamp, <code>X-Timestamp</code> header, you can use a HEAD request to the support listener <code>/routes</code> endpoint:</p> <pre><code>% curl -I localhost:9911/routes\nHTTP/1.1 200 OK\nContent-Type: text/plain\nX-Count: 1\nX-Timestamp: 1541086036\nDate: Fri, 02 Nov 2018 00:30:43 GMT\n</code></pre> <p>For skipper operators the number of routes can be interesting for statistics and the timestamp to detect skipper instances that have not updated its routing table.</p> <p>If there are more than 1024 routes used, then paging the results is possible with the <code>offset</code> and <code>limit</code> query parameters:</p> <pre><code>curl localhost:9911/routes?offset=2048&amp;limit=512\n</code></pre>"},{"location":"tutorials/basics/#route-ids","title":"Route IDs","text":"<p>In the following example rid is the route ID:</p> <pre><code>% curl localhost:9911/routes\nrid: *\n  -&gt; setQuery(\"lang\", \"pt\")\n  -&gt; \"http://127.0.0.1:8000\";\n</code></pre> <p>If the route ID has a prefix <code>kube_</code>, then it is a route created by the Kubernetes dataclient. We do not disallow that you create manually routes with <code>kube_</code> prefix, but most of the time you should not use it in other routes to differentiate the routes created by other dataclients, in case you use multiple at the same time.</p>"},{"location":"tutorials/built-your-own/","title":"Built your own skipper proxy","text":"<p>One of the biggest advantages of skipper compared to other HTTP proxies is that skipper is a library first design. This means that it is common to built your custom proxy based on skipper.</p> <p>A minimal example project is skipper-example-proxy.</p> <pre><code>/*\nThis command provides an executable version of skipper with the default\nset of filters.\n\nFor the list of command line options, run:\n\n    skipper -help\n\nFor details about the usage and extensibility of skipper, please see the\ndocumentation of the root skipper package.\n\nTo see which built-in filters are available, see the skipper/filters\npackage documentation.\n*/\npackage main\n\nimport (\n    log \"github.com/sirupsen/logrus\"\n    lfilters \"github.com/szuecs/skipper-example-proxy/filters\"\n    \"github.com/zalando/skipper\"\n    \"github.com/zalando/skipper/config\"\n)\n\nfunc main() {\n    cfg := config.NewConfig()\n    if err := cfg.Parse(); err != nil {\n        log.Fatalf(\"Error processing config: %s\", err)\n    }\n\n    log.SetLevel(cfg.ApplicationLogLevel)\n\n    opt := cfg.ToOptions()\n    opt.CustomFilters = append(opt.CustomFilters, lfilters.NewMyFilter())\n\n    log.Fatal(skipper.Run(opt))\n}\n</code></pre>"},{"location":"tutorials/built-your-own/#code","title":"Code","text":"<p>Write the code and use the custom filter implemented in https://github.com/szuecs/skipper-example-proxy/blob/main/filters/custom.go <pre><code>[:~]% mkdir -p /tmp/go/skipper\n[:~]% cd /tmp/go/skipper\n[:/tmp/go/skipper]% go mod init myproject\ngo: creating new go.mod: module myproject\n[:/tmp/go/skipper]% cat &gt;main.go\npackage main\n\nimport (\n    log \"github.com/sirupsen/logrus\"\n    lfilters \"github.com/szuecs/skipper-example-proxy/filters\"\n    \"github.com/zalando/skipper\"\n    \"github.com/zalando/skipper/config\"\n)\n\nfunc main() {\n    cfg := config.NewConfig()\n    if err := cfg.Parse(); err != nil {\n        log.Fatalf(\"Error processing config: %s\", err)\n    }\n\n    log.SetLevel(cfg.ApplicationLogLevel)\n\n    opt := cfg.ToOptions()\n    opt.CustomFilters = append(opt.CustomFilters, lfilters.NewMyFilter())\n\n    log.Fatal(skipper.Run(opt))\n}\nCTRL-D\n[:/tmp/go/skipper]%\n</code></pre></p>"},{"location":"tutorials/built-your-own/#build","title":"Build","text":"<p>Fetch dependencies and build your skipper binary. <pre><code>[:/tmp/go/skipper]% go mod tidy\ngo: finding module for package github.com/zalando/skipper/config\ngo: finding module for package github.com/szuecs/skipper-example-proxy/filters\ngo: finding module for package github.com/sirupsen/logrus\ngo: finding module for package github.com/zalando/skipper\ngo: found github.com/sirupsen/logrus in github.com/sirupsen/logrus v1.9.3\ngo: found github.com/szuecs/skipper-example-proxy/filters in github.com/szuecs/skipper-example-proxy v0.0.0-20230622190245-63163cbaabc8\ngo: found github.com/zalando/skipper in github.com/zalando/skipper v0.16.117\ngo: found github.com/zalando/skipper/config in github.com/zalando/skipper v0.16.117\ngo: finding module for package github.com/nxadm/tail\ngo: finding module for package github.com/kr/text\ngo: finding module for package github.com/rogpeppe/go-internal/fmtsort\ngo: found github.com/kr/text in github.com/kr/text v0.2.0\ngo: found github.com/rogpeppe/go-internal/fmtsort in github.com/rogpeppe/go-internal v1.10.0\n...\n\n[:/tmp/go/skipper]% go build -o skipper .\n[:/tmp/go/skipper]%\n</code></pre></p>"},{"location":"tutorials/built-your-own/#test","title":"Test","text":"<p>We start the proxy</p> <pre><code># start the proxy\n[:/tmp/go/skipper]% ./skipper -inline-routes='* -&gt; myFilter() -&gt; status(250) -&gt; &lt;shunt&gt;'\n[APP]INFO[0000] Expose metrics in codahale format\n[APP]INFO[0000] enable swarm: false\n[APP]INFO[0000] Replacing tee filter specification\n[APP]INFO[0000] Replacing teenf filter specification\n[APP]INFO[0000] Replacing lua filter specification\n[APP]INFO[0000] support listener on :9911\n[APP]INFO[0000] Dataclients are updated once, first load complete\n[APP]INFO[0000] proxy listener on :9090\n[APP]INFO[0000] TLS settings not found, defaulting to HTTP\n[APP]INFO[0000] route settings, reset, route: : * -&gt; myFilter() -&gt; status(250) -&gt; &lt;shunt&gt;\n[APP]INFO[0000] route settings received\n[APP]INFO[0000] route settings applied\n127.0.0.1 - - [22/Jun/2023:21:13:46 +0200] \"GET /foo HTTP/1.1\" 250 0 \"-\" \"curl/7.49.0\" 0 127.0.0.1:9090 - -\n</code></pre> <p>Then we start the client to call the proxy endpoint. <pre><code># client\n% curl -v http://127.0.0.1:9090/foo\n*   Trying 127.0.0.1...\n* Connected to 127.0.0.1 (127.0.0.1) port 9090 (#0)\n&gt; GET /foo HTTP/1.1\n&gt; Host: 127.0.0.1:9090\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 250 status code 250   &lt;-- skipper core filter status(250)\n&lt; My-Filter: response            &lt;-- your custom filter myFilter()\n&lt; Server: Skipper\n&lt; Date: Thu, 22 Jun 2023 19:13:46 GMT\n&lt; Transfer-Encoding: chunked\n&lt;\n* Connection #0 to host 127.0.0.1 left intact\n</code></pre></p>"},{"location":"tutorials/common-use-cases/","title":"Common Use Cases","text":""},{"location":"tutorials/common-use-cases/#common-use-cases","title":"Common Use Cases","text":"<p>To understand common use cases, we assume you read the basics.</p>"},{"location":"tutorials/common-use-cases/#redirect-handling","title":"Redirect handling","text":"<p>If you want to do a redirect from a route, you can use the <code>redirectTo()</code> filter in combination with the <code>&lt;shunt&gt;</code> backend. If you do not specify a path in your redirect, then the path from the client will be passed further and not modified by the redirect.</p> <p>Example:</p> <pre><code>% ./bin/skipper -address :8080 -inline-routes 'r: * -&gt; redirectTo(308, \"http://127.0.0.1:9999\") -&gt; &lt;shunt&gt;'\n::1 - - [01/Nov/2018:18:42:02 +0100] \"GET / HTTP/1.1\" 308 0 \"-\" \"curl/7.49.0\" 0 localhost:8080 - -\n::1 - - [01/Nov/2018:18:42:08 +0100] \"GET /foo HTTP/1.1\" 308 0 \"-\" \"curl/7.49.0\" 0 localhost:8080 - -\n\n% curl localhost:8080 -v\n* Rebuilt URL to: localhost:8080/\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET / HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 308 Permanent Redirect\n&lt; Location: http://127.0.0.1:9999/\n&lt; Server: Skipper\n&lt; Date: Thu, 01 Nov 2018 17:42:18 GMT\n&lt; Content-Length: 0\n&lt;\n* Connection #0 to host localhost left intact\n\n% curl localhost:8080/foo -v\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET /foo HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 308 Permanent Redirect\n&lt; Location: http://127.0.0.1:9999/foo\n&lt; Server: Skipper\n&lt; Date: Thu, 01 Nov 2018 17:42:14 GMT\n&lt; Content-Length: 0\n&lt;\n* Connection #0 to host localhost left intact\n</code></pre>"},{"location":"tutorials/common-use-cases/#set-absolute-path","title":"set absolute path","text":"<p>If you set a path, in this example /, in your redirect definition, then the path is set to the chosen value. The Location header is set in the response to <code>/</code>, but the client sent <code>/foo</code>.</p> <pre><code>% ./bin/skipper -address :8080 -inline-routes 'r: * -&gt; redirectTo(308, \"http://127.0.0.1:9999/\") -&gt; &lt;shunt&gt;'\n\n% curl localhost:8080/foo -v\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET /foo HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 308 Permanent Redirect\n&lt; Location: http://127.0.0.1:9999/\n&lt; Server: Skipper\n&lt; Date: Thu, 01 Nov 2018 17:47:17 GMT\n&lt; Content-Length: 0\n&lt;\n* Connection #0 to host localhost left intact\n</code></pre>"},{"location":"tutorials/common-use-cases/#change-base-path","title":"change base path","text":"<p>If you want a redirect definition that adds a base path and the specified path by the client should be appended to this base path you can use the <code>modPath</code> filter just before the <code>redirectTo()</code> to modify the base path as you like.</p> <p>Route Example shows, that calls to <code>/a/base/foo/bar</code> would be redirected to <code>https://another-example.com/my/new/base/foo/bar</code>:</p> <pre><code>redirect: Path(\"/a/base/\")\n          -&gt; modPath(\"/a/base/\", \"/my/new/base/\")\n          -&gt; redirectTo(308, \"https://another-example.com\")\n          -&gt; &lt;shunt&gt;'\n</code></pre> <p>The next example shows how to test a redirect with changed base path on your computer:</p> <pre><code>% ./bin/skipper -address :8080 -inline-routes 'r: * -&gt; modPath(\"/\", \"/my/new/base/\") -&gt; redirectTo(308, \"http://127.0.0.1:9999\") -&gt; &lt;shunt&gt;'\n::1 - - [01/Nov/2018:18:49:45 +0100] \"GET /foo HTTP/1.1\" 308 0 \"-\" \"curl/7.49.0\" 0 localhost:8080 - -\n\n% curl localhost:8080/foo -v\n*   Trying ::1...\n* Connected to localhost (::1) port 8080 (#0)\n&gt; GET /foo HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.49.0\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 308 Permanent Redirect\n&lt; Location: http://127.0.0.1:9999/my/new/base/foo\n&lt; Server: Skipper\n&lt; Date: Thu, 01 Nov 2018 17:49:45 GMT\n&lt; Content-Length: 0\n&lt;\n* Connection #0 to host localhost left intact\n</code></pre>"},{"location":"tutorials/development/","title":"Development","text":""},{"location":"tutorials/development/#local-setup","title":"Local Setup","text":""},{"location":"tutorials/development/#build-skipper-binary","title":"Build Skipper Binary","text":"<p>Clone repository and compile with Go.</p> <pre><code>git clone https://github.com/zalando/skipper.git\ncd skipper\nmake skipper\n</code></pre> <p>binary will be <code>./bin/skipper</code></p>"},{"location":"tutorials/development/#run-skipper-as-proxy-with-2-backends","title":"Run Skipper as Proxy with 2 backends","text":"<p>As a small example, we show how you can run one proxy skipper and 2 backend skippers.</p> <p>Start the proxy that listens on port 9999 and serves all requests with a single route, that proxies to two backends using the round robin algorithm: <pre><code>./bin/skipper -inline-routes='r1: * -&gt; &lt;roundRobin, \"http://127.0.0.1:9001\", \"http://127.0.0.1:9002\"&gt;' --address :9999\n</code></pre></p> <p>Start two backends, with similar routes, one responds with \u201c1\u201d and the other with \u201c2\u201d in the HTTP response body: <pre><code>./bin/skipper -inline-routes='r1: * -&gt; inlineContent(\"1\") -&gt; &lt;shunt&gt;' --address :9001 &amp;\n./bin/skipper -inline-routes='r1: * -&gt; inlineContent(\"2\") -&gt; &lt;shunt&gt;' --address :9002\n</code></pre></p> <p>Test the proxy with curl as a client: <pre><code>curl -s http://localhost:9999/foo\n1\ncurl -s http://localhost:9999/foo\n2\ncurl -s http://localhost:9999/foo\n1\ncurl -s http://localhost:9999/foo\n2\n</code></pre></p>"},{"location":"tutorials/development/#debugging-skipper","title":"Debugging Skipper","text":"<p>It can be helpful to run Skipper in a debug session locally that enables one to inspect variables and do other debugging activities in order to analyze filter and token states.</p> <p>For Visual Studio Code users, a simple setup could be to create following launch configuration that compiles Skipper, runs it in a Delve debug session, and then opens the default web browser creating the request. By setting a breakpoint, you can inspect the state of the filter or application. This setup is especially useful when inspecting oauth flows and tokens as it allows stepping through the states.</p> Example `.vscode/launch.json` file <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Launch Package\",\n            \"type\": \"go\",\n            \"request\": \"launch\",\n            \"mode\": \"debug\",\n            \"program\": \"${workspaceFolder}/cmd/skipper/main.go\",\n            \"args\": [\n                \"-application-log-level=debug\",\n                \"-address=:9999\",\n                \"-inline-routes=PathSubtree(\\\"/\\\") -&gt; inlineContent(\\\"Hello World\\\") -&gt; &lt;shunt&gt;\",\n               // example OIDC setup, using https://developer.microsoft.com/en-us/microsoft-365/dev-program\n               //  \"-oidc-secrets-file=${workspaceFolder}/.vscode/launch.json\",\n               //  \"-inline-routes=* -&gt; oauthOidcAnyClaims(\\\"https://login.microsoftonline.com/&lt;tenant id&gt;/v2.0\\\",\\\"&lt;application id&gt;\\\",\\\"&lt;client secret&gt;\\\",\\\"http://localhost:9999/authcallback\\\", \\\"profile\\\", \\\"\\\", \\\"\\\", \\\"x-auth-email:claims.email x-groups:claims.groups\\\") -&gt; inlineContent(\\\"restricted access\\\") -&gt; &lt;shunt&gt;\",\n            ],\n            \"serverReadyAction\": {\n                \"pattern\": \"route settings applied\",\n                \"uriFormat\": \"http://localhost:9999\",\n                \"action\": \"openExternally\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"tutorials/development/#docs","title":"Docs","text":"<p>We have user documentation and developer documentation separated. In <code>docs/</code> you find the user documentation in mkdocs format and rendered at https://opensource.zalando.com/skipper which is updated automatically with each <code>docs/</code> change merged to <code>master</code> branch. Developer documentation for skipper as library users godoc format is used and rendered at https://pkg.go.dev/github.com/zalando/skipper.</p>"},{"location":"tutorials/development/#user-documentation","title":"User documentation","text":"<p>To see rendered documentation locally run <code>mkdocs serve</code> and navigate to http://127.0.0.1:8000.</p>"},{"location":"tutorials/development/#filters","title":"Filters","text":"<p>Filters allow to change arbitrary HTTP data in the Request or Response. If you need to read and write the http.Body, please make sure you discuss the use case before creating a pull request.</p> <p>A filter consists of at least two types a <code>filters.Spec</code> and a <code>filters.Filter</code>. Spec consists of everything that is needed and known before a user will instantiate a filter.</p> <p>A spec will be created in the bootstrap procedure of a skipper process. A spec has to satisfy the <code>filters.Spec</code> interface <code>Name() string</code> and <code>CreateFilter([]interface{}) (filters.Filter, error)</code>.</p> <p>The actual filter implementation has to satisfy the <code>filter.Filter</code> interface <code>Request(filters.FilterContext)</code> and <code>Response(filters.FilterContext)</code>.</p> <p>The simplest filter possible is, if <code>filters.Spec</code> and <code>filters.Filter</code> are the same type:</p> <pre><code>type myFilter struct{}\n\nfunc NewMyFilter() *myFilter {\n    return &amp;myFilter{}\n}\n\nfunc (spec *myFilter) Name() string { return \"myFilter\" }\n\nfunc (spec *myFilter) CreateFilter(config []interface{}) (filters.Filter, error) {\n     return NewMyFilter(), nil\n}\n\nfunc (f *myFilter) Request(ctx filters.FilterContext) {\n     // change data in ctx.Request() for example\n}\n\nfunc (f *myFilter) Response(ctx filters.FilterContext) {\n     // change data in ctx.Response() for example\n}\n</code></pre> <p>Find a detailed example at how to develop a filter.</p>"},{"location":"tutorials/development/#filters-with-cleanup","title":"Filters with cleanup","text":"<p>Sometimes your filter needs to cleanup resources on shutdown. In Go functions that do this have often the name <code>Close()</code>. There is the <code>filters.FilterCloser</code> interface and if you comply with it, the routing.Route will make sure your filters are closed if <code>routing.Routing</code> was closed.</p> <pre><code>type myFilter struct{}\n\nfunc NewMyFilter() *myFilter {\n    return &amp;myFilter{}\n}\n\nfunc (spec *myFilter) Name() string { return \"myFilter\" }\n\nfunc (spec *myFilter) CreateFilter(config []interface{}) (filters.Filter, error) {\n     return NewMyFilter(), nil\n}\n\nfunc (f *myFilter) Request(ctx filters.FilterContext) {\n     // change data in ctx.Request() for example\n}\n\nfunc (f *myFilter) Response(ctx filters.FilterContext) {\n     // change data in ctx.Response() for example\n}\n\nfunc (f *myFilter) Close() error {\n     // cleanup your filter\n}\n</code></pre>"},{"location":"tutorials/development/#filters-with-error-handling","title":"Filters with error handling","text":"<p>Sometimes you want to have a filter that wants to get called <code>Response()</code> even if the proxy will not send a response from the backend, for example you want to count error status codes, like the admissionControl filter. In this case you need to comply with the following proxy interface:</p> <pre><code>// errorHandlerFilter is an opt-in for filters to get called\n// Response(ctx) in case of errors.\ntype errorHandlerFilter interface {\n    // HandleErrorResponse returns true if a filter wants to get called\n    HandleErrorResponse() bool\n}\n</code></pre> <p>Example: <pre><code>type myFilter struct{}\n\nfunc NewMyFilter() *myFilter {\n    return &amp;myFilter{}\n}\n\nfunc (spec *myFilter) Name() string { return \"myFilter\" }\n\nfunc (spec *myFilter) CreateFilter(config []interface{}) (filters.Filter, error) {\n     return NewMyFilter(), nil\n}\n\nfunc (f *myFilter) Request(ctx filters.FilterContext) {\n     // change data in ctx.Request() for example\n}\n\nfunc (f *myFilter) Response(ctx filters.FilterContext) {\n     // change data in ctx.Response() for example\n}\n\nfunc (f *myFilter) HandleErrorResponse() bool() {\n     return true\n}\n</code></pre></p>"},{"location":"tutorials/development/#predicates","title":"Predicates","text":"<p>Predicates allow to match a condition, that can be based on arbitrary HTTP data in the Request. There are also predicates, that use a chance <code>Traffic()</code> or the current local time, for example <code>After()</code>, to match a request and do not use the HTTP data at all.</p> <p>A predicate consists of at least two types <code>routing.Predicate</code> and <code>routing.PredicateSpec</code>, which are both interfaces.</p> <p>A spec will be created in the bootstrap procedure of a skipper process. A spec has to satisfy the <code>routing.PredicateSpec</code> interface <code>Name() string</code> and <code>Create([]interface{}) (routing.Predicate, error)</code>.</p> <p>The actual predicate implementation has to satisfy the <code>routing.Predicate</code> interface <code>Match(*http.Request) bool</code> and returns true if the predicate matches the request. If false is returned, the routing table will be searched for another route that might match the given request.</p> <p>The simplest possible predicate implementation is, if <code>routing.PredicateSpec</code> and <code>routing.Predicate</code> are the same type:</p> <pre><code>type myPredicate struct{}\n\nfunc NewMyPredicate() routing.PredicateSpec {\n    return &amp;myPredicate{}\n}\n\nfunc (spec *myPredicate) Name() string { return \"myPredicate\" }\n\nfunc (spec *myPredicate) Create(config []interface{}) (routing.Predicate, error) {\n     return NewMyPredicate(), nil\n}\n\nfunc (f *myPredicate) Match(r *http.Request) bool {\n     // match data in *http.Request for example\n     return true\n}\n</code></pre> <p>Predicates are quite similar to implement as Filters, so for a more complete example, find an example how to develop a filter.</p>"},{"location":"tutorials/development/#dataclients","title":"Dataclients","text":"<p>Dataclients are the way how to integrate new route sources. Dataclients pull information from a source and create routes for skipper\u2019s routing table.</p> <p>You have to implement <code>routing.DataClient</code>, which is an interface that defines function signatures <code>LoadAll() ([]*eskip.Route, error)</code> and <code>LoadUpdate() ([]*eskip.Route, []string, error)</code>.</p> <p>The <code>LoadUpdate()</code> method can be implemented either in a way that returns immediately, or blocks until there is a change. The routing package will regularly call the <code>LoadUpdate()</code> method with a small delay between the calls.</p> <p>A complete example is the routestring implementation, which fits in less than 50 lines of code.</p>"},{"location":"tutorials/development/#opentracing","title":"Opentracing","text":"<p>Your custom Opentracing implementations need to satisfy the <code>opentracing.Tracer</code> interface from https://github.com/opentracing/opentracing-go and need to be loaded as a plugin, which might change in the future. Please check the tracing package and ask for further guidance in our community channels.</p>"},{"location":"tutorials/development/#core","title":"Core","text":"<p>Non trivial changes, proposals and enhancements to the core of skipper should be discussed first in a GitHub issue, such that we can think about how this fits best in the project and how to achieve the most useful result. Feel also free to reach out to our community channels and discuss there your idea.</p> <p>Every change in core has to have tests included and should be a non breaking change. We planned since a longer time a breaking change, but we should coordinate to make it as good as possible for all skipper as library users. Most often a breaking change can be postponed to the future and a feature independently added and the old feature might be deprecated to delete it later. Use of deprecated features should be shown in logs with a <code>log.Warning</code>.</p>"},{"location":"tutorials/operations/","title":"Operations","text":""},{"location":"tutorials/operations/#kubernetes","title":"Kubernetes","text":"<p>In the beginning we chose to run Skipper as daemonset to run it on all worker nodes. Since 2018 we run Skipper as deployment with an hpa, horizontal Pod autoscaler, to scale Skipper by CPU usage. All our clusters are using AWS autoscaling groups (ASG), to increase and decrease the number of running nodes in a cluster based on use.</p> <p>In both deployment styles we run Skipper with <code>hostnetwork: true</code> and point the loadbalancer in front of it to the skipper port of all worker nodes. In our case we run an AWS Application loadbalancer (ALB) in front, and we terminate TLS on the ALB. A health check from the ALB detects, if Skipper is running on a worker node or not.</p>"},{"location":"tutorials/operations/#first-steps","title":"First steps","text":"<p>The next part will show you how to run Skipper with a minimal feature set, that supports already most of the features.</p> <p>A minimal set of arguments that should be chosen to support most Kubernetes use cases:</p> <pre><code>          - \"skipper\"\n          - \"-kubernetes\"\n          - \"-kubernetes-in-cluster\"\n          - \"-kubernetes-path-mode=path-prefix\"\n          - \"-address=:9999\"\n          - \"-wait-first-route-load\"\n          - \"-proxy-preserve-host\"\n          - \"-enable-ratelimits\"\n          - \"-experimental-upgrade\"\n          - \"-metrics-flavour=prometheus\"\n          - \"-metrics-exp-decay-sample\"\n          - \"-serve-host-metrics\"\n          - \"-disable-metrics-compat\"\n          - \"-enable-connection-metrics\"\n          - \"-histogram-metric-buckets=.0001,.00025,.0005,.00075,.001,.0025,.005,.0075,.01,.025,.05,.075,.1,.2,.3,.4,.5,.75,1,2,3,4,5,7,10,15,20,30,60,120,300,600\"\n          - \"-max-audit-body=0\"\n          - \"-idle-timeout-server=62s\"\n</code></pre> <p>Skipper started with these options will support instance based ratelimits, a wide range of Prometheus metrics, websockets and a better HTTP path routing than the default Kubernetes Ingress spec supports.</p> <p>The former Kubernetes Ingress v1beta1 spec defined a path as regular expression, which is neither what most people would expect, nor want. Skipper defaults in Kubernetes to use the PathRegexp predicate for routing, because of the spec. We believe the better default is the path prefix mode, that uses PathSubtree predicate, instead. Path prefix search is much more scalable and cannot lead to unexpected results by not so experienced regular expressions users. Since Kubernetes v1.18, Ingress v1 path definition supports all path matching modes that are common in skipper:</p> <ul> <li><code>pathType: Exact</code> maps to <code>Path()</code></li> <li><code>pathType: Prefix</code> maps to <code>PathSubtree()</code></li> <li><code>pathType: ImplementationSpecific</code> is defined as you set path prefix mode.</li> </ul> <p>To find more information about Metrics, including formats and example Prometheus queries you find in the metrics section. The settings shown above support system and application metrics to carefully monitor Skipper and your backend applications. Backend application metrics get error rates and latency buckets based on host headers. The chosen options should safely run all workloads from small to high traffic.</p> <p>The option <code>-max-audit-body=0</code>, won\u2019t log the HTTP body, if you would do audit logging, to have a safe default.</p> <p>The last option <code>-idle-timeout-server=62s</code> was chosen, because of a known issue, if you run in a multi layer loadbalancer, with ALBs in front of Skipper. ALBs idle connection timeout is 60s and AWS support told us to run the backends with a bigger timeout, than the ALB in front.</p>"},{"location":"tutorials/operations/#opt-in-more-features","title":"Opt-In more features","text":""},{"location":"tutorials/operations/#reverse-source-predicate","title":"Reverse Source Predicate","text":"<p>Depending on the HTTP loadbalancer in front of your Skippers, you might want to set <code>-reverse-source-predicate</code>. This setting reverses the lookup of the client IP to find it in the <code>X-Forwarded-For</code> header values. If you do not care about clientRatelimits based on X-Forwarded-For headers, you can also ignore this.</p>"},{"location":"tutorials/operations/#cluster-ratelimit","title":"Cluster Ratelimit","text":"<p>Ratelimits can be calculated for the whole cluster instead of having only the instance based ratelimits. The common term we use in skipper documentation is cluster ratelimit. There are two option, but we highly recommend the use of Redis based cluster ratelimits. To support redis based cluster ratelimits you have to use <code>-enable-swarm</code> and add a list of URLs to redis <code>-swarm-redis-urls=skipper-ingress-redis-0.skipper-ingress-redis.kube-system.svc.cluster.local:6379,skipper-ingress-redis-1.skipper-ingress-redis.kube-system.svc.cluster.local:6379</code>. We run redis as statefulset with a headless service to have predictable names. We chose to not use a persistent volume, because storing the data in memory is good enough for this use case.</p>"},{"location":"tutorials/operations/#east-west","title":"East West","text":"<p>Attention</p> <p>This feature is deprecated. Consider using EastWest Range.</p> <p>Skipper supports cluster internal service-to-service communication as part of running as an API Gateway with an East-West setup. You have to add <code>-enable-kubernetes-east-west</code> and optionally choose a domain <code>-kubernetes-east-west-domain=.ingress.cluster.local</code>. Be warned: There is a known bug, if you combine it with custom routes. You might want to consider EastWest Range.</p>"},{"location":"tutorials/operations/#east-west-range","title":"East West Range","text":"<p>Alternatively, you can use Kubernetes East West Range feature. Use the flag <code>-kubernetes-east-west-range-domains</code> to define the cluster internal domains <code>-kubernetes-east-west-range-predicates</code> to define the predicates that will be appended to every route identified as an internal domain. Differently from the <code>-enable-kubernetes-east-west</code> and the <code>-kubernetes-east-west-domain=.ingress.cluster.local</code> flags (check East West) this feature will not automatically create routes for you and both features shouldn\u2019t be used in combination. The ingress and/or route groups resources must opt-in for east west range routes, explicitly defining them. For example, given that Skipper was initialized with the following east-west range flags:</p> <pre><code>skipper \\\n  -kubernetes-east-west-range-domains=\"ingress.cluster.local\" \\\n  -kubernetes-east-west-range-predicates='ClientIP(\"10.2.0.0/16\")'\n</code></pre> <p>and the following ingress is defined:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: qux\n  namespace: foo\nspec:\n  rules:\n  - host: example.ingress.cluster.local\n    http:\n      paths:\n      - path: \"/\"\n        pathType: Prefix\n        backend:\n          service:\n            name: qux\n            port:\n              name: baz\n</code></pre> <p>Skipper will secure this route adding the predicate <code>ClientIP(\"10.2.0.0/16\")</code>.</p> <p>The same ingress might be used for internal and external hostnames. For example, given a slightly modified version of the ingress:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n...\nspec:\n  rules:\n  - host: example.ingress.cluster.local\n    http: ...\n  - host: example.mydomain.org\n    http: ...\n</code></pre> <p>will make the service accessible through <code>example.ingress.cluster.local</code> and <code>example.mydomain.org</code>, but the first hostname will only accept connections from the network <code>10.2.0.0/16</code>, on this specific scenario.</p> <p>You can specify multiple east-west range domains and predicates:</p> <pre><code>skipper \\\n  -kubernetes-east-west-range-domains=\"ingress.cluster.local,another.cluster.local\"\n  -kubernetes-east-west-range-predicates='ClientIP(\"10.2.0.0/16\") &amp;&amp; SourceLastFrom(\"10.2.0.0/16\")'\n</code></pre>"},{"location":"tutorials/operations/#api-monitoring-and-auth","title":"API monitoring and Auth","text":"<p>As part of API Gateway features, skipper supports API monitoring and common authentication and authorization protocols in Microservices architectures.</p>"},{"location":"tutorials/operations/#opentracing","title":"OpenTracing","text":"<p>Skipper has support for different OpenTracing API vendors, including jaeger, lightstep and instana. For example to configure the lightstep opentracing plugin, with a searchable <code>component</code> and <code>cluster</code> <code>tag</code> you can use: <code>- \"-opentracing=lightstep component-name=skipper-ingress token=$(LIGHTSTEP_TOKEN) collector=tracing-collector.endpoint:8444 cmd-line=skipper-ingress max-buffered-spans=4096 tag=cluster=mycluster\"</code>. The <code>LIGHTSTEP_TOKEN</code> is passed as environment variable to the process.</p>"},{"location":"tutorials/operations/#global-default-filters","title":"Global default filters","text":"<p>Skipper can also add global default filters, which will be automatically added to all routes. For example you can use <code>-default-filters-prepend=\"enableAccessLog(4,5)\"</code> to enable only access logs in case of HTTP codes 4xx or 5xx. In the specific case of <code>*AccessLog</code> filters and <code>-default-filters-prepend</code>, the default choice can be overridden by users via <code>zalando.org/skipper-filter</code> ingress annotation.</p>"},{"location":"tutorials/operations/#production-example","title":"Production example","text":"<p>A full production deployment example you find at Zalando\u2019s configuration repository.</p>"},{"location":"tutorials/operations/#recommendations","title":"Recommendations","text":"<p>We recommend to run a loadbalancer in front of Skipper to terminate TLS, such that cluster users cannot access your keys and certificates. While skipper supports SNI, hardware and cloud loadbalancers often have hardware support to terminate TLS. It\u2019s cheaper for you to offload TLS to these devices and trust your compute vendor.</p> <p>We recommend to start simple and grow the feature set from there. Check features, that are used in <code>&gt;60</code> production clusters in Zalando\u2019s configuration repository.</p>"},{"location":"tutorials/operations/#dashboards","title":"Dashboards","text":"<p>As an operator, build a Skipper dashboard and learn how Skipper and the Go runtime behaves with your workload. We successfully ran several load tests from 0 to 25k requests per seconds.  The load test was ramping up in less than a minute with initially 3 Skipper Pods, with an HPA that has CPU target value of 100%.</p> <p>Operations dashboard:  </p> <p>Application metrics dashboard: </p>"},{"location":"tutorials/ratelimit/","title":"Ratelimits","text":""},{"location":"tutorials/ratelimit/#overview","title":"Overview","text":"<p>Ratelimits are calculated for a number of requests and a <code>time.Duration</code> for a given bucket. To enable rate limits you need to run skipper with <code>-enable-ratelimits</code>.</p> <p>A <code>time.Duration</code> is specified as string and can for example be \u201c10s\u201d for ten seconds, \u201c5m\u201d for five minutes or \u201c2h\u201d for two hours.</p> <p>As bucket skipper can use either the backend or some client information.</p> <p>In case of a backend ratelimit the bucket is only one global for one route.</p> <p>In case of a client ratelimit the buckets are created by the used <code>ratelimit.Lookuper</code>, which defaults to the <code>X-Forwarded-For</code> header, but can be also the <code>Authorization</code> header. So for the client ratelimit with <code>X-Forwarded-For</code> header, the client IP that the first proxy in the list sees will be used to lookup the bucket to count requests.</p>"},{"location":"tutorials/ratelimit/#instance-local-ratelimit","title":"Instance local Ratelimit","text":"<p>Filters <code>ratelimit()</code> and <code>clientRatelimit()</code> calculate the ratelimit in a local view having no information about other skipper instances.</p>"},{"location":"tutorials/ratelimit/#backend-ratelimit","title":"Backend Ratelimit","text":"<p>The backend ratelimit filter is <code>ratelimit()</code> and it is the simplest one. You can define how many requests a route allows for a given <code>time.Duration</code> to send to all backends of the route. This means that you cannot limit traffic to a single backend instance.</p> <p>For example to limit the route to 10 requests per minute for each skipper instance, you can specify:</p> <pre><code>ratelimit(10, \"1m\")\n</code></pre>"},{"location":"tutorials/ratelimit/#client-ratelimit","title":"Client Ratelimit","text":"<p>The client ratelimit filter is <code>clientRatelimit()</code> and it uses information from the request to find the bucket which will get the increased request count.</p> <p>For example to limit the route to 10 requests per minute for each skipper instance for the same client selected by the X-Forwarded-For header, you can specify:</p> <pre><code>clientRatelimit(10, \"1m\")\n</code></pre> <p>There is an optional third argument that selects the same client by HTTP header value. As an example for Authorization Header you would use:</p> <pre><code>clientRatelimit(10, \"1m\", \"Authorization\")\n</code></pre> <p>The optional third argument can create an AND combined Header ratelimit. The header names must be separated by <code>,</code>. For example all of the specified headers have to be the same to recognize them as the same client:</p> <pre><code>clientRatelimit(10, \"1m\", \"X-Forwarded-For,Authorization,X-Foo\")\n</code></pre> <p>Internally skipper has a clean interval to clean up old buckets to reduce the memory footprint in the long run.</p>"},{"location":"tutorials/ratelimit/#security-consideration","title":"Security Consideration","text":"<p>ClientRatelimit works on data provided by the client. In theory an attacker likely can workaround all of your configurations. On the other hand there is always a pattern in attacks, and you are more likely being able to find the pattern and mitigate the attack, if you have a powerful tool like the provided <code>clientRatelimit</code>.</p>"},{"location":"tutorials/ratelimit/#cluster-ratelimit","title":"Cluster Ratelimit","text":"<p>A cluster ratelimit computes all requests for all skipper peers. This requires, that you run skipper with <code>-enable-swarm</code> and select one of the two implementations:</p> <ul> <li>Redis</li> <li>SWIM</li> </ul> <p>Make sure all requirements, that are dependent on the implementation and your dataclient in use.</p>"},{"location":"tutorials/ratelimit/#redis-based-cluster-ratelimits","title":"Redis based Cluster Ratelimits","text":"<p>This solution is independent of the dataclient being used. You have to run one or more Redis instances. See also Running with Redis based Cluster Ratelimits.</p> <p>There are 3 different configurations to assign Redis instances as a Skipper Redis swarm.</p>"},{"location":"tutorials/ratelimit/#static","title":"Static","text":"<p>Specify <code>-swarm-redis-urls</code>, multiple instances can be separated by comma, for example: <code>-swarm-redis-urls=redis1:6379,redis2:6379</code>. Use this if you don\u2019t need to scale your Redis instances.</p>"},{"location":"tutorials/ratelimit/#kubernetes-service-selector","title":"Kubernetes Service Selector","text":"<p>Specify <code>-kubernetes-redis-service-namespace=&lt;namespace&gt;</code>, <code>-kubernetes-redis-service-name=&lt;name&gt;</code> and optional <code>-kubernetes-redis-service-port=&lt;port number&gt;</code>.</p> <p>Skipper will update Redis addresses every 10 seconds from specified service endpoints. This allows you to dynamically scale Redis instances. Note that when <code>-kubernetes</code> is set Skipper also fetches <code>Ingresses</code> and <code>RouteGroups</code> for routing, see ingress-controller deployment docs.</p>"},{"location":"tutorials/ratelimit/#http-endpoint","title":"HTTP Endpoint","text":"<p>Specify <code>-swarm-redis-remote=http://127.0.0.1/redis/endpoints</code>,</p> <p>Skipper will update Redis addresses every 10 seconds from this remote URL that should return data in the following JSON format: <pre><code>{\n    \"endpoints\": [\n        {\"address\": \"10.2.0.1:6379\"}, {\"address\": \"10.2.0.2:6379\"},\n        {\"address\": \"10.2.0.3:6379\"}, {\"address\": \"10.2.0.4:6379\"},\n        {\"address\": \"10.2.0.5:6379\"}\n    ]\n}\n</code></pre></p> <p>If you have routesrv proxy enabled, you need to configure Skipper with the flag <code>-swarm-redis-remote=http://&lt;routesrv-service-name&gt;.&lt;routesrv-namespace&gt;.svc.cluster.local/swarm/redis/shards</code>. <code>Routesrv</code> will be responsible for collecting Redis endpoints and Skipper will poll them from it.</p>"},{"location":"tutorials/ratelimit/#implementation","title":"Implementation","text":"<p>The implementation use Redis ring to be able to shard via client hashing and spread the load across multiple Redis instances to be able to scale out the shared storage.</p> <p>The ratelimit algorithm is a sliding window and makes use of the following Redis commands:</p> <ul> <li>ZREMRANGEBYSCORE,</li> <li>ZCARD,</li> <li>ZADD and</li> <li>ZRANGEBYSCORE</li> </ul> <p></p>"},{"location":"tutorials/ratelimit/#swim-based-cluster-ratelimits","title":"SWIM based Cluster Ratelimits","text":"<p>SWIM is a \u201cScalable Weakly-consistent Infection-style Process Group Membership Protocol\u201d, which is very interesting to use for cluster ratelimits. The implementation has some weaknesses in the algorithm, that lead sometimes to too much ratelimits or too few and therefore is not considered to be stable. For running skipper in Kubernetes with this, see also Running with SWIM based Cluster Ratelimits</p> <p>In case of Kubernetes you might specify additionally <code>-swarm-label-selector-key</code>, which defaults to \u201capplication\u201d and <code>-swarm-label-selector-value</code>, which defaults to \u201cskipper-ingress\u201d and <code>-swarm-namespace</code>, which defaults to \u201ckube-system\u201d.</p> <p>The following shows the setup of a SWIM based cluster ratelimit:</p> <p></p>"},{"location":"tutorials/ratelimit/#backend-ratelimit_1","title":"Backend Ratelimit","text":"<p>The backend ratelimit filter is <code>clusterRatelimit()</code>. You can define how many requests a route allows for a given <code>time.Duration</code> in total for all skipper instances summed up. The first parameter is the group parameter, which can be used to select the same ratelimit group across one or more routes</p> <p>For example rate limit \u201cgroupA\u201d limits the rate limit group to 10 requests per minute in total for the cluster, you can specify:</p> <pre><code>clusterRatelimit(\"groupA\", 10, \"1m\")\n</code></pre>"},{"location":"tutorials/ratelimit/#client-ratelimit_1","title":"Client Ratelimit","text":"<p>The client ratelimit filter is <code>clusterClientRatelimit()</code> and it uses information from the request to find the bucket which will get the increased request count.  You can define how many requests a client is allowed to hit this route for a given <code>time.Duration</code> in total for all skipper instances summed up. The first parameter is the group parameter, which can be used to select the same ratelimit group across one or more routes</p> <p>For example rate limit \u201cgroupB\u201d limits the rate limit group to 10 requests per minute for the full skipper swarm for the same client selected by the X-Forwarded-For header, you can specify:</p> <pre><code>clusterClientRatelimit(\"groupB\", 10, \"1m\")\n</code></pre> <p>The same for Authorization Header you would use:</p> <pre><code>clusterClientRatelimit(\"groupC\", 10, \"1m\", \"Authorization\")\n</code></pre> <p>The optional fourth argument can create an AND combined Header ratelimit. The header names must be separated by <code>,</code>. For example all of the specified headers have to be the same to recognize them as the same client:</p> <pre><code>clusterClientRatelimit(\"groupC\", 5, \"10s\", \"X-Forwarded-For,Authorization,X-Foo\")\n</code></pre> <p>Internally skipper has a clean interval to clean up old buckets to reduce the memory footprint in the long run.</p>"},{"location":"tutorials/ratelimit/#security-consideration_1","title":"Security Consideration","text":"<p>ClusterClientRatelimit works on data provided by the client. In theory an attacker likely can workaround all of your configurations. On the other hand there is always a pattern in attacks, and you are more likely being able to find the pattern and mitigate the attack, if you have a powerful tool like the provided <code>clusterClientRatelimit</code>.</p>"},{"location":"tutorials/shadow-traffic/","title":"Shadow Traffic","text":"<p>This tutorial will show how to setup routing for shadow traffic, where one backend (main) will receive the full traffic, while a shadowing backend (test) will receive only a certain percentage of the same traffic.</p>"},{"location":"tutorials/shadow-traffic/#used-predicates","title":"Used Predicates:","text":"<ul> <li>Tee</li> <li>Traffic</li> </ul>"},{"location":"tutorials/shadow-traffic/#used-filters","title":"Used Filters:","text":"<ul> <li>teeLoopback</li> </ul>"},{"location":"tutorials/shadow-traffic/#1-initial-state","title":"1. Initial state","text":"<p>Before the shadow traffic, we are sending all traffic to the main backend.</p> <pre><code>main: * -&gt; \"https://main.example.org\";\n</code></pre>"},{"location":"tutorials/shadow-traffic/#2-clone-the-main-route-handling-10-of-the-traffic","title":"2. Clone the main route, handling 10% of the traffic","text":"<p>Before generating the shadow traffic, we create an identical clone of the main route that will handle only 10% of the traffic, while the rest stays being handled by the main route.</p> <pre><code>main: * -&gt; \"https://main.example.org\";\nsplit: Traffic(.1) -&gt; \"https://main.example.org\";\n</code></pre>"},{"location":"tutorials/shadow-traffic/#3-prepare-the-route-for-the-shadow-traffic","title":"3. Prepare the route for the shadow traffic","text":"<p>The route introduced next won\u2019t handle directly any incoming requests, because they won\u2019t be matched by the Tee predicate, but it is prepared to send tee requests to the alternative, \u2018shadow\u2019 backend.</p> <pre><code>main: * -&gt; \"https://main.example.org\";\nsplit: Traffic(.1) -&gt; \"https://main.example.org\";\nshadow: Tee(\"shadow-test-1\") &amp;&amp; True() -&gt; \"https://shadow.example.org\";\n</code></pre>"},{"location":"tutorials/shadow-traffic/#4-apply-the-teeloopback-filter","title":"4. Apply the teeLoopback filter","text":"<p>Now we can apply the teeLoopback filter to the \u2018split\u2019 route, using the same label as we did in the Tee predicate.</p> <pre><code>main: * -&gt; \"https://main.example.org\";\nsplit: Traffic(.1) -&gt; teeLoopback(\"shadow-test-1\") -&gt; \"https://main.example.org\";\nshadow: Tee(\"shadow-test-1\") &amp;&amp; True() -&gt; \"https://shadow.example.org\";\n</code></pre> <p>Note that as of now, we need to increase the weight of the \u2018shadow\u2019 route by adding the <code>True()</code> predicate in order to avoid that the \u2018split\u2019 route would match the cloned request again.</p> <p>After this, the \u2018split\u2019 route will still send all the handled requests, 10% of the total traffic, to the main backend, while the rest of the traffic is routed there by the \u2018main\u2019 route. However, the teeLoopback filter will also clone the traffic of the \u2018split\u2019 route, 10% of the total, and reapply the routing on it, during which these requests will be matched by the Tee predicate, and sent to the shadow backend.</p>"}]}